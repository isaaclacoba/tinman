<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="es">
    <head>
    <meta charset="utf-8">
    <meta name="description" content="blog del proyecto Tinman">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Tinman | Tinman</title>

    
            <link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">

    
            <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

      <link rel="canonical" href="http://isaaclacoba.github.io/tinman/index.html">




    
        <!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->

    




</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://isaaclacoba.github.io/tinman/">

                <span id="blog-title">Tinman</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li>
<a href="archive.html">Archivo</a>
                </li>
<li>
<a href="categories/index.html">Tags</a>
                </li>
<li>
<a href="rss.xml">feed RSS</a>

                
            </li>
</ul>

            <ul class="nav navbar-nav navbar-right">
                
                
                    
                
            </ul>
        </div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav>

<!-- End of Menubar -->

<div class="container" id="content">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<div class="postindex">
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html" class="u-url">Justificación y objetivos del proyecto</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html" rel="bookmark"><time class="published dt-published" datetime="2015-01-24T11:06:19+01:00" itemprop="datePublished" title="2015-01-24 11:06">2015-01-24 11:06</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="tinman.jpg" class="align-center" id="logo-tinman" src="posts/justificacion-objetivos/tinman.jpg">
<p>En esta entrada se explicará brevemente qué es el proyecto Tinman, se
justificarán las razones por las cuales se está realizando este
proyecto, y por último, se listarán los objetivos que se pretenden
cumplir con el desarrollo del mismo.</p>
<div class="section" id="que-es-tinman">
<h2>¿Qué es Tinman?</h2>
<p><em>Tinman</em> es el nombre corto de mi trabajo fin de Grado(TFG), que se titula: "Instrumentación de un videojuego 3D con fines docentes". El videojuego será un clon del famoso juego de carreras arcade "<a class="reference external" href="http://es.wikipedia.org/wiki/Super_Off_Road">Super Off Road</a>", y de aquí es de donde surge <em>Tinman</em> como nombre de mi proyecto, a modo de broma, dado que el juego original llevó el nombre de Ivan "Ironman" Stewart, un famoso piloto del estilo <em>Off-Road</em>.</p>
<p>Este proyecto nació con el espíritu de crear un videojuego que fuese útil como caso práctico sobre el que estudiar toda una serie de técnicas relacionadas con el desarrollo de videojuegos. Es obvio que se trata de un proyecto muy ambicioso y por ello se ha de acotar el alcance del mismo. Del título, lo que más puede llevar a confusión sea la última parte, con fines docentes. Debido a que desarrollar un <em>Serius Game</em> específicamente orientado a desarrolladores se desmarca del objeto de evaluación dentro de un TFG, e incluso en una tesis de máster, el esfuerzo en este proyecto se ha centrado en desarrollar un código lo más limpio posible, sobre el que poder ejemplificar el uso de técnicas avanzadas como patrones de diseño o como <a class="reference external" href="http://programmers.stackexchange.com/a/94567">idioms</a> en C++, por poner algunos ejemplos.</p>
<p>Para que lo anterior fuese posible se decidió licenciar el código del proyecto, así como todo el contenido generado, bajo una licencia libre. En nuestro caso, el proyecto se licencia bajo GPLv3.Se decidió usar una licencia libre porque si se pretendía enseñar a quien lo deseara cómo fue creado el proyecto, la forma mas sencilla pasaba por dar libertad para leer el código, modificarlo y distribuir tanto modificaciones del proyecto original como copias del mismo. Creo que la mejor forma de aprender a programar es programando, y a mí me resulta mas sencillo si tengo algo sobre lo que empezar.</p>
<p>Por otra parte, no abundan proyectos libres en el mundo de los videojuegos y los que existen, o bien no se ha dado al código fuente el mimo que merece, o los creadores son ingenieros con una larga trayectoria, por lo que el código, aunque mantenible, flexible y bien estructurado, se hace difícil de estudiar para quien está comenzando a aprender y más complicado si estos proyectos están escritos en C++. Este lenguaje se ha convertido en estándar para la industria del videojuego, por múltiples razones. No sólo ofrece tanto mecanismos de muy alto nivel, tambien permite trabajar a nivel de dirección de memoria, de registro,...con lo que ofrece al ingeniero una flexibilidad que no se encuentra en otros lenguajes. Además, al ser compilado, permite optimizaciones de bajo nivel que no ofrecen otros lenguajes basados en máquinas virtuales o interpretados.</p>
<p>Pero alguien podría estar preguntándose: ¿realmente un videojuego se justifica como trabajo fin de Grado?</p>
<p>Según la "<a class="reference external" href="http://webpub.esi.uclm.es/archivos/336/Normativa-TFGs">Normativa sobre la elaboración y defensa del *Trabajo Fin
de Grado*</a>"
de la Escuela Superior de Informática de Ciudad Real, su artículo 2º
<em>Naturaleza del Trabajo Fin de Grado</em>, estipula lo siguiente:</p>
<p>"El Trabajo Fin de Grado supone la realización por parte del estudiante, y de forma
individual, de un proyecto, memoria o estudio bajo la supervisión de
uno o más tutores/as, en el que se integren y desarrollen los
contenidos formativos recibidos, capacidades, competencias y
habilidades adquiridas durante el periodo de docencia del Grado en
Ingeniería Informática"</p>
<p>El apaertado anterior señala que el TFG consiste en desarrollar, de manera individual, un proyecto, memoria o estudio; es decir, que no es requerida implementación alguna. El proyecto Tinman requiere la aplicación de técnicas avanzadas de ingeniería del Software, sigue una metodología concreta de desarrollo (<em>desarrollo orientado por pruebas</em>), requiere la capacidad para resolver problemas complejos, hace uso de un software de control de versiones, que ayuda a realizar un seguimiento del progreso del proyecto, etc. Todo esto hace que se cumpla  lo previamente citado para considerar este proyecto como TFG.</p>
<p>Por otra parte, en todo proyecto debe contemplarse, de una forma u otra, el contexto económico. En ese sentido, el sector de los videojuegos está en pleno auge. Por aportar algunas cifras, la empresa NewZoo en su <a class="reference external" href="http://www.newzoo.com/insights/global-games-market-will-reach-102-9-billion-2017-2/">publicación</a> sobre la situación mundial del mercado del videojuego señalaba que si la progresión de crecimiento actual se mantiene, se espera que la cifra de facturación mundial ascienda desde los 81.400 millones de dólares actuales en 2014 hasta los 102.900 millones en 2017. No hace es necesario ser economista para darse cuenta que el volumen de facturación es impresionante y que por sí sólo justifica la creación de nuevos proyectos orientados a este sector.</p>
<img alt="mercado-videojuego.png" class="align-center" id="grafico-mercado" src="posts/justificacion-objetivos/mercado-videojuego.png">
<p>Para finalizar, se listarán los objetivos que se pretenden cumplir.</p>
</div>
<div class="section" id="objetivos">
<h2>Objetivos</h2>
<p>En primer lugar se pretende desarrollar de un videojuego, utilizando
gráficos en 3D. Aunque el videojuego en sí ya es un objetivo de envergadura, este proyecto pretende utilizarlo como base para dos objetivos adicionales:</p>
<ul class="simple">
<li>Diseño e implementación de mecanismos de instrumentación del juego que permitan
aplicar técnicas de testing automático y al mismo tiempo exponer los mecanismos internos con fines didácticos y de depuración.</li>
<li>Diseño e implementación de un modelo de red para una modalidad multijugador, que
aprovechará los citados mecanismos de instrumentación con los mismos fines.</li>
</ul>
<p>Otro objetivo no menos importante es crear un ejemplo completo de videojuego que pueda servir a futuros programadores a aprender las técnicas básicas y los fundamentos técnicos esenciales del desarrollo de un videojuego. Por ese motivo se hará énfasis en los siguientes aspectos:</p>
<ul class="simple">
<li>Claridad del código.</li>
<li>Uso de patrones de diseño.</li>
<li>Técnicas de introspección de objetos.</li>
<li>Acceso al código fuente y al propio proyecto. Por esta razón se
distribuirá bajo una licencia libre.</li>
</ul>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/introduccion-ogre3d/introduccion-a-ogre3d.html" class="u-url">Introducción a Ogre3D</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/introduccion-ogre3d/introduccion-a-ogre3d.html" rel="bookmark"><time class="published dt-published" datetime="2015-01-03T10:41:32+01:00" itemprop="datePublished" title="2015-01-03 10:41">2015-01-03 10:41</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="ogre-logo.png" class="align-center" src="posts/introduccion-ogre3d/ogre-logo.png">
<p>En esta primera entrada hablaremos brevemente de Ogre3D, y de porqué
se ha elegido como biblioteca de renderizado. Para ejemplificarlo, se
ha creado un pequeño programa usando Ogre en el que se renderiza su
mascota, Sinbad, al mismo tiempo que servirá como ejemplo para mostrar
la estructura típica de un programa que hace uso de esta biblioteca.</p>
<p>Este post es una adaptación del tutorial que realicé hace unos meses y que podeis encontrar aquí: <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/overview">https://bitbucket.org/IsaacLacoba/intro-ogre/overview</a></p>
<div class="section" id="que-es-ogre3d">
<h2>¿Qué es Ogre3D?</h2>
<p>Ogre3D(<a class="reference external" href="http://www.ogre3d.org/">Object-Oriented Graphic Engine</a>) es
un motor de renderizado de propósito general creado por Steve
Streeting(tambien conocido como Sinbad) distribuido bajo licencia
LGPL(<a class="reference external" href="https://bitbucket.org/sinbad/ogre">repositorio-ogre3d</a>). Fue
creado en 2001(<a class="reference external" href="http://www.gamasutra.com/view/news/105533/QA_Steve_Streeting_On_Open_Source_3D_Engine_OGRE_3D.php">entrevista-streeting</a>)
con el propósito de crear un componente de renderizado en tiempo real
sin hacer asunciones a nivel de aplicación. El objetivo era crear un
componente genérico que pudiese ser ampliado a través de
plugins. Desde un principio el proyecto se diseñó teniendo en cuenta
la mantenibilidad y la facilidad de ampliación.</p>
<p>Ogre3D no fue concebido como un motor de juegos. Se pretendía cubrir
el mayor espectro posible,de manera que no sólo sirviese a campos como
el de los videojuegos, sino tambien a los de simulación, realidad
aumentada, realidad virtual,...y en general, cualquier campo que
requiriese del uso de herramientas de renderizado en tiempo real.</p>
<p>Además, el hecho de que se distribuya bajo una licencia de código
libre contribuye muchísimo más a su éxito. Esto es así debido a que la
comunidad está muy involucrada con el proyecto, cosa que podemos
observar en el <a class="reference external" href="http://www.ogre3d.org/forums/">foro oficial</a> del
proyecto, donde se resuelven dudas de desarrollo, se discute el
roadmap, etc. En cuanto a las <a class="reference external" href="http://www.ogre3d.org/developers/submit-patch">politica de contribuciones</a>, los usuarios de la
comunidad pueden colaborar bien realizando pull-request al repositorio
oficial con sus parches o bien reportando
bugs al <a class="reference external" href="https://ogre3d.atlassian.net/browse/OGRE/?selectedTab=com.atlassian.jira.jira-projects-plugin:summary-panel">Jira del proyecto</a></p>
<p>Como hemos dicho antes, Ogre3D no es un motor de juego. Esto implica
que será el desarrollador quien tenga que encargarse de aspectos como
la gestión de eventos de entrada (teclado,ratón,...), físicas, networking,
interfaces, etc. En el caso del desarrollo de interfaces existen maneras de crearlas
con Ogre a través del uso de overlays; sin embargo, esta
aproximación no es lo suficientemente flexible como para crear interfaces
avanzadas. Las características principales de Ogre son:</p>
<ul class="simple">
<li>
<strong>Mutiplataforma</strong>: permite el desarrollo para sistemas Windows, GNU/Linux y Mac OS X.</li>
<li>
<strong>Diseño a alto nivel</strong>: Ogre3D encapsula llamadas a las librerías
gráficas DirectX y OpenGL. Además, hace uso de patrones de diseño:
<em>observer</em> para informar de eventos y cambios de estado,
<em>singleton</em> para evitar que exista mas de una instancia de
cualquier manager, <em>visitor</em> para realizar operaciones sobre
un objeto y evitar modificarlo (por ejemplo, en los nodos del grafo
de escena), <em>façade</em> para unificar el acceso a operaciones,
<em>factory</em> para creación de objetos concretos de interfaces
abstractas, etc.</li>
<li>
<strong>Grafo de escena</strong>: una de las características mas
importantes del grafo de escena de Ogre es que desacopla el propio
grafo del contenido de la escena, definiendo una arquitectura de
pugins. A diferencia de otros motores gráficos, como Irrlicht3D,
Blitz3D o Unreal, Ogre no se basa en la herencia como principio de
diseño del grafo, sino en la composición. Esto permite expandir el
diseño para soportar otros tipos de datos, como audio o elementos de
simulación física. En la siguiente figura podemos ver
el esquema general del grafo de escena de Ogre.</li>
</ul>
<div class="line-block">
<div class="line"><br></div>
</div>
<img alt="Jerarquía general del grafo de escena." class="align-center" id="my-picture" src="posts/introduccion-ogre3d/grafo-escena.png" style="width: 250px;">
<div class="line-block">
<div class="line"><br></div>
</div>
<ul class="simple">
<li>
<strong>Aceleración Hardware</strong>: OGRE permite definir el comportamiento
de la parte programable de la GPU mediante la definición de Shaders,
estando al mismo nivel de otros motores como Unreal o CryEngine.</li>
<li>
<strong>Materiales</strong>: se definen mediante un sistema de scripts y permiten
asignar o cambiar los materiales de los elementos de la escena sin
modificar el código fuente.</li>
<li>
<strong>Animación</strong>: tres tipos(skeletal, morph y pose). La animación y la
geometría asociada a los modelos se almacena en un único formato
binario optimizado. El proceso mas empleado se basa en la
exportación desde la aplicación de modelado y animación 3D a un
formato XML (Ogre XML) para convertirlo posteriormente al formato
binario optimizado mediante la herramienta de línea de órdenes
OgreXMLConverter.</li>
<li>
<strong>Composición y Postprocesado</strong>.</li>
<li>
<strong>Plugins</strong>.</li>
<li>
<strong>Gestión de Recursos</strong>: Ogre ofrece una serie de gestores de
recursos, organizados jerárquicamente por grupos.</li>
<li>
<strong>Características específicas avanzadas</strong>: El motor soporta gran
cantidad de características de visualización avanzadas, tales como
sombras dinámicas (basadas en diversas técnicas de cálculo),
sistemas de partículas, animación basada en esqueletos y de
vértices, y un largo etcétera. OGRE soporta además el uso de otras
bibliotecas auxiliares mediante plugins y conectores. Entre los más
utilizados cabe destacar las bibliotecas de simulación física ODE,
el soporte del metaformato Collada, o la reproducción de streaming
de vídeo con Theora.</li>
</ul>
</div>
<div class="section" id="veamos-algo-de-codigo">
<h2>Veamos algo de código</h2>
<p>El código fuente del ejemplo que vamos a estudiar lo podemos encontrar
en el siguiente repositorio:
<a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/overview">https://bitbucket.org/IsaacLacoba/intro-ogre/overview</a>.</p>
<p>Se ha creado un <em>¡Hola Mundo!</em> en Ogre3D con la intención de que fuese
lo más sencillo posible. Por esta razón, lo único que hace el ejemplo
es renderizar la mascota de Ogre, Sinbad. En la <a class="reference external" href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Tutorials">wiki del proyecto
Ogre</a>
hay una colección muy interesante de tutoriales que es recomendable
que el lector interesado estudie. En los listados de código, intentaremos mostrar únicamente el código que se añade en cada paso.</p>
<p>Pero antes de empezar, vamos a explicar como instalar Ogre3D en un
sistema operativo GNU/Linux. Consulta este <a class="reference external" href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Installing+the+Ogre+SDK">tutorial</a>
para saber como instalar Ogre3D en un sistema Microsoft Windows.</p>
</div>
<div class="section" id="instalacion">
<h2>Instalación</h2>
<p>En distribuciones de GNU/Linux, la instalación de Ogre3D pasa por
instalar los siguientes paquetes:</p>
<pre class="code bash literal-block">
<span class="c"># apt-get update apt-get install libogre-1.8.0 libogre-1.8-dev libogre-1.8.0-dbg freeglut3-dev libfreetype6 libfreetype6-dev libgl1-mesa-dev libgl1-mesa-glx</span>
</pre>
<p>Los tres primeros paquetes nos instalarán Ogre3D. Los siguientes
paquetes son dependencias indirectas de Ogre, los primeros de OpenGL y
los dos últimos instalarán el driver gráfico mesa.</p>
<div class="section" id="comprobando-la-instalacion">
<h3>Comprobando la instalación</h3>
<p>Aunque el proceso de instalación ha sido extremadamente complejo, no
está de más comprobar que todo haya ido bien. Para comprobar que Ogre
se ha instalado correctamente, crearemos una instancia del objeto Root
y compilaremos el código.</p>
<p>Primero, crearemos un fichero de texto llamado <em>main.cpp</em> con el siguiente código:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 162)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   #include &lt;OgreRoot.h&gt;

   int main(int argc, char argv*[]) {
      Ogre::Root* root = new Ogre::Root("config/plugins.cfg", "config/ogre.cfg", "config/ogre.log");
   }

</pre>
</div>
<p>Para poder compilarlo, crearemos un sencillo makefile con el siguiente
código. Crea un fichero llamado Makefile y escribe el siguiente
codigo:</p>
<pre class="code make literal-block">
<span class="nv">CXX</span><span class="o">=</span>g++
<span class="nv">CXXFLAGS</span> <span class="o">=</span> -std<span class="o">=</span>c++11 -ggdb <span class="k">$(</span>shell pkg-config --cflags OGRE OIS<span class="k">)</span>
<span class="nv">LDLIBS</span> <span class="o">=</span> <span class="k">$(</span>shell pkg-config --libs OGRE OIS<span class="k">)</span>

<span class="nf">main</span><span class="o">:</span> <span class="m">main.cpp</span>
</pre>
<p>Para compilarlo, abriremos un terminal en la carpeta donde
tengamos el codigo fuente y ejecutaremos:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>make
</pre>
<p>Esto compilara nuestro codigo. Si la compilación se realizó sin
problemas, procederemos a ejecutar el binario:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>./main
</pre>
<p>Si todo ha ido bien, la traza de inicialización de Ogre debiera
mostrarse por terminal y en el fichero "config/ogre.log". Hecho
esto, habremos comprobado que hemos instalado correctamente Ogre en
nuestro sistema. Ahora, continuemos construyendo nuestro ejemplo.</p>
</div>
</div>
<div class="section" id="sigamos-programando">
<h2>Sigamos programando</h2>
<p>El objeto que acabamos de crear es el objeto principal de Ogre, el
cual inicializa todos los componentes internos. Recibe hasta tres
parámetros, los cuales son las rutas a tres ficheros de configuración:
el primero indica la ruta de los plugins que se van a usar, el segundo
indica la configuración básica del sistema de renderizado(OpenGL o
DirectX, tamaño de la pantalla, frecuencia de refresco,...) y el
tercero es la ruta hacia el log donde Ogre volcará la traza, tanto de
inicialización como de destrucción de los recursos. Indicándole la
ruta hacia los ficheros, Ogre se encargará de crearlos si no
existiesen, únicamente en los dos últimos casos. En el caso del
fichero de plugins, hay que indicarle la ruta, ya que por defecto Ogre
no sabe donde buscarlos.</p>
<p>Una vez hecho esto, añadiremos el siguiente código que permite indicar
a Ogre la configuración básica del sistema de renderizado:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 223)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   void check_config(Ogre::Root* root) {
      if (not (root-&gt;restoreConfig() || root-&gt;showConfigDialog())) {
         Ogre::LogManager::getSingleton().logMessage("Initialize::configure_ogre =&gt; " +
         std::string("ERROR: unable to configure Ogre"));
      }
   }

   int main(int argc, char *argv[]) {
     Ogre::Root* root = new Ogre::Root("config/plugins.cfg", "config/ogre.cfg", "config/ogre.log");
     check_config(root);

     return 0;
   }

</pre>
</div>
<p>Al ejecutarlo por primera vez, debería aparecer una pantalla como la siguiente:</p>
<div class="line-block">
<div class="line"><br></div>
</div>
<img alt="configuracion-ogre.png" class="align-center" src="posts/introduccion-ogre3d/configuracion-ogre.png">
<div class="line-block">
<div class="line"><br></div>
</div>
<p>Este dialogo aparecerá cuando Ogre no encuentre el fichero
"config/ogre.cfg" (es decir, Ogre::Root::restoreConfig() devuelva
falso) e invoque al método Ogre::Root::showConfigDialog(). Debemos
asegurarnos de que la opción <em>Full Screen</em> este marcada como
<em>No</em>, de modo que podamos cerrar la aplicación de forma
correcta mas adelante. Hecho esto, podemos pulsar
<em>Accept</em>. Internamente, Ogre invocará a los métodos
Ogre::Root::SetRenderSystem, Ogre::RenderSystem::setConfigOption y
Ogre::Root::saveConfig que establecen el sistema de renderizado, la
configuración del mismo y guardan dicha configuración en un fichero de
texto.</p>
<p>El siguiente paso consiste en crear la ventana de nuestra aplicación,
donde se renderizará la escena. Existen dos formas de crear una
ventana: la primera es usando el constructor de la clase
Ogre::RenderWindow. La segunda, mas sencilla, es dejar que Ogre cree
una por defecto, basándose en la configuración obtenida del paso
anterior:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 267)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   #include &lt;OgreRenderWindow.h&gt;
   (...)
   int main(int argc, char *argv[]) {
      Ogre::Root* root = new Ogre::Root("config/plugins.cfg", "config/ogre.cfg", "config/ogre.log");
      check_config(root);
      Ogre::RenderWindow* window = root-&gt;initialize(true, "Titulo");
   }

</pre>
</div>
<p>Añadimos el fichero de cabecera y creamos la ventana por defecto con el método
Ogre::Root:initialize. El primer parámetro indica a Ogre que queremos que cree un
Ogre::RenderWindow. Internamente se invocará al método
Ogre::Root::createRenderWindow. Es importante señalar que solo se
puede invocar este método después de haber obtenido la configuración
básica del sistema de renderizado.</p>
<p>Tras esto, procederemos a inicializar el gestor de escena:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 286)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

  (...)

   int main(int argc, char *argv[]) {

   (...)
      Ogre::SceneManager* scene_manager = root-&gt;createSceneManager(Ogre::ST_GENERIC);
  }

</pre>
</div>
<p>La clase Ogre::SceneManager se encarga de organizar el
<em>culling</em> y el proceso de renderizado de la escena, junto con
la clase Ogre::RenderQueue. Del mismo modo que antes, hacemos uso de
la instancia del objeto Root para inicializar el gestor de escena. El
método Ogre::Root::createSceneManager acepta un tipo enumerado llamado
<a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/group___scene.html#gga7383602bd480d43b80c626969b9af914a0af8f844019e52fe112e9a946a919fcd">Ogre::SceneType</a>. Este tipo enumerado le indica a
Ogre qué tipo de <a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/class_ogre_1_1_scene_manager.html">SceneManger</a> tiene que
devolver (para mas información ver el <a class="reference external" href="http://www.ogre3d.org/tikiwiki/SceneManagersFAQ#Selecting_a_Scene_Manager">faq</a> ).</p>
<p>El gestor de escena nos permitirá crear nuestros nodos de escena y
las entidades donde se cargarán las mallas 3D. Para ello, necesitamos
tener algo que renderizar, de modo que vamos a descargarnos las
mallas.</p>
<div class="section" id="obteniendo-recursos-multimedia">
<h3>Obteniendo recursos multimedia</h3>
<p>En Internet podemos encontrar gran cantidad de contenido con licencia
creative commons que nos permitirá trabajar libremente con él, aunque
siempre hay que mirar cuidadosamente qué tipo de licencia tiene el
contenido multimedia que vamos a usar y respetarla en todo
momento. Para nuestro primer ejemplo, utilizaremos la mascota de
Ogre3D, Sinbad. Para ello, nos iremos al repositorio del
<a class="reference external" href="https://bitbucket.org/sinbad/ogre/src/046a0d6687d11a4413db3bbb8d49cc721b083a48/Samples/Media/packs/?at=default">proyecto</a>, a la carpeta <strong>Samples/Media/Packs</strong>,
donde podremos encontrar mallas listas para ser usadas. Nos
descargaremos el pack llamadado <em>Sinbad.zip</em>. A continuación,
crearemos una carpeta llamada <em>media</em> dentro del directorio de
nuestro proyecto y descompromimos el contenido del archivo .zip allí.</p>
<p>Hecho esto, los siguientes pasos que nos quedan son crear un nodo y
una entidad, adjuntar la entidad al nodo, así como crear un foco de
luz y una cámara.</p>
</div>
<div class="section" id="creando-nuestra-escena">
<h3>Creando nuestra escena</h3>
<p>El siguiente paso que deberemos realizar será crear un fichero que
permita saber a Ogre donde están los recursos multimedia. Dentro de la
carpeta <em>config</em> crearemos un fichero llamado "resources.cfg"
con el siguiente contenido:</p>
<pre class="code bash literal-block">
<span class="o">[</span>General<span class="o">]</span>
<span class="nv">FileSystem</span><span class="o">=</span>media
</pre>
<p>Esto simplemente le indica a Ogre que dentro de la carpeta media
encontrara los recursos multimedia. Pero primero hay que parsear el
fichero y cargar dichos recursos.</p>
</div>
<div class="section" id="cargando-los-recursos">
<h3>Cargando los recursos</h3>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 349)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   (...)
   #include &lt;OgreResourceGroupManager.h&gt;
   #include &lt;OgreConfigFile.h&gt;

   void load_resources(string resources_file) {
       Ogre::ConfigFile cf;
       cf.load(resources_file);

       Ogre::ConfigFile::SectionIterator seci = cf.getSectionIterator();

       Ogre::String secName, typeName, archName;
       while (seci.hasMoreElements()) {
         secName = seci.peekNextKey();
         Ogre::ConfigFile::SettingsMultiMap *settings = seci.getNext();
         Ogre::ConfigFile::SettingsMultiMap::iterator i;
         for (i = settings-&gt;begin(); i != settings-&gt;end(); ++i) {
           typeName = i-&gt;first;
           archName = i-&gt;second;
           Ogre::ResourceGroupManager::getSingleton()
             .addResourceLocation(archName, typeName, secName);
         }
       }

       Ogre::ResourceGroupManager::getSingleton()
         .initialiseAllResourceGroups();
   }

   int main(int argc, char *argv[])
   {
     (...)
     load_resources("config/resources.cfg");
   }


</pre>
</div>
<p>La función anterior abre el fichero y lo va
recorriendo buscando claves. Cada clave indica el nombre de
un directorio donde hay recursos multimedia. Estos directorios los
recorre en el bucle <em>for</em> buscando archivos de los que saca
el tipo, el nombre y los registra dentro del gestor de recursos
(Ogre::ResourcerGroupManager). Tras registrar todos los recursos que
haya encontrado, los inicializa.</p>
<p>Es importante que se invoque la función
<em>load_resources(string)</em> antes que la función
<em>check_config(Ogre::Root)</em> en el caso en el que usemos
Ogre::Overlay. Si se invoca en orden contrario, el programa compilará
correctamente, pero lanzará un error de segmento.</p>
<p>Este paso nos permitirá utilizar los recursos multimedia en nuestra
escena. Pero primero, deberemos crearemos la cámara y un foco de
luz.</p>
</div>
<div class="section" id="creando-nuestra-camara">
<h3>Creando nuestra cámara</h3>
<p>El objeto Ogre::Camera define la cámara de la escena. Este objeto es
imprescindible, pues sin él no podremos ver nada en nuestra
ventana. Para ello, añadiremos el siguiente código:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 410)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   (...)
   #include &lt;OgreCamera.h&gt;

   Ogre::Camera* create_camera(Ogre::Root* root) {
     Ogre::Camera* camera = root-&gt;getSceneManager("SceneManager")-&gt;createCamera("Camera");

     camera-&gt;setPosition(Ogre::Vector3(0, 160, 160));
     camera-&gt;lookAt(Ogre::Vector3(0,0,0));
     camera-&gt;setNearClipDistance(5);
     camera-&gt;setFarClipDistance(10000);


     Ogre::Viewport* viewport = root-&gt;getAutoCreatedWindow()-&gt;addViewport(camera);
     viewport-&gt;setBackgroundColour(Ogre::ColourValue(0, 0, 0));

     camera-&gt;setAspectRatio(Ogre::Real(viewport-&gt;getActualWidth()) / Ogre::Real(viewport-&gt;getActualHeight()));

     return camera;
   }

   int main(int argc, char *argv[]){
    (...)
     Ogre::Camera* camera = create_camera(root);
   }


</pre>
</div>
<p>En esta ocasión, utilizamos el gestor de escena para crear una cámara
asociada a él. Ogre permite tener mas de un gestor de escena, e ir
cambiando entre ellos. Es por esta razón que hay que asociar la cámara
a un gestor de escena.</p>
<p>El objeto Ogre::Viewport es el equivalente al frustrum de la cámara;
es decir, indica la región que sera renderizada.</p>
<p>Una vez inicializada la cámara, es importante añadir una fuente de
luz, ya que por defecto el mundo se haya en tinieblas:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 449)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   void create_light(Ogre::Root* root){
     Ogre::SceneManager* manager = root-&gt;getSceneManager("SceneManager");
     manager-&gt;setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_ADDITIVE);

     manager-&gt;setAmbientLight(Ogre::ColourValue(0.25, 0.25, 0.25));

     Ogre::Light* light = manager-&gt;createLight("MainLight");
     light-&gt;setPosition(20, 80, 50);
     light-&gt;setCastShadows(true);

   }

   int main(int argc, char *argv[])
   {
     (...)
     create_light(root);
   }


</pre>
</div>
<p>El método Ogre::SceneManager:setShadowTechnique(Ogre::ShadowTechnique)
asigna la técnica de generación de sombras que sera usada por este
gestor de escena. El tipo <a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/group___general.html#ga79dcd426d291c31072c1ad6f183715d6">Ogre::ShadowTechnique</a>
es un tipo enumerado que permite seleccionar una técnica de generación
de sombra.</p>
<p>Una vez que tenemos listo todo lo necesario para que pueda renderizarse
nuestra escena, procederemos a crearla añadiendo nodos de escena.</p>
</div>
<div class="section" id="anadiendo-nodos-a-nuestra-escena">
<h3>Añadiendo nodos a nuestra escena</h3>
<p>La forma en que Ogre desencapsula el grafo de escena y los objetos de
los mismos es mediante el objeto Ogre::SceneNode. Los objeto SceneNode
son los cuerpos gráficos genéricos sobre los que se realizarán las
operaciones de traslación, rotación, etc. A estos nodos hay que
adjuntarles un contenido, típicamente un objeto de tipo Ogre::Entity,
aunque se pueden adjuntar otros tipos de objetos. Veamos el código:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 491)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   (...)
   #include &lt;OgreEntity.h&gt;
   #include &lt;OgreVector3.h&gt;
   #include &lt;OgreMath.h&gt;
   #include &lt;OgreMeshManager.h&gt;

   (...)
   Ogre::SceneNode* get_node_by_name(Ogre::SceneManager* manager,
                                    Ogre::String node_name="") {
     Ogre::SceneNode* node;
     if (node_name.empty())
       node = manager-&gt;getRootSceneNode();
     else
       node = manager-&gt;getSceneNode(node_name);

     return node;
   }

   Ogre::Entity* create_entity_and_attach(Ogre::SceneManager* manager,
                                          Ogre::String name,
                                          Ogre::String mesh,
                                          Ogre::String target_node="",
                                          bool cast_shadows=true){
     Ogre::SceneNode* node = get_node_by_name(manager, target_node);
     Ogre::Entity* entity = manager-&gt;createEntity(name, mesh);
     entity-&gt;setCastShadows(cast_shadows);

     node-&gt;attachObject(entity);
     return entity;
   }
   Ogre::SceneNode* create_node(Ogre::SceneManager* manager,
                                Ogre::String name,
                                Ogre::String parent="") {
     Ogre::SceneNode* parent_node = get_node_by_name(manager, parent);

       return parent_node-&gt;createChildSceneNode(name);
   }


   Ogre::SceneNode* create_node_and_entity(Ogre::SceneManager* manager,
                                           Ogre::String name,
                                           Ogre::String mesh,
                                           Ogre::String parent="") {
     Ogre::SceneNode* node = create_node(manager, name, parent);
     Ogre::Entity* entity = create_entity_and_attach(manager, name, mesh, name);
       return node;
   }

   int main(int argc, char *argv[]) {
   (...)
     Ogre::SceneNode* node = create_node_and_entity(scene_manager, "SinbadNode", "Sinbad.mesh");

   }


</pre>
</div>
<p>Las funciones anteriores son funciones de alto nivel que encapsulan
una funcionalidad relacionada con el nombre de la función. Aunque
parezca mucho código, las sentencias mas importantes son:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 552)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

  parent_node-&gt;createChildSceneNode(name);


</pre>
</div>
<p>La sentencia anterior genera un nodo hijo cuyo nodo raíz es el nodo
padre(<em>parent_node</em>). Esto es muy útil, ya que todas las
transformaciones que sufra el padre tambien las sufrirá el hijo. De
esta forma, podemos generar cuerpos compuestos y mover únicamente el
nodo padre, sabiendo que los nodos hijos se moverán de igual forma.</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 563)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

  Ogre::Entity* entity = manager-&gt;createEntity(name, mesh);


</pre>
</div>
<p>Esta sentencia crea una instancia de un objeto tipo Ogre::Mesh. La
clase Ogre::Mesh almacena los datos necesarios para representar un
objeto tridimensional. Dicha malla la hemos cargado anteriormente en
el método <em>load_resources(std::string)</em>.</p>
<p>Por último, utilizamos dos funciones muy similares para obtener la
referencia a los SceneNode por su nombre:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 576)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   Ogre::SceneManager::getRootSceneNode();
   Ogre::SceneManager::getSceneNode(Ogre::String node_name);


</pre>
</div>
<p>El primero devuelve la referencia al nodo raíz del grafo de escena y
el segundo al nodo que coincida con el nombre que se le pase por
argumentos.</p>
<p>Por último, debemos añadir la sentencia que renderiza la escena. Para
poder parar nuestra aplicación, en este documento se hará uso de la
clase Ogre::WindowEventListener, que cuenta con el método
WindowClosing y windowClosed. Para ello crearemos una clase y haremos
que herede de Ogre::WindowEventListener:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 592)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   #include &lt;OgreWindowEventUtilities.h&gt;

   class WindowManager: public Ogre::WindowEventListener{
     Ogre::RenderWindow* window_;

   public:
     bool exit;

     WindowManager(Ogre::RenderWindow* window){
       window_ = window;
       exit = false;
       Ogre::WindowEventUtilities::addWindowEventListener(window, this);
     }

     bool windowClosing(Ogre::RenderWindow* window){
       Ogre::LogManager::getSingleton().logMessage("Closing window...");
       exit = true;
       return true;
     }

     void windowClosed(Ogre::RenderWindow* window) {
       Ogre::LogManager::getSingleton().logMessage("Window closed.");
       exit = true;
     }

   int main(int argc, char *argv[])
   {
     (...)
     WindowManager windowManager(window);

     while(!windowManager.exit){
       root-&gt;renderOneFrame();
       Ogre::WindowEventUtilities::messagePump();
     }
   }
   };


</pre>
</div>
<p>La clase Ogre::WindowEventListener se encarga de gestionar todos los
eventos relacionados con una ventana.</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 635)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   Ogre::WindowEventUtilities::addWindowEventListener(window, this);

</pre>
</div>
<p>La sentencia anterior se encarga de registrar la instancia de la clase
WindowManager como gestor de todos los eventos producidos en
<em>window</em>. Los métodos <em>windowClosed</em> y
<em>windowClosing</em> se ejecutan cuando se detecta un evento de
cierre de ventana; es decir, cuando se pulsa el botón de salir de la
esquina superior derecha de la ventana.</p>
<p>Se ha añadido el bucle principal a la función principal. El método
<em>renderOneFrame</em> indica a Ogre que debe actualizar los cuerpos
gráficos de la escena, muestras que la sentencia
<em>messagePump()</em> debe ser llamada una vez por frame, ya que
actualizará todas las ventanas que hayan sido registradas.</p>
<p>Hecho esto, habremos terminado. Sólo faltará compilar y ejecutar
nuestra aplicación. El resultado deberá ser parecido al de la
siguiente figura.</p>
<div class="line-block">
<div class="line"><br></div>
</div>
<blockquote>
<img alt="captura-ejecucion.png" class="align-center" src="posts/introduccion-ogre3d/captura-ejecucion.png">
</blockquote>
<div class="line-block">
<div class="line"><br></div>
</div>
<p>El código final debe parecerse al del fichero que podremos encontrar
en el <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/src/47e9565d0897607426587ef70798496f44f23ec8/src/main.cpp?at=master">repositorio de este tutorial</a></p>
<!-- LocalWords:  renderizada -->
</div>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/presentacion/presentacion.html" class="u-url">Presentación</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/presentacion/presentacion.html" rel="bookmark"><time class="published dt-published" datetime="2014-12-03T23:07:15+01:00" itemprop="datePublished" title="2014-12-03 23:07">2014-12-03 23:07</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="tinman.jpg" class="align-center" src="posts/presentacion/tinman.jpg">
<p>Este blog servirá como registro donde quedará plasmada la evolución de mi proyecto fin de grado.</p>
<p>En él se explicará el porqué de cada decisión que se ha tomado y se tomará durante el desarrollo
del mismo de una forma sencilla y concisa, desarrollando las distintas alternativas que se han tenido
en consideración en cada momento.</p>
<p>El código fuente del proyecto se puede encontrar en el siguiente link: <a class="reference external" href="https://bitbucket.org/arco_group/tfg.tinman">https://bitbucket.org/arco_group/tfg.tinman</a></p>
<div class="section" id="acerca-de-mi">
<h2>Acerca de mí:</h2>
<p>Me llamo Isaac y actualmente soy estudiante de Grado en Ingeniería Informática en la Escuela Superior de Informática de Ciudad Real.
Soy oootro apasionado mas de la tecnología, prueba de ello es que haya elegido usar Nikola como generador de mi blog y github pages
como lugar donde alojarlo, en lugar de las miles de soluciones existentes que te facilitan la vida. Porque pudiendo seguir la solución dificil, ¿para qué vas a seguir la fácil?</p>
<p>Esto último define bien mis preferencias. Desde siempre he sido un apasionado de los videojuegos. Y ya que el proyecto fin de grado es el broche final a lo que ha sido, hasta el momento, mi experiencia como estudiante universitario, decidí que sería perfecto finalizar con un proyecto que me definiese como ingeniero y como persona.</p>
</div>
</div>
    </div>
    </article>
</div>







        </div>
        <!--End of body content-->

        <footer>
            Contents © 2015         <a href="mailto:isaac.lacoba@gmail.com">Isaac Lacoba Molina</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
    </div>
</div>


            <script src="assets/js/all-nocdn.js"></script>
        <script src="assets/js/colorbox-i18n/jquery.colorbox-es.js"></script>
    
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul>
<li>
<a class="addthis_button_facebook"></a>
</li>
<li>
<a class="addthis_button_google_plusone_share"></a>
</li>
<li>
<a class="addthis_button_linkedin"></a>
</li>
<li>
<a class="addthis_button_twitter"></a>
</li>
</ul>
</div>
<script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script>jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    <!-- fancy dates -->
    <script>
    moment.locale("es");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script>
    <!-- end fancy dates -->
    
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-57580832-1', 'auto');ga('send', 'pageview');</script>

</body>
</html>
