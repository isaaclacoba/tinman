<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="es">
    <head>
    <meta charset="utf-8">
    <meta name="description" content="blog del proyecto Tinman">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Tinman | Tinman</title>

    
            <link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">

    
            <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

      <link rel="canonical" href="http://isaaclacoba.github.io/tinman/index.html">




    
        <!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->

    




</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://isaaclacoba.github.io/tinman/">

                <span id="blog-title">Tinman</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li>
<a href="archive.html">Archivo</a>
                </li>
<li>
<a href="categories/index.html">Tags</a>
                </li>
<li>
<a href="rss.xml">feed RSS</a>

                
            </li>
</ul>

            <ul class="nav navbar-nav navbar-right">
                
                
                    
                
            </ul>
        </div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav>

<!-- End of Menubar -->

<div class="container" id="content">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<div class="postindex">
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/creando-coche/creando-coches-para-el-juego.html" class="u-url">Creando coches para el juego</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/creando-coche/creando-coches-para-el-juego.html" rel="bookmark"><time class="published dt-published" datetime="2015-03-07T13:52:25+01:00" itemprop="datePublished" title="2015-03-07 13:52">2015-03-07 13:52</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="tinman.jpg" class="align-center" id="logo-tinman" src="posts/creando-coche/tinman.jpg">
<p>En esta entrada se va a hablar acerca del componente de dinámica de
vehículos que incorpora Bullet Physics, el motor de físicas que se
está usando en este proyecto. Se explicará como inicializar el
vehículo y los elementos mas relevantes de éste módulo de Bullet. Por
último, mostraremos un pequeño ejemplo que servirá para ejemplificar
lo hablado en esta entrada.</p>
<p>Pero para empezar, vamos a introducir brevemente los principios
físicos que permiten el movimiento de un coche.</p>
<div class="section" id="un-poco-de-teoria">
<h2>Un poco de teoría</h2>
<p>A grandes rasgos, el movimiento de un coche radica en un conjunto de
fuerzas que se aplican sobre las ruedas y el chasis del vehículo. En
la dirección del movimiento del coche se aplica una fuerza
longitudinal, compuesta por la fuerza que aplican las ruedas, la
fuerza de frenado, la resistencia que oponen los neumáticos y la
resistencia del aire. Por otro lado, en giros existen fuerzas
laterales causadas por la fricción lateral de las ruedas, además del
momento angular del coche y el esfuerzo de torsión causado por las
fuerzas laterales.</p>
<p><em>Nota:</em> este apartado es un resume del siguiente <a class="reference external" href="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html">artículo</a></p>
<div class="section" id="movimientos-rectilineos">
<h3>Movimientos rectilíneos</h3>
<p>La primera fuerza que entra en juego es la fuerza de tracción. La
fuerza de tracción es ocasionada por la fricción del neumático contra
la superficie del asfalto, que es ocasinada por el desplazamiento
del neumático contra el asfalto debido al par motor aplicado por este.</p>
<p>El par motor es el momento de fuerza que ejerce el motor del coche
sobre el eje de transmisión, expresado en N.m. El par motor que
puede entregar depende de la velocidad a la cuál este gira,
típicamente expresada en rpm. La relación momento torsor/rpm no es
lineal, pero se representa normalmente como una curva llamada función
del momento torsor (La curva exacta de cada motor viene determinada
por los test que los fabricantes los someten estos motores). Aquí
vemos un ejemplo para el motor del Corvette LS1(5.7 litros V8).</p>
<div class="figure align-center">
<img alt="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/cttorq.gif" src="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/cttorq.gif">
<p class="caption">Curva de par motor/potencia del Corvette LS1</p>
</div>
<p>El eje de abscisas está expresado en revoluciones por minuto(rpm) y el
de ordenadas en Caballos de potencia. La curva anterior sólo esta
definida en el rango de rpm en el que trabaja el motor, que para el
ejemplo es en el intervalo 1000 y 6000 rpm. La curva de par motor
representa la máxima potencia que puede entregar el motor para unas
rpm dadas.</p>
<p>El par motor se transmite a través de los engranajes hasta llegar a
las ruedas, que se acaba conviertiendo en una fuerza a través del giro
de esta sobre la carretera, dividido por el radio.  La siguiente
imagen ilustra el proceso:</p>
<div class="figure align-center">
<img alt="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/tc_torques.png" src="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/tc_torques.png">
<p class="caption">Par motor aplicado sobre el eje de tracción</p>
</div>
<p>A continuación podemos ver la formula que convierte el par motor
proporcionado por el motor en fuerza de "conducción"; es decir, la
fuerza longitudinal que ejercen las ruedas del eje de tracción sobre la
carretera:</p>
<div class="math">
\begin{equation*}
Fconducción = \frac{u * Pmotor * Xg * Xm * n}{Rw}
\end{equation*}
</div>
<p>Donde:</p>
<ul class="simple">
<li>u es el vector unitario que refleja la orientación del coche</li>
<li>Pmotor es el par motor en rpm</li>
<li>xm es la relación de transmisión de las marchas</li>
<li>xd es el coeficiente del <a class="reference external" href="http://es.wikipedia.org/wiki/Mecanismo_diferencial">diferencial</a>
</li>
<li>n es la eficiencia de la transmisión</li>
<li>Rw es el radio de la rueda.</li>
</ul>
<p>Si esta fuera la única fuerza que influye en el movimiento, el coche
aceleraría hasta alcanzar una velocidad infinita. Aquí es donde entran
en juego las resistencia. A altas velocidades la mas importante es la
resistencia del aire. Esta fuerza es muy importante porque es
proporcional al cuadrado de la velocidad.</p>
<div class="math">
\begin{equation*}
Fdrag = - Cdrag * v * |v|
\end{equation*}
</div>
<p>Donde:</p>
<ul class="simple">
<li>Cdrag es una constante de resistencia del aire.</li>
<li>v es el vector de velocidad.</li>
<li>|v| el módulo del vector.</li>
</ul>
<p>El módulo del vector velocidad es la velocidad a la que nos referimos
comunmente, expresada en km/h cuando hablamos de vehículos.</p>
<p>La siguiente resistencia que encontramos es la resistencia al giro. Es
causada por la fricción entre la goma del neumático y la superficie de
contacto debido al desplazamiento de las ruedas.</p>
<div class="math">
\begin{equation*}
Frr = -Crr Frr = - Crr * v
\end{equation*}
</div>
<p>Donde:</p>
<ul class="simple">
<li>Crr es una constante de rozamiento.</li>
<li>v el vector de velocidad.</li>
</ul>
<p>A bajas velocidades la resistencia al giro es la mayor resistencia que
encuentra el coche, mientras que a altas velocidades sería la
resistencia del aire.</p>
<p>La fuerza logitudinal total es la suma de estas tres fuerzas:</p>
<div class="math">
\begin{equation*}
Flongitudinal =   Fconducción + Fdrag   + Frr
\end{equation*}
</div>
</div>
<div class="section" id="transferencia-de-peso">
<h3>Transferencia de peso</h3>
<p>Un efecto importante cuando se acelera o frena es el efecto de la
transferencia dinámica de peso. Cuando se frena el coche baja el morro
hacia adelante. Durante la aceleración, el coche se inclina hacia
atrás. Esto es debido a que el centro de gravedad el coche cambia. El
efecto de esto es que el peso sobre las ruedas traseras aumenta
durante la aceleración, mientras que las ruedas delanteras deben
soportar menos peso.</p>
<p>La distribución de peso afecta dramáticamente a la tracción máxima por
rueda. Esto es debido a que el límite de fricción es proporcional a la
carga en esa rueda:</p>
<div class="math">
\begin{equation*}
Fmax = mu * Pesocoche
\end{equation*}
</div>
<p>Donde:
- mu es coeficiente de rozamiento del neumático.</p>
<p>Para vehiculos estacionados el peso total del coche (W = M*g) se
distribuye sobre las ruedas delanteras y traseras de acuerdo a la
distancia entre la parte el eje delantero y trasero al centro de masa:</p>
<div class="math">
\begin{equation*}
Peso ruedas traseras = \frac{c}{L} * M
\end{equation*}
</div>
<div class="math">
\begin{equation*}
Peso ruedas delanteras = \frac{b}{L} * M
\end{equation*}
</div>
<p>Donde:</p>
<ul class="simple">
<li>
<em>b</em> y <em>c</em> son la distancia al centro de gravedad de los ejes delanteros y traseros.</li>
<li>
<em>L</em> es el grosor de las ruedas.</li>
</ul>
<p>Si el coche acelera o desacelera en un factor a, el peso frontal y trasero se calculan como sigue:</p>
<div class="math">
\begin{equation*}
Peso ruedas traseras = \frac{c}{L} * W - \frac{h}{L} * M * a
\end{equation*}
</div>
<div class="math">
\begin{equation*}
Peso ruedas delanteras = \frac{c}{L} * W + \frac{h}{L} * M * a
\end{equation*}
</div>
<p>Donde:</p>
<ul class="simple">
<li>
<em>h</em> es la altura del centro de gravedad,</li>
<li>
<em>M</em> es la masa del coche y</li>
<li>a la aceleración</li>
</ul>
<div class="figure align-center">
<img alt="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/ctwd.jpg" src="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/ctwd.jpg">
<p class="caption">Distribución del peso del coche sobre las ruedas</p>
</div>
</div>
<div class="section" id="giros">
<h3>Giros</h3>
<p>Una cosa a tener en cuenta cuando estamos simulando giros es que la
simulación de las propiedades física a baja velocidad es diferente de
la simulación a alta velocidad. A velocidades bajas (aparcamiento,
maniobras), las ruedas giran mas o menos en la dirección en la que
éstas apuntan. Para simular estos giros no se necesita considerar las
fuerzas y ni la masas. En otras palabras, es un problema de cinética
no de dinámica.</p>
<p>A velocidades más altas, puede ocurrir que las ruedas apunten en una
dirección mientras que se muevan en otra. En otras palabras, las
ruedas a veces pueden tener una velocidad que no esté alineada con la
orientación de la rueda. Esto significa que hay una componente de
velocidad que está en un ángulo recto a la rueda. Por supuesto, esto
causa mucha fricción. Después de todo una rueda está diseñado para
rodar en una dirección particular sin demasiado esfuerzo.  En giros a
alta velocidad, las ruedas están siendo empujadas hacia los lados y
tenemos que tomar estas fuerzas en cuenta.</p>
</div>
</div>
<div class="section" id="vehiculos-en-bullet">
<h2>Vehículos en Bullet</h2>
<p>El componente de dinámica de vehículos de Bullet ofrece una
implementación basada en rayqueries, de tal manera que se lanza un
rayo por cada rueda del coche. Usando como referencia el punto de
contacto del rayo contra el suelo, calculamos la longitud y la fuerza
de la suspensión. La fuerza de la suspensión se aplica sobre el
chassis de forma que no choque contra el suelo. De hecho, el chasis
del vehículo flota sobre el suelo sustentándose sobre los rayos. La
fuerza de fricción se calcula por cada rueda que esté en contacto con
el suelo. Esto se aplica como una fuerza hacia los lados y adelante
por cada rueda; es decir, por cada rayo.</p>
<p>Hay una serie de clases que son importantes a la hora de utilizar vehículos en Bullet:</p>
<ul class="simple">
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtRaycastVehicle.html">btRaycastVehicle</a>: Es la clase que modela el comportamiento del coche.</li>
</ul>
<pre class="code c++ literal-block">
<span class="n">btRaycastVehicle</span><span class="o">::</span><span class="n">btRaycastVehicle</span><span class="p">(</span> <span class="k">const</span> <span class="n">btVehicleTuning</span><span class="o">&amp;</span> <span class="n">tuning</span><span class="p">,</span>
       <span class="n">btRigidBody</span><span class="o">*</span> <span class="n">chassis</span><span class="p">,</span>
<span class="n">btVehicleRaycaster</span><span class="o">*</span>  <span class="n">raycaster</span><span class="p">)</span>
</pre>
<ul class="simple">
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/structbtVehicleRaycaster.html">btVehicleRaycaster</a>: clase que proporciona una abstracción a la clase btRaycastVehicle para la gestión de rayqueries.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtRigidBody.html">btRigidBody</a>: clase que representa un <a class="reference external" href="http://es.wikipedia.org/wiki/Cuerpo_r%C3%ADgido">cuerpo rigido</a>.
- <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtRaycastVehicle_1_1btVehicleTuning.html">btVehicleTuning</a>: clase que sirve como estructura de datos para el almacenamiento de algunos de los atributos mas importantes del vehículo. Los atributos son:<ul>
<li>btScalar m_suspensionStiffness: La rigidez (stiffness) de la
suspensión. Se recomienda asignarle el valor de 10.0 para
Todoterrenos, 50.0 para coches deportivos y 200.0 para coches de
formula 1.</li>
<li>btScalar    m_suspensionCompression.</li>
<li>btScalar m_suspensionDamping: Coeficiente de amortiguación en el caso de que esté comprimida. Toma valores entre 0 y 1. El valor mínimo hace que la amortiguación rebote, mientras que el valor máximo sea lo mas rígida posible. Entre 0.1 y 0.3 la amortiguación se suele comportar correctamente.</li>
<li>btScalar    m_maxSuspensionTravelCm: La distancia máxima que puede ser comprimida la suspensión, en centímetros.</li>
<li>btScalar    m_frictionSlip:  El coeficiente de fricción entre el neumatico y el suelo. Para coches realistas debería tener el valor de 0.8, pero aumentando el valor mejora la conducción. Para coches de kart se aconseja asignarle un valores muy altos (10000.0).</li>
<li>btScalar    m_maxSuspensionForce:</li>
</ul>
</li>
</ul>
<p>Para ampliar mas acerca de este tema, el autor de la implementación del módulo de vehículos escribió un <a class="reference external" href="https://docs.google.com/document/d/18edpOwtGgCwNyvakS78jxMajCuezotCU_0iezcwiFQc/edit">documento</a> en el que hablaba de los aspectos mas relevantes.</p>
</div>
<div class="section" id="veamos-algo-de-codigo">
<h2>Veamos algo de código</h2>
<p>A continuación vamos a explicar cómo inicializar un vehículo en Bullet
y las operaciones mas importantes. En este ejemplo me voy a apoyar del
<a class="reference external" href="https://bitbucket.org/arco_group/tfg.tinman/src/4ed771a44142c75b196e147a6cec8d2da220aab5/src/managers/physics.cpp?at=master">gestor de físicas</a>
que he escrito para mi proyecto, que me abstrae a la hora de crear
cuerpos rígidos, formas de colisión, etcétera. El código completo
relativo al coche se puede encontrar en la <a class="reference external" href="https://bitbucket.org/arco_group/tfg.tinman/src/4ed771a44142c75b196e147a6cec8d2da220aab5/src/model/car.cpp?at=master">clase Car</a>
de mi proyecto.</p>
<p>Los pasos que hay que seguir para inicializar un coche en bullet son:</p>
<ul class="simple">
<li>Creamos un cuerpo rígido</li>
</ul>
<pre class="code c++ literal-block">
<span class="n">btVector3</span> <span class="n">car_dimensions</span> <span class="o">=</span> <span class="n">btVector3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">btBoxShape</span><span class="o">*</span> <span class="n">chassis_box</span> <span class="o">=</span> <span class="n">physics</span><span class="o">-&gt;</span><span class="n">create_shape</span><span class="p">(</span><span class="n">car_dimensions</span><span class="p">);</span>

<span class="n">btVector3</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">btVector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">btCompoundShape</span><span class="o">*</span> <span class="n">compound</span> <span class="o">=</span>  <span class="n">physics</span><span class="o">-&gt;</span><span class="n">create_compound_shape</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">chassis_box</span><span class="p">);</span>

<span class="n">btQuaternion</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">btQuaternion</span><span class="p">(</span><span class="n">btVector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">btScalar</span><span class="p">(</span><span class="mi">80</span><span class="p">));</span>
<span class="n">btVector3</span> <span class="n">position</span> <span class="o">=</span> <span class="n">btVector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">btTransform</span><span class="p">(</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">position</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">mass</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">chassis_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="p">(</span><span class="s">"chassis_node"</span><span class="p">);</span>

<span class="n">btRigidBody</span><span class="o">*</span> <span class="n">chassis_body_</span> <span class="o">=</span>  <span class="n">physics</span><span class="o">-&gt;</span><span class="n">create_rigid_body</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">chassis_node</span><span class="p">,</span> <span class="n">compound</span><span class="p">,</span> <span class="n">mass</span><span class="p">);</span>

<span class="n">chassis_body_</span><span class="o">-&gt;</span><span class="n">setActivationState</span><span class="p">(</span><span class="n">DISABLE_DEACTIVATION</span><span class="p">);</span>
</pre>
<p>En el fragmento anterior se crean dos formas de colisión: una caja y una forma compuesta(btCompoundShape), a la que asociamos la primera. Esto permite desplazar la caja una unidad en el eje Y, de forma que esté un poco alzada, indicandolo a través de la variable <em>origin</em>.</p>
<p>Tras esto se crea un cuerpo rígido. El primer atributo es una estructura de datos que almacena las rotaciones y la posición inicial. El segundo es un nodo de ogre, dado que mi gestor de físicas integra Bullet con Ogre. El tercer argumento es la forma compuesta que hemos creado antes y, por último, la masa del vehículo expresada en kilogramos.</p>
<p>El último paso consiste en indicarle a Bullet que el cuerpo rígido que acabamos de crear nunca debe ser desactivado; es decir, debe tenerlo en cuenta en todo momento en cada iteración de la simulación física. Bullet ignora algunos cuerpos rígidos que considera que no van a interaccionar en algún momento con otros cuerpos rigidos. Sin embargo, esto tiene como contrapunto que puede que el motor ignore acciones por parte del usuario, como una invocación al método de aceleración. Haciendo que nunca se desactive evitamos esto.</p>
<ul class="simple">
<li>Añadimos las ruedas. Para esto, usamos el método addWheel de la clase btRaycastVehicle(la clase que modela el vehículo):</li>
</ul>
<pre class="code c++ literal-block">
<span class="n">btWheelInfo</span> <span class="o">&amp;</span> <span class="n">btRaycastVehicle</span><span class="o">::</span><span class="n">addWheel</span> <span class="p">(</span><span class="k">const</span> <span class="n">btVector3</span> <span class="o">&amp;</span><span class="n">connectionPointCS0</span><span class="p">,</span>
       <span class="k">const</span> <span class="n">btVector3</span> <span class="o">&amp;</span><span class="n">wheelDirectionCS0</span><span class="p">,</span> <span class="k">const</span> <span class="n">btVector3</span> <span class="o">&amp;</span><span class="n">wheelAxleCS</span><span class="p">,</span>
       <span class="n">btScalar</span> <span class="n">suspensionRestLength</span><span class="p">,</span><span class="n">btScalar</span> <span class="n">wheelRadius</span><span class="p">,</span> <span class="k">const</span> <span class="n">btVehicleTuning</span> <span class="o">&amp;</span><span class="n">tuning</span><span class="p">,</span>
       <span class="kt">bool</span> <span class="n">isFrontWheel</span><span class="p">);</span>
</pre>
<p>Este método recibe:</p>
<ol class="arabic simple">
<li>const btVector3 &amp;connectionPointCS0: la posición de donde va a salir el rayo que representa la rueda. Esta posición debe estar dentro del chasis del coche o de lo contrario esa rueda no aplicará fuerza de tracción.</li>
<li>const btVector3 &amp;wheelDirectionCS0: El vector dirección de la rueda.</li>
<li>const btVector3 &amp;wheelAxleCS: El eje sobre el que estará  el eje de la rueda.</li>
<li>btScalar suspensionRestLength: La longitud máxima de la suspensión, en metros.</li>
<li>btScalar wheelRadius: radio de la rueda,</li>
<li>const btVehicleTuning &amp;tuning: Ver explicación anterior.</li>
<li>bool isFrontWheel: indica si la rueda está en el eje delantero o el trasero.</li>
</ol>
<ul class="simple">
<li>Creamos el coche:</li>
</ul>
<pre class="code c++ literal-block">
<span class="n">btDefaultVehicleRaycaster</span> <span class="n">vehicle_raycaster</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btDefaultVehicleRaycaster</span><span class="p">(</span><span class="n">physics</span><span class="o">-&gt;</span><span class="n">dynamics_world_</span><span class="p">);</span>
<span class="n">btRaycastVehicle</span> <span class="n">vehicle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btRaycastVehicle</span><span class="p">(</span><span class="n">tuning_</span> <span class="p">,</span> <span class="n">chassis_body_</span><span class="p">,</span> <span class="n">vehicle_raycaster_</span><span class="p">);</span>

<span class="n">physics</span><span class="o">-&gt;</span><span class="n">dynamics_world_</span><span class="o">-&gt;</span><span class="n">addVehicle</span><span class="p">(</span><span class="n">vehicle</span><span class="p">);</span>
</pre>
<p>Como vemos, el último paso consiste en crear un objeto de tipo btRaycastVehicle y añadirlo al mundo a través del método addVehicle de la clase btDiscreteDynamicsWorld. Bullet ofrece una implementación por defecto de la intefaz btVehicleRaycaster, lo que nos ahorra tener que implementarla nosotros.</p>
<p>Acelerar:</p>
<pre class="code c++ literal-block">
<span class="kt">void</span>
<span class="n">CarController</span><span class="o">::</span><span class="n">accelerate</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">f_engine_</span> <span class="o">&gt;=</span>  <span class="n">f_max_engine_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">accelerating_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">f_engine_</span> <span class="o">+=</span> <span class="n">acceleration_</span><span class="p">;</span>
  <span class="n">accelerating_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>Frenar:</p>
<pre class="code c++ literal-block">
<span class="kt">void</span>
<span class="n">CarController</span><span class="o">::</span><span class="n">brake</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">accelerating_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
   <span class="n">braking_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
   <span class="n">f_braking_</span> <span class="o">=</span> <span class="n">f_max_braking_</span><span class="p">;</span>
   <span class="n">f_engine_</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_engine_</span> <span class="o">&lt;=</span> <span class="n">f_max_engine_</span><span class="p">)</span> <span class="o">?</span>
   <span class="o">-</span><span class="n">f_max_engine_</span><span class="o">:</span> <span class="n">f_engine_</span> <span class="o">-</span> <span class="n">deceleration_</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>Girar:</p>
<pre class="code c++ literal-block">
 <span class="kt">void</span>
 <span class="n">CarController</span><span class="o">::</span><span class="n">turn</span><span class="p">(</span><span class="n">Direction</span> <span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span><span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">Direction</span><span class="o">::</span><span class="n">right</span><span class="p">){</span>
     <span class="n">turn_wheels</span><span class="p">(</span><span class="n">Direction</span><span class="o">::</span><span class="n">right</span><span class="p">);</span>
     <span class="n">steering_</span> <span class="o">=</span> <span class="p">(</span><span class="n">steering_</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">steering_clamp_</span><span class="p">)</span><span class="o">?</span>
     <span class="o">-</span><span class="n">steering_clamp_</span> <span class="o">:</span> <span class="n">steering_</span> <span class="o">-</span> <span class="n">steering_increment_</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">else</span><span class="p">{</span>
     <span class="n">turn_wheels</span><span class="p">(</span><span class="n">Direction</span><span class="o">::</span><span class="n">left</span><span class="p">);</span>
     <span class="n">steering_</span> <span class="o">=</span> <span class="p">(</span><span class="n">steering_</span> <span class="o">&gt;</span> <span class="n">steering_clamp_</span><span class="p">)</span><span class="o">?</span>
        <span class="n">steering_clamp_</span> <span class="o">:</span> <span class="n">steering_</span> <span class="o">+</span> <span class="n">steering_increment_</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>Para que el coche acelere se ejecuta la siguiente función, que aplica par motor a las ruedas del coche</p>
<pre class="code c++ literal-block">
<span class="n">vehicle_</span><span class="o">-&gt;</span><span class="n">applyEngineForce</span><span class="p">(</span><span class="n">controller_</span><span class="o">-&gt;</span><span class="n">f_engine_</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">vehicle_</span><span class="o">-&gt;</span><span class="n">applyEngineForce</span><span class="p">(</span><span class="n">controller_</span><span class="o">-&gt;</span><span class="n">f_engine_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre>
<p>Para hacer que el coche gire se aplica un giro a las ruedas:</p>
<pre class="code c++ literal-block">
<span class="n">vehicle_</span><span class="o">-&gt;</span><span class="n">setSteeringValue</span><span class="p">(</span><span class="n">controller_</span><span class="o">-&gt;</span><span class="n">steering_</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">vehicle_</span><span class="o">-&gt;</span><span class="n">setSteeringValue</span><span class="p">(</span><span class="n">controller_</span><span class="o">-&gt;</span><span class="n">steering_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre>
<p>El primer argumento de las funciones anteriores representa el valor de par motor o steering aplicado a las ruedas. El segundo argumento es el índice de las ruedas. En este ejemplo, corresponde con las ruedas delanteras.</p>
<!--  -->
<!-- Hola, parece que tienes algo de curiosidad. -->
<!-- Como recompensa, aquí tienes la traducción del artículo completo sobre el que me he basado para escribir el apartado teórico de este post -->
<!--  -->
<!-- // -*- coding:utf-8; tab-width:4; mode:cpp -*- -->
<!--  -->
<!-- Original: http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html -->
<!--  -->
<!-- **************** -->
<!-- Introducción -->
<!-- **************** -->
<!--  -->
<!-- Este tutorial trata el tema de la simulación de coches en -->
<!-- videojuegos. Se tratará las propiedades físicas que modelan el -->
<!-- comportamiento de un coche orientándolo a su aplicación a videojuegos. -->
<!--  -->
<!-- Uno de los puntos clave de la simulación en videojuegos consiste en -->
<!-- simplificar las físicas para gestionar fuerzas laterales y -->
<!-- logitudinales de forma separada. Las fuerzas logitudinales operan en -->
<!-- la dirección del cuerpo del coche. La logitudinal está -->
<!-- compuesta por la fuerza que aplican las ruedas, la de frenado, la -->
<!-- resistencia de giro y la resistencia del aire. Estas fuerzas juntas -->
<!-- controlan la aceleración y desaceleración del coche, así como su -->
<!-- velocidad. Por otro lado, las fuerzas laterales permiten al coche -->
<!-- girar. Estas fuerzas son causadas por la fricción lateral de las -->
<!-- ruedas. Tambien hay que tener en cuenta el momento angular del coche y -->
<!-- el esfuerzo de torsión causado por las fuerzas laterales. -->
<!--  -->
<!-- *********************************** -->
<!-- Físicas en movimientos rectilíneos -->
<!-- *********************************** -->
<!--  -->
<!-- El primer caso a considerar es el de un coche moviendose en línea -->
<!-- recta. La primera fuerza que entra en juego es la fuerza de tracción; -->
<!-- es decir, la que proporcina el motor a través de las ruedas. El motor -->
<!-- gira las ruedas hacia adelante(aplicando una fuerza de torsión), de -->
<!-- tal forma que las ruedas empujan hacia atrás contra la superficie de la -->
<!-- carretera y, en reacción, se genera una fuerza hacia adelante. Esto -->
<!-- implica que la fuerza de tracción es equivalente a la fuerza del -->
<!-- motor, que es controlada directamente por el usuario. -->
<!--  -->
<!-- Ftraccion = u * FMotor, -->
<!-- donde u es un vector unitario con la dirección del coche. -->
<!--  -->
<!-- Si esta fuera la única fuerza que influye en el movimiento, el coche -->
<!-- aceleraría hasta alcanzar una velocidad infinita. Aquí es donde entran -->
<!-- en juego las fuerzas de resistencia. La primera sería la resistencia -->
<!-- del aire. Esta fuerza es muy importante porque es proporcional al -->
<!-- cuadrado de la velocidad. Al conducir a altas velocidades ésta es la -->
<!-- mayor resitencia que encuentra el coche. -->
<!--  -->
<!-- Fdrag = - Cdrag * v * | v | -->
<!-- donde Cdrag es una constante de resistencia del aire, -->
<!-- v es el vector de velocidad y -->
<!-- | v | el módulo del vector. -->
<!--  -->
<!-- El módulo del vector velocidad es la velocidad a la que nos referimos -->
<!-- comunmente, expresada en km/h cuando hablamos de vehículos. -->
<!--  -->
<!-- speed = sqrt(v.x*v.x + v.y*v.y); -->
<!-- fdrag.x = - Cdrag * v.x * speed; -->
<!-- fdrag.y = - Cdrag * v.y * speed; -->
<!--  -->
<!--  -->
<!-- La siguiente resistencia que encontramos es la resistencia al giro. Es -->
<!-- causada por la fricción entre la goma del neumático y la superficie de -->
<!-- contacto debido al desplazamiento de las ruedas. -->
<!--  -->
<!--  -->
<!-- Frr = -Crr Frr = - Crr * v -->
<!-- donde Crr es una constante de rozamiento y -->
<!-- v el vector de velocidad. -->
<!--  -->
<!-- A bajas velocidades la resistencia al giro es la mayor resistencia que -->
<!-- encuentra el coche, mientras que a altas velocidades sería la -->
<!-- resistencia del aire. A 100km/h (aproximadamente 30m/s) son -->
<!-- equivalentes [http://www.gdconf.com/2000/library/homepage.htm]. Esto -->
<!-- significa que el coeficiente resistencia de giro debe ser -->
<!-- aproximadamente 30 veces el valor del coeficiente de resistencia -->
<!-- aerodinámica. -->
<!--  -->
<!-- La fuerza logitudinal total es la suma de estas tres fuerzas: -->
<!--  -->
<!-- Flong =   Ftraction + Fdrag   + Frr -->
<!--  -->
<!-- Hay que señalar que si se conduce en línea recta las fuerzas de -->
<!-- resistencia tiene sentido contrario al que toma el coche, oponiéndose -->
<!-- al movimiento. De esta forma, dentro de la fórmula tomarían valores -->
<!-- negativos, mientras que la fuerza de tracción toma valores -->
<!-- positivos. Cuando el coche se mueve a una velocidad constante las -->
<!-- fuerzas se encuentran en equilibrio, por lo que Flong es cero. -->
<!--  -->
<!-- La aceleración del coche(expresada en m/s) se calcula a partir de la -->
<!-- fuerza neta(Newtons) y la masa del coche (kg) usando la segunda ley de -->
<!-- Newton: -->
<!--  -->
<!-- a = F/Métrico -->
<!--  -->
<!--  -->
<!-- La velocidad del coche se calcula integrando la aceleración en el -->
<!-- tiempo: -->
<!--  -->
<!-- v = v0 + aceleración * dt -->
<!-- donde dt es el incremento de tiempo en segundos entre las -->
<!-- subsiguientes llamadas al motor de físicas. -->
<!--  -->
<!-- La posición del coche se calcula integrando la velocidad a lo largo -->
<!-- del tiempo: -->
<!--  -->
<!-- p = p + dt * v -->
<!--  -->
<!--  -->
<!-- Con estas tres fuerzas se puede simular la aceleración del coche de -->
<!-- una forma bastante precisa. Juntas también determinan la velocidad -->
<!-- máxima del coche para una potencia de motor dada. No hay necesidad de -->
<!-- definir una velocidad máxima en ninguna parte del código ya que es -->
<!-- algo que viene dado por estas ecuaciones. Esto es así debido a que las -->
<!-- ecuaciones interaccionan entre ellas. Por ejemplo, si la tracción -->
<!-- sobrepasa a las resistencias dentro de la fórmula de la fuerza -->
<!-- longitudinal, el coche acelerará. La velocidad del coche se -->
<!-- incrementará, lo que incrementará las resistencias. La fuerza neta -->
<!-- decrementará y por tanto la aceleración. En algún punto las -->
<!-- resistencias y la fuerza de tracción se igualarán, cancelándose -->
<!-- mútuamente, lo que hará que el coche alcance la velocidad punta para -->
<!-- esa potencia de motor determinada. -->
<!-- .. image:: http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/ctgraph.jpg -->
<!-- :align: center -->
<!-- :alt: Distribución del peso del coche sobre las ruedas -->
<!--  -->
<!--  -->
<!-- En el diagrama el eje de las x denota la velocidad del coche en metros -->
<!-- por segundo y el eje de las y el valor de las fuerzas. La fuerza de -->
<!-- tracción( azul oscuro) se configura a un valor aleatorio, ya que no -->
<!-- depende de la velocidad del coche. La resistencia de giro (línea -->
<!-- morada) es una función lineal de la velocidad y la resistencia -->
<!-- aerodinámica(línea amarilla) es una función cuadrática de la -->
<!-- velocidad. A velocidades bajas la resistencia de giro sobrepasa a la -->
<!-- resistencia del aire. A 30m/s las dos funciones se cruzan. A -->
<!-- velocidades altas la resistencia del aire es la mayor de las -->
<!-- resistencias. La suma de las dos resistencias se muestra en la línea -->
<!-- azul claro. A 37m/s la suma de las resitencias iguala la línea -->
<!-- horizontal (potencia del motor). Esta es la velocidad punta para ese -->
<!-- valor particular de la potencia del motor. -->
<!--  -->
<!-- ******************* -->
<!-- Constantes mágicas -->
<!-- ******************* -->
<!--  -->
<!-- Hasta ahora, hemos introducido dos constantes mágicas, Cdrag y Crr. Si -->
<!-- no se persigue conseguir realismo en la simulación física, los valores -->
<!-- que hemos dado a estas constantes son suficientemente buenos para tu -->
<!-- juego. Por ejemplo, en un juego arcade se podría querer que el coche -->
<!-- acelerase mas rápido que el la vida real. Sin embargo, si se busca -->
<!-- el realismo, es importante dar a estas constantes valores precisos. -->
<!--  -->
<!-- La resistencia del aire está modelada, aproximadamente, por la -->
<!-- siguiente fórmula [Fluid Mechanics by Landau and Lifshitz, [Beckham] -->
<!-- chapter 6, [Zuvich]] -->
<!--  -->
<!-- Fdrag =  0.5 * Cd * A * rho * v2 -->
<!--  -->
<!-- donde  Cd = coeficiente de fricción -->
<!-- A es el area frontal del coche -->
<!-- rho (Greek symbol)= densidad del aire. -->
<!-- v = velocidad del coche -->
<!--  -->
<!-- La densidad del aire(rho) es 1.29kg/m³, el area frontal -->
<!-- aproximadamente 2.2m², Cd depende de la forma del coche y se determina -->
<!-- con test en tuneles de viento. Para un Corvette: 0.3. Esto nos da para -->
<!-- Cdrag: -->
<!--  -->
<!-- Cdrag = 0.5 * 0.3 * 2.2 *1.29 = 0.4257 -->
<!--  -->
<!-- Crr es aproximadamente 30 veces Cdrag, lo que nos da: -->
<!--  -->
<!-- Crr = 30 * 0.4257 = 12.8 -->
<!--  -->
<!-- Este último valor no es 100% correcto. -->
<!--  -->
<!-- ********** -->
<!-- Frenado -->
<!-- ********** -->
<!--  -->
<!-- Cuando el coche frena, la fuerza de tracción se ve reemplazada por la -->
<!-- fuerza de frenado, la cuál está orientada en sentido opuesto al del -->
<!-- movimiento. La fuerza longitudinal total es el vector que resulta de -->
<!-- la suma de las tres fuerzas: -->
<!--  -->
<!-- Flong =   Fbraking + Fdrag   + Frr -->
<!--  -->
<!-- La fuerza de frenado de forma simplificada es igual a: -->
<!--  -->
<!-- Fbraking = -u * Cbraking -->
<!--  -->
<!-- u es el vector unitario de movimiento y -->
<!-- Cbraking una constante de frenado. -->
<!--  -->
<!-- En esta fórmula la fuerza de frenado es constante, de modo que hay que -->
<!-- dejar de aplicarla cuando la velocidad del coche llegue a cero, para -->
<!-- que el coche no empiece a avanzar en sentido contrario al del -->
<!-- movimiento. -->
<!--  -->
<!-- ************************ -->
<!-- Transferencia de peso -->
<!-- ************************ -->
<!--  -->
<!-- Un efecto importante cuando se acelera o frena es el efecto de la -->
<!-- transferencia dinámica de peso. Cuando se frena el coche baja el morro -->
<!-- hacia adelante. Durante la aceleración, el coche se inclina hacia -->
<!-- atrás. Esto es debido a que el centro de gravedad el coche cambia. El -->
<!-- efecto de esto es que el peso sobre las ruedas traseras aumenta -->
<!-- durante la aceleración, mientras que las ruedas delanteras deben -->
<!-- soportar menos peso. -->
<!--  -->
<!-- El efecto de la transferencia de peso es importante por dos -->
<!-- razones. La primera es que el efecto visual del coche "cabeceando" en -->
<!-- respuesta a las acciones del usuario aporta gran realismo. De repente -->
<!-- el usuario se siente mas inmerso en la simulación. -->
<!--  -->
<!-- Por otra parte, la distribución de peso afecta dramáticamente a la -->
<!-- tracción máxima por rueda. Esto es debido a que el límite de fricción -->
<!-- es proporcional a la carga en esa rueda: -->
<!--  -->
<!-- Fmax = mu * W -->
<!--  -->
<!-- donde mu es el coeficiente de fricción en el neumático y -->
<!-- W es el peso del coche. -->
<!--  -->
<!-- Para neumáticos de calle m utoma el valor de 1.0, mientras que para -->
<!-- neumáticos de carrera puede tomar valores superiores a 1.5. -->
<!--  -->
<!-- Para vehiculos estacionados el peso total del coche (W = M*g) se -->
<!-- distribuye sobre las ruedas delanteras y traseras de acuerdo a la -->
<!-- distancia entre la parte el eje delantero y trasero al centro de masa: -->
<!--  -->
<!-- Wdelantero = (c/L)*W -->
<!-- Wtrasero   = (b/L)*W -->
<!-- donde b y c son la distancia al centro de gravedad de los ejes delanteros y traseros y L es la base de las ruedas. -->
<!--  -->
<!-- .. image:: transferencia-peso.jpg -->
<!-- :align: center -->
<!-- :alt: Distribución del peso del coche sobre las ruedas -->
<!--  -->
<!--  -->
<!-- Si el coche acelera o desacelera en un factor a, el peso frontal y -->
<!-- trasero se calculan como sigue: -->
<!--  -->
<!-- Wf = (c/L)*W - (h/L)*M*a -->
<!-- Wr = (b/L)*W + (h/L)*M*a -->
<!-- donde h es la altura del centro de gravedad, M es la masa del coche y a la aceleración -->
<!--  -->
<!-- Para simplificar las fórmulas, se puede asumir una distribución -->
<!-- estática de 50-50 sobre la parte frontal y trasera. En otras palabras, -->
<!-- asumimos b = c = L/2. En ese caso, Wf = 0.5W -(h/L) * M * a y Wr = -->
<!-- 0.5*W + (h/L)*M*a. -->
<!--  -->
<!-- ***************** -->
<!-- Fuerza del motor -->
<!-- ***************** -->
<!--  -->
<!-- Hasta ahora hemos hecho una pequeña simplificación diciendo que el -->
<!-- motor da una cantidad de fuerza. El motor aporta par motor o momento -->
<!-- torsor. El par motor es fuerza por distancia. Si aplicas una fuerza de -->
<!-- 10 Newton 0.3 metros en el eje de rotación, obtienes 10*0.3 = 3N.m ( -->
<!-- Newton metro). Es lo mismo cuando aplicas un par motor de 1 Newton a -->
<!-- 3 metros del eje. En ambos casos el momento es el mismo. -->
<!--  -->
<!-- El momento torsor que puede entregar el motor depende de la velocidad -->
<!-- a la cuál este gira, típicamente expresado en rpm. La relación momento -->
<!-- torsor/rpm no es lineal, pero se representa normalmente como una curva -->
<!-- llamada función del momento torsor (La curva exacta de cada motor -->
<!-- viene determinada por los test a los que son sometidos estos -->
<!-- motores). Aquí vemos un ejemplo para el motor de un Corvette de 1997 a -->
<!-- 2000: el LS1(5.7 litros V8) -->
<!-- .. image:: http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/cttorq.gif -->
<!-- :align: center -->
<!-- :alt: Curva de potencia/par motor del Corvette LS1 -->
<!-- Nota que la curva del par motor alcanza el máximo alrededor de las -->
<!-- 4400 rpm con un par motor de 475 N.m y la curva de los caballos de -->
<!-- potencia alcanza el máximo a 5600rpm a 345 caballos de potencia( 257 -->
<!-- kW). Las curvas sólo están definidas en el rango de los 1000 a los -->
<!-- 6000 rpm debido a que es el rango operativo del motor. Cualquier valor -->
<!-- inferior hará que el motor se detenga. Cualquier valor superior lo -->
<!-- dañaría. -->
<!--  -->
<!-- Los valores mencionados anteriormente hacen referencia al máximo par -->
<!-- motor que puede entregar el motor paraa unas rpm dadas. El par real que -->
<!-- entrega el motor depende de la posición del acelerador y es una -->
<!-- fracción entre 0 y 1 de este máximo. -->
<!--  -->
<!-- Nuestro interés se centra principalmente en la curva del par, aunque -->
<!-- algunas personas encuentran interesante tambien la de potencia. A -->
<!-- continuación se puede ver la misma gráfica en unidades del SMI. -->
<!--  -->
<!-- .. image:: http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/cttorqsi.gif -->
<!-- :align: center -->
<!-- :alt: Curva de potencia/par motor del Corvette LS1 -->
<!--  -->
<!-- Ahora, el par de torsión desde el motor (es decir, en el cigüeñal) se -->
<!-- convierte a través del engranaje diferencial y antes de que sea -->
<!-- aplicada a las ruedas traseras. El engranaje multiplica el par de -->
<!-- torsión por un factor que depende de las relaciones de transmisión -->
<!-- (las marchas). -->
<!--  -->
<!-- Desafortunadamente se pierde energía en el proceso. Hasta un -->
<!-- 30% se puede perder en forma de calor. Esto da una eficiencia de -->
<!-- transmisión del 70%, aunque el valor concreto en cada coche varía. -->
<!--  -->
<!-- El par motor se convierte en una fuerza a través del giro de la rueda -->
<!-- sobre la carretera, dividido por el radio de la rueda( Fuerza = par -->
<!-- motor / distancia) -->
<!--  -->
<!-- A continuación podemos ver la formula que convierte par motor en -->
<!-- fuerza de "conducción": la fuerza longitudinal que ejercen las dos -->
<!-- ruedas traseras sobre la carretera. -->
<!--  -->
<!-- Fdrive = u * Tengine * xg * xd * n / Rw -->
<!-- donde u es el vector unitario que refleja la orientación del coche -->
<!-- Tengine es el par motor en rpm -->
<!-- xg es la relación de las marchas -->
<!-- xd es el coeficiente diferencial -->
<!-- n es la eficiencia de la transmisión -->
<!-- Rw es el radio de la rueda. -->
<!--  -->
<!-- ************************* -->
<!-- Relación de transmisión -->
<!-- ************************* -->
<!--  -->
<!-- Los siguientes ratios se aplican al Corvette C5 hardtop: -->
<!--  -->
<!--  -->
<!-- First gear         g1          2.66 -->
<!-- Second gear                g2          1.78 -->
<!-- Third gear         g3          1.30 -->
<!-- Fourth gear                g4          1.0 -->
<!-- Fifth gear         g5          0.74 -->
<!-- Sixth gear         g6          0.50 -->
<!-- Reverse                gR          2.90 -->
<!-- Differential ratio         xd          3.42 -->
<!--  -->
<!-- El máximo par motor es 475 N.m a 4400 rpm, la masa = 1439 kg(ignorando -->
<!-- la del conductor por ahora). En la primera marcha, con el máximo par -->
<!-- nos da 475*2.66*3.42*0.7/0.33 = 9166 N de fuerza. Esto haría que el -->
<!-- coche acelerase los 1439 kg del coche a 6.4 m/s² que es igual a 0.65 -->
<!-- g. -->
<!--  -->
<!-- La combinación de las marchas y el diferencial actua como un -->
<!-- multiplicador del par motor en el cigueñal sobre el par de torsión que -->
<!-- se aplica a las ruedas. Por ejemplo, el Corvette en la primera marcha -->
<!-- tiene un multiplicador de 2,66 * 3,42 = 9,1. Esto significa que cada -->
<!-- metro Newton del par motor en el cigüeñal resulta en 9,1 Nm de par -->
<!-- motor en el eje trasero. Considerando un 30% de perdida de energía, -->
<!-- esto deja 6.4 N.m. Dividiendo esto por el radio de las ruedas -->
<!-- obtenemos la fuerza ejercida por las ruedas. Suponiendo un radio de 34 -->
<!-- cm, tenemos 6.4 N.m/0.34m = 2.2N de fuerza por N.m de par motor. Sin -->
<!-- embargo, la ganancia obtenida como par motor tiene como contrapunto -->
<!-- velocidad angular. Se intercambia fuerza por velocidad. Por cada rpm -->
<!-- de las ruedas, el motor debe dar 9.1 rpm. La velocidad de rotación de -->
<!-- cad rueda es directamente proporcional a la velocidad del coche. Una -->
<!-- rpm está 1/60th de una revolución por segundo. Cada revolución hace -->
<!-- avanzar a la rueda 2 pi * R hacia adelante; es decir, 2 * 3.14 * 0.34 -->
<!-- = 2.14 m. De esta forma, 4400 rpm en la primera marcha equivalen a 483 -->
<!-- rpm en las ruedas, lo que son 8.05 rotaciones por segundo = 17.2 m/s ( -->
<!-- alrededor de 62 km/h). -->
<!--  -->
<!-- En marchas bajas el ratio de las marchas es alto, de modo que obtienes -->
<!-- mucho par motor pero poca velocidad. En velocidades altas, obtienes -->
<!-- mas velocidad que par motor. Esto se puede observar en las siguietne -->
<!-- gráfica. -->
<!--  -->
<!-- .. image::  http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/ctgrcrvs.gif -->
<!-- :align: center -->
<!-- :alt: Distribución del peso del coche sobre las ruedas -->
<!--  -->
<!-- La gráfica asume una eficiencia del 100%. El par motor se representa -->
<!-- como la línea negra. -->
<!--  -->
<!-- *************************************** -->
<!-- Aceleración (Drive wheel acceleration) -->
<!-- *************************************** -->
<!--  -->
<!-- El par motor que obtenemos para una rpm dada es el máximo par motor a -->
<!-- esa rpm. Cuanto par motor se aplica realmente a las ruedas depende de -->
<!-- la posición del acelerador. Esta posición se determina por las -->
<!-- entradas del usuario (a través del pedal) y varía de 0 a 100%. -->
<!--  -->
<!-- ********************************** -->
<!-- Como obtener el valor de los rpm -->
<!-- ********************************** -->
<!--  -->
<!-- Se necesita calcular el valor máximo del par motor y a partir de ese -->
<!-- valor obtener el valor real del par motor aplicado; es decir, hay que -->
<!-- conocer cuán rápido gira el cigüeñal. -->
<!--  -->
<!-- Una forma en que se puede calcular este valor es obteniendo la -->
<!-- velocidad de rotación de las ruedas. Despues de todo, si el motor no -->
<!-- está desembragado, el cigueñal y las ruedas estarán físicamente -->
<!-- conectadas a través de la transmisión. Conociendo los rpm del motor -->
<!-- podemos conocer la velocidad de rotación de las ruedas y viceversa. -->
<!--  -->
<!-- rpm = Ratio de giro de las ruedas * marcha * ratio  del diferencial * (60 / 2 pi) -->
<!--  -->
<!-- El multiplicando 60/2 * pi es un factor de conversión de rad/s a -->
<!-- rpm. Hay 60 segundos en un minuto y 2pi radianes por revolución. De -->
<!-- acuerdo a esta fórmula el cigueñal gira más rápido que las -->
<!-- ruedas. Supongamos que está girando a 17 rad/s: -->
<!--  -->
<!-- Las ruedas giran a 17 rad /s.  El ratio de la primera marcha es -->
<!-- 2.66, el ratio differential es 3.42 por lo que el cigueñal rota a -->
<!-- 153 rad/s.  Eso significa que el motor gira a => 153*60 = 9170 -->
<!-- rad/minute = 9170/2 pi = 1460 rpm -->
<!--  -->
<!-- Debido a que la curva del par motor no está definido por debajo de -->
<!-- ciertas rpm, hay que hacer que el gestor de físicas contemple caso: -->
<!--  -->
<!-- if( rpm < 1000 ) -->
<!-- rpm = 1000; -->
<!--  -->
<!-- Esto es necesario para poder modelar el motor del coche cuando éste -->
<!-- esté parado. Ya que calculamos los rpm a partir de las rpm de las -->
<!-- ruedas y éstas estarán paradas, los rpm serán 0. -->
<!--  -->
<!-- Hay dos formas de obtener la velocidad de rotación de las ruedas. La -->
<!-- primera es un truco y la segunda involucra hacer un seguimiento a lo -->
<!-- largo del tiempo de varias variables. -->
<!--  -->
<!-- La forma más fácil es pretender que la rueda está girando y derivar la -->
<!-- velocidad de rotación de la velocidad del coche y el radio de la -->
<!-- rueda. Por ejemplo, digamos que el coche se mueve a 20 km/h = 20,000 m -->
<!-- / 3600 s = 5.6 m/s.  el radio de las ruedas es 0.33 m, por lo que la -->
<!-- velocidad angular de las ruedas es 5.6/0.33 = 17 rad/s -->
<!--  -->
<!-- Usando las formulas anteriores para obtener rpm, obtenemos que el -->
<!-- valor es 1460 rpm, de lo que podemos calcular el par motor a partir de -->
<!-- la curva del par motor. -->
<!--  -->
<!-- Una forma más avanzada es hacer que la simulación realice un -->
<!-- seguimiento de la velocidad de rotación de la rueda y de cómo cambia -->
<!-- con el tiempo, debido al par motor que actúan sobre dichas ruedas. En -->
<!-- otras palabras, calculamos la velocidad de rotación mediante la -->
<!-- integración de la aceleración rotacional en el tiempo. La aceleración -->
<!-- rotacional en cualquier instante particular depende de la suma de -->
<!-- todos los pares de torsión en el eje y es igual al par neto dividido -->
<!-- por la inercia del eje (al igual que la aceleración es la fuerza -->
<!-- dividida por la masa). El par neto es el par motor que vimos antes, -->
<!-- menos los pares de rozamiento que lo contrarrestan (par de frenado si -->
<!-- se está frenado y par de tracción a partir del contacto con la -->
<!-- superficie de la carretera). -->
<!--  -->
<!-- *********************************************** -->
<!-- Relación de deslizamiento y fuerza de tracción -->
<!-- *********************************************** -->
<!--  -->
<!-- Calcular la velocidad angular de las ruedas a partir de la velocidad -->
<!-- del coche sólo es posible si la rueda está girando, es decir, no hay -->
<!-- desplazamiento lateral entre el neumatico y la carretera. Esto es -->
<!-- cierto para las ruedas delanteras, pero para las ruedas motrices esto -->
<!-- no se suele cumplir.  Por ejemplo, cuando estas derrapan no se produce -->
<!-- transferencia de energia para hacer que el coche avance. -->
<!--  -->
<!-- En una situación típica en la que el coche se desplaza a una velocidad -->
<!-- constante, las ruedas traseras giran levemente más rápido que las -->
<!-- ruedas delanteras. Dado que las ruedas delanteras no derrapan, se -->
<!-- puede calcular su velocidad angular con sólo dividir la velocidad del -->
<!-- coche por 2 pi veces el radio de la rueda. Sin embargo, dado que las -->
<!-- ruedas traseras giran más rápido, eso significa que la superficie del -->
<!-- neumático se estará deslizando contra respecto a la superficie de la -->
<!-- carretera. Este deslizamiento causa una fuerza de fricción en la -->
<!-- dirección opuesta a la de deslizamiento. Por tanto, la fuerza de -->
<!-- fricción estará apuntando a la parte delantera del coche. De hecho, -->
<!-- esta reacción a la rueda que patina es lo que empuja al coche. Esta -->
<!-- fuerza de fricción se conoce como tracción o fuerza longtitudinal. La -->
<!-- tracción depende de la cantidad de deslizamiento. La forma -->
<!-- estandarizada de expresar la cantidad de deslizamiento es como la -->
<!-- denominada relación de deslizamiento: -->
<!--  -->
<!-- .. figure:: http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/cteq_sr.gif -->
<!-- :align: center -->
<!-- :alt: Relación de desplazamiento -->
<!--  -->
<!-- Donde: -->
<!-- Ww (omega) es la velocidad angular de las ruedas (in rad/s) -->
<!-- Rw es el radio de las ruedas ( en metros) -->
<!-- vlong es la velocidad del coche; la velocidad longitu -->
<!-- dinal. -->
<!--  -->
<!-- Nota: hay una serie de definiciones ligeramente diferentes de relación -->
<!-- de deslizamiento en uso. Esta definición particular también funciona -->
<!-- para los coches de tracción delantera.  La relación de deslizamiento -->
<!-- es cero para una rueda que no gira. Para un frenazo del coche con las -->
<!-- ruedas bloqueadas la relación de deslizamiento es -1, y un coche -->
<!-- acelerando tiene una relación de deslizamiento positivo, pudiendo -->
<!-- alcanzar valores mayores a 1 cuando existen una gran cantidad de -->
<!-- deslizamiento. -->
<!--  -->
<!-- La relación entre la fuerza longitudinal y el ratio de desplazamiento -->
<!-- puede ser descrita por una curva como la del siguiente gráfico: -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/ctsrcurve.gif -->
<!--  -->
<!-- La gráfica muestra cómo la fuerza es cero si el ratio de deslizamiento -->
<!-- es 0, mientras que ésta alcanza su máximo para un valor del ratio de -->
<!-- desplazamiento del 6%, donde la fuerza longitudinal supera levemente -->
<!-- la carga de las ruedas. La curva exacta puede variar dependiendo del -->
<!-- tipo de neumático, de la superficie, la temperatura, etcetera. Esto -->
<!-- significa que las ruedas obtienen un mejor agarre con un poco de -->
<!-- deslizamiento. Mas hallá de ese óptimo, el agarre disminuye. Por esa -->
<!-- razón un derrape no da mayor aceleración. Habría tanto deslizamiento -->
<!-- que la fuerza longitudinal estaría por debajo de su valor máximo. La -->
<!-- disminución del desplazamiento da lugar a una mayor tracción y una -->
<!-- mejor aceleración. -->
<!--  -->
<!-- La fuerza longitudinal es directamente proporcional a la carga de las -->
<!-- ruedas, como vimos cuando se discutió la transferencia de carga. Por -->
<!-- esta razón en lugar de dibujar una gráfica para cada valor particular -->
<!-- de la carga, podemos crear una curva normalizada dividiendo la fuerza -->
<!-- por la carga. -->
<!--  -->
<!-- Para obtener la fuerza longitudinal a partir de la fuerza logitudinal -->
<!-- normalizada debemos multiplicarla por la carga: -->
<!--  -->
<!-- Flong = F(n, long) * Fz -->
<!-- donde Fn,long es la fuerza longitudinal normalizada para una relación de desplazamiento dada y Fz es la carga del neumático. -->
<!--  -->
<!-- Para simplificar la simulación se puede aproximar a la siguiente fórmula: -->
<!--  -->
<!-- Flong = Ct * slip ratio -->
<!--  -->
<!-- donde Ct es la constante de tracción; es decir, la pendiente de la curva de -->
<!-- relación de desplazamiento en el origen.  Es interesante limitar -->
<!-- la fuerza a un valor máximo para que no sobrepase dicho valor -->
<!-- cuando la curva de desplazamiento sobrepase el valor máximo. La -->
<!-- siguiente gráfica representa dicha curva: -->
<!--  -->
<!--  -->
<!-- *********************************** -->
<!-- Par motor sobre el eje de tracción -->
<!-- *********************************** -->
<!--  -->
<!-- Para recapitular, la fuerza de tracción es la fuerza de fricción que -->
<!-- la superficie de la carretera aplica sobre la superficie de las -->
<!-- ruedas. Obviamente, esta fuerza es causada por el par motor que aplica -->
<!-- el motor sobre los ejes de cada rueda. -->
<!--  -->
<!-- Par motor = Ftracción * Rruedas -->
<!--  -->
<!-- Este par motor se opone al momento de torsión entregado por el motor a -->
<!-- cada rueda(que hemos llamado par motor de "conducción"). Si se frena, -->
<!-- tambien se causará momento de torsión. Para el freno, se va a suponer -->
<!-- que se entrega un par motor constante en la direccion opuesta a la -->
<!-- rotación de las ruedas. Hay que tener en cuenta esto para poder frenar -->
<!-- cuando se va marcha atrás. El siguiente diagrama ilustra estos -->
<!-- conceptos para un coche acelerando. El par motor es amplificado por -->
<!-- las marchas y el diferencial, proporcionando par a las ruedas -->
<!-- traseras. La velocidad angular de las ruedas es suficientemente alta -->
<!-- como para provocar deslizamiento entre la superficie del neumático y -->
<!-- la carretera, lo que puede ser expresado como un ratio de -->
<!-- deslizamiento positivo.  Esto resulta en una fuerza de fricción -->
<!-- reactiva, conocida como fuerza de tracción, que es lo que empuja el -->
<!-- coche hacia adelante. La fuerza de tracción tambien se traduce en un -->
<!-- par de tracción en las ruedas traseras que se opone al par de -->
<!-- impulso. En este caso, el par neto sigue siendo positivo y dará lugar -->
<!-- a una aceleración de la velocidad de rotación de las ruedas -->
<!-- traseras. Esto incrementará los rpm y el ratio de deslizamiento. -->
<!--  -->
<!-- .. image:: http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/tc_torques.png -->
<!-- :align: center -->
<!-- :alt: Distribución del peso del coche sobre las ruedas -->
<!--  -->
<!-- El par neto en el eje trasero es la suma de los siguientes pares: -->
<!--  -->
<!-- ParMotorTotal = Par motor + par motor en ambas ruedas + par motor de frenado -->
<!--  -->
<!-- Hay que recordar que los momentos de torsión son magnitudes con signo, -->
<!-- el momento de impulso normalmente tendrá signo opuesto a los de -->
<!-- tracción y de frenado. Si el conductor no frena, el momento de frenado -->
<!-- es cero. -->
<!--  -->
<!-- El par total genera una velocidad angular sobre las ruedas que tienen -->
<!-- tracción, tal y como una fuerza aplicada sobre una masa hace que dicha -->
<!-- masa acelere: -->
<!--  -->
<!-- Aangular = Par motor total / inercias de las ruedas de tracción. -->
<!--  -->
<!-- La inercia de un cilindro sólido alrededor de un eje puede ser -->
<!-- calculado con la siguiente fórmula: -->
<!--  -->
<!-- InerciaCilindro = Masa * Radio^2 / 2 -->
<!--  -->
<!-- Así que para una rueda de 75 kg con un radio de 33 cm su inercia es de -->
<!-- 75 * 0.33 * 0.33 / 2 = 4.1 kg.m2. Multiplicando por dos se obtiene la -->
<!-- inercia total de las dos ruedas del eje trasero, para mayor precisión -->
<!-- habría que añadir la inercia del propio eje, la inercia de los -->
<!-- engranajes y la del motor. -->
<!--  -->
<!-- Una aceleración angular positiva incrementará la velocidad angular de -->
<!-- las ruedas traseras en el tiempo. Como la velicidad del coche depende -->
<!-- de la aceleración lineal, podemos simular esto realizando integración -->
<!-- lineal en cada simulación que realice nuestro gestor de físicas: -->
<!--  -->
<!-- velocidad angular de las ruedas traseras += velocidad angular de las ruedas traseras * time step -->
<!--  -->
<!-- Donde time step es la cantidad de tiempo entre llamadas al simulador -->
<!-- físico. De esta forma se puede determinar cuán rápido están girando -->
<!-- las ruedas de tracción y por lo tanto las rpm del motor. -->
<!--  -->
<!-- *********************** -->
<!-- El huevo y la gallina -->
<!-- *********************** -->
<!--  -->
<!-- Algunos lectores podrían estar confusos en este punto. Necesitamos los -->
<!-- rpm para calcular el par motor, pero el número de revoluciones depende -->
<!-- de la velocidad de rotación de las ruedas traseras, que a su vez -->
<!-- depende del par motor. Sin duda, esta es una definición circular. -->
<!--  -->
<!-- Este es un ejemplo de una ecuación diferencial: tenemos ecuaciones -->
<!-- para las distintas variables que dependen mutuamente la una de la -->
<!-- otra. Pero ya hemos visto un ejemplo más de esto antes: la resistencia -->
<!-- del aire depende de la velocidad, sin embargo, la velocidad depende de -->
<!-- la resistencia del aire, ya que influye en la aceleración. -->
<!--  -->
<!-- Para resolver ecuaciones diferenciales en los programas de ordenador -->
<!-- utilizamos la técnica de integración numérica: si conocemos todos los -->
<!-- valores en el tiempo t, podemos trabajar los valores en el tiempo t + -->
<!-- delta. En otras palabras, en lugar de tratar de resolver estas -->
<!-- ecuaciones mutuamente dependientes, tomamos instantáneas en tiempo y -->
<!-- resolvemos las ecuaciones para estos valores. Utilizamos los valores -->
<!-- de la iteración anterior para calcular los de la siguiente. Si el paso -->
<!-- de tiempo es lo suficientemente pequeño, este método funcionará -->
<!-- correctamente. -->
<!--  -->
<!-- Existe multitud de teoría relacionada con el cálculo de ecuaciones -->
<!-- diferenciales e integración numérica. Uno de los problemas de la -->
<!-- integracion numérica es que un integrador puede "estallar" si el -->
<!-- intervalo de tiempo no es lo suficentemente pequeño. En lugar de dar -->
<!-- valores correctos, se disparán al infinito, debido a que estos -->
<!-- pequeños errores se multiplican rápidamente. La alternativa pasa por -->
<!-- usar integradores mas inteligentes; por ejemplo, RK4. -->
<!--  -->
<!-- ******* -->
<!-- Giros -->
<!-- ******* -->
<!--  -->
<!-- Una cosa a tener en cuenta cuando estamos simulando giros es que la -->
<!-- simulación de las propiedades física a baja velocidad es diferente de -->
<!-- la simulación a alta velocidad. A velocidades bajas (aparcamiento, -->
<!-- maniobras), las ruedas giran mas o menos en la dirección en la que -->
<!-- éstas apuntan. Para simular estos giros no se necesita considerar las -->
<!-- fuerzas y ni la masas. En otras palabras, es un problema de cinética -->
<!-- no de dinámica. -->
<!--  -->
<!-- A velocidades más altas, puede ocurrir que las ruedas apunten en una -->
<!-- dirección mientras que se muevan en otra. En otras palabras, las -->
<!-- ruedas a veces pueden tener una velocidad que no esté alineada con la -->
<!-- orientación de la rueda. Esto significa que hay una componente de -->
<!-- velocidad que está en un ángulo recto a la rueda. Por supuesto, esto -->
<!-- causa mucha fricción. Después de todo una rueda está diseñado para -->
<!-- rodar en una dirección particular sin demasiado esfuerzo.  En giros a -->
<!-- alta velocidad, las ruedas están siendo empujadas hacia los lados y -->
<!-- tenemos que tomar estas fuerzas en cuenta. -->
<!--  -->
<!-- Veamos el caso de giros a bajas velocidades. Podemos suponer que las -->
<!-- ruedas se están moviendo en la dirección que apuntan. En este caso, -->
<!-- las ruedas están rodando pero no se desliza hacia los lados. Si las -->
<!-- ruedas delanteras están giradas en un ángulo delta y el coche se está -->
<!-- moviendo a una velocidad constante, entonces el coche describirá una -->
<!-- trayectoria circular. Imagínese líneas que se proyectan desde el -->
<!-- centro de los hubcabs de la rueda delantera y trasera en el interior -->
<!-- de la curva. Cuando estas dos líneas se cruzan definen el centro de la -->
<!-- circuferencia que está realizando el giro del coche. -->
<!--  -->
<!-- Esto está muy bien ilustrado en la siguiente figura. Note cómo las -->
<!-- líneas verdes se cruzan en un punto, el centro alrededor del cual el -->
<!-- vehículo está girando. También se puede notar que las ruedas -->
<!-- delanteras no están giradas en el mismo ángulo, la rueda exterior se -->
<!-- volvió un poco menos que la rueda interior. Esto es también lo que -->
<!-- sucede en la vida real, el mecanismo de dirección diferencial de un -->
<!-- automóvil está diseñado para girar las ruedas en un ángulo -->
<!-- diferente. Para una simulación de un coche puede que esta sutileza sea -->
<!-- tan importante. Se va a centrar la explicación en el ángulo de -->
<!-- dirección de la rueda delantera en el interior de la curva y se -->
<!-- ignorará la rueda en el otro lado. -->
<!--  -->
<!-- El radio del círculo se puede determinar a través de cálculos -->
<!-- geométricos, como se ve en el siguiente diagrama: -->
<!--  -->
<!-- .. image:: http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games_files/ctangles.jpg -->
<!-- :align: center -->
<!--  -->
<!-- La distancia entre el eje delantero y el trasero se calcula desde la base de -->
<!-- la rueda y denota como L. El radio del círculo que describe el coche -->
<!-- (para ser preciso el círculo que describe la rueda delantera) se llama -->
<!-- R. El diagrama muestra un triángulo con un vértice en el centro del -->
<!-- círculo y uno en el centro de cada rueda. El ángulo en la rueda -->
<!-- trasera es de 90 grados por definición. El ángulo en la rueda -->
<!-- delantera es de 90 grados menos delta. Esto significa que el ángulo en -->
<!-- el centro del círculo también es delta (la suma de los ángulos de un -->
<!-- triángulo es siempre 180 grados). El seno de este ángulo es la base de -->
<!-- la rueda dividido por el radio del círculo, por lo tanto: -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/cteq_r.gif -->
<!--  -->
<!-- Tenga en cuenta que si el ángulo de dirección es cero, entonces el -->
<!-- radio del círculo es infinito, es decir, que está conduciendo en línea -->
<!-- recta.  De esta forma podemos derivar el radio del círculo del ángulo -->
<!-- de dirección. Bien, el siguiente paso consiste en calcular la velocidad -->
<!-- angular, es decir, la velocidad a la que el coche gira. La velocidad -->
<!-- angular se suele representar mediante la letra griega omega (), y se -->
<!-- expresa en radianes por segundo. (Un radián es un círculo completo, -->
<!-- dividido por 2 pi). Es bastante sencillo de determinar: si estamos -->
<!-- conduciendo en círculos a una velocidad constante v y el radio del círculo -->
<!-- es R, ¿cuánto tiempo se tarda en completar un círculo? Esa es la -->
<!-- circunferencia dividida por la velocidad. En el momento en que el -->
<!-- coche ha descrito una trayectoria circular también ha girado alrededor -->
<!-- de su eje exactamente una vez. En otras palabras: -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/cteq_av.gif -->
<!--  -->
<!-- Mediante el uso de estas dos últimas ecuaciones, sabemos lo rápido que -->
<!-- el coche debe acudir en busca de un ángulo de giro dado a una -->
<!-- velocidad específica. Eso es todo lo que necesitamos para giros a -->
<!-- bajas velocidades. El ángulo de dirección se determina a partir de la -->
<!-- entrada del usuario. La velocidad del coche se determina de la misma -->
<!-- forma en que se calcula en movimientos rectilíneos (el vector de -->
<!-- velocidad siempre apunta en la dirección del coche). A partir de éste -->
<!-- se calcula el radio del círculo y la velocidad angular. La velocidad -->
<!-- angular se utiliza para cambiar la orientación del coche a una tasa -->
<!-- específica. La velocidad del coche no se ve afectado por el cambio, el -->
<!-- vector de velocidad sólo rota para que coincida con la orientación del -->
<!-- coche. -->
<!--  -->
<!-- ***************************** -->
<!-- Giros a altas velocidades -->
<!-- ***************************** -->
<!--  -->
<!-- Por supuesto, no hay muchos juegos que involucran autos que circulan -->
<!-- alrededor tranquilamente (aparte de la legendaria Trabant Granny -->
<!-- Racer;-). Los jugadores son impaciente y por lo general quieren llegar -->
<!-- a algún lugar a toda prisa, añadiendo derrapes, y destrozo de -->
<!-- mobiliario vario. El objetivo es encontrar un modelo de físicas que -->
<!-- permita vueltas subvirajes, sobreviraje, derrape, freno de mano, etc. -->
<!--  -->
<!-- A altas velocidades, ya no podemos asumir que las ruedas se están -->
<!-- moviendo en la dirección que apuntan. Están unidas a la carrocería del -->
<!-- vehículo que tiene una cierta masa y lleva un toma tiempo al coche -->
<!-- reaccionar a las fuerzas de dirección. El cuerpo del coche también -->
<!-- puede tener una velocidad angular. Al igual que con la velocidad -->
<!-- lineal, lleva tiempo que ésta tome los valores que nosotros queremos -->
<!-- para que el coche gire hacia donde queramos. La velocidad angular -->
<!-- depende de la aceleración angular que es a su vez dependiente del par -->
<!-- de torsión y de la inercia (que son los equivalentes de rotación de la -->
<!-- fuerza y ​​de la masa). -->
<!--  -->
<!-- Además, el propio vehículo no siempre se mueve en la dirección en que -->
<!-- quiere el conductor. Piense en pilotos de rally que pasan por una -->
<!-- curva. El ángulo entre la orientación del coche y vector de velocidad -->
<!-- del coche se conoce como el ángulo de deslizamiento lateral (beta). -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/ctbeta.jpg -->
<!--  -->
<!-- Ahora echemos un vistazo a alta velocidad en curva desde el punto de -->
<!-- vista de la rueda. En esta situación tenemos que calcular la velocidad -->
<!-- lateral de los neumáticos. Dado que las ruedas grian, tienen -->
<!-- relativamente baja resistencia al movimiento hacia adelante o hacia -->
<!-- atrás. sin embargo, las ruedas oponen resistencia a movimientos -->
<!-- perpendiculares a la dirección en la que apuntan. Pruebe empujando un -->
<!-- neumático del coche de lado. Esto es muy difícil porque hay que vencer -->
<!-- la fuerza máxima fricción estática para conseguir que la rueda se deslice. -->
<!--  -->
<!-- En las curvas de alta velocidad, los neumáticos sufren unas las -->
<!-- fuerzas laterales también conocida como la fuerza de viraje. Esta -->
<!-- fuerza depende del ángulo de deslizamiento (alfa), que es el ángulo -->
<!-- entre el rumbo del neumático y su dirección de desplazamiento. A -->
<!-- medida que el ángulo de deslizamiento crece, también lo hace la fuerza -->
<!-- de viraje. La fuerza de viraje por neumático también depende del peso -->
<!-- sobre el neumático. En ángulos de deslizamiento bajos, la relación -->
<!-- entre el ángulo de deslizamiento y fuerza de viraje es lineal, en -->
<!-- otras palabras: -->
<!--  -->
<!-- Flateral = Ca * alpha -->
<!-- donde la constante de Ca se conoce como la rigidez en las curvas. -->
<!--  -->
<!-- Si desea ver esta explicado en una imagen, tenga en cuenta la -->
<!-- siguiente. El vector de velocidad de la rueda tiene un ángulo alfa con -->
<!-- respecto a la dirección en la que la rueda apunta. Podemos dividir el -->
<!-- vector velocidad v en dos componentes. El vector longtitudinal = cos -->
<!-- magnitud (alfa) * v. El movimiento en esta dirección se corresponde con -->
<!-- la dirección en la que giro la rueda. El vector lateral tiene -->
<!-- magnitud sen (alfa) * v y provoca una fuerza de resistencia en la -->
<!-- dirección opuesta: la fuerza de viraje. -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/ctimage8.gif -->
<!--  -->
<!-- Hay tres componentes que definen el ángulo de deslizamiento de las -->
<!-- ruedas: el ángulo de deslizamiento lateral del coche, la rotación -->
<!-- angular del coche alrededor del eje hacia arriba (velocidad de -->
<!-- derrape) y, para las ruedas delanteras, el ángulo de dirección. -->
<!--  -->
<!-- El ángulo de deslizamiento lateral b (beta) es la diferencia entre la -->
<!-- orientación del vehículo y la dirección del movimiento. En otras -->
<!-- palabras, es el ángulo entre el eje longtitudinal y la dirección real -->
<!-- de viaje. Así que es similar en concepto a lo que el ángulo de -->
<!-- deslizamiento es para los neumáticos. Debido a que el coche puede -->
<!-- moverse en una dirección diferente a donde está apuntando, experimenta -->
<!-- un movimiento hacia los lados. Esto es equivalente a la componente -->
<!-- perpendicular del vector de velocidad. -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/ctbeta.gif -->
<!--  -->
<!-- Si el coche está girando alrededor del centro de masas (CG) a una tasa -->
<!-- omega (en rad / s!), esto significa que las ruedas delanteras -->
<!-- describen una trayectoria circular alrededor del centro de gravedad -->
<!-- CG. Si el coche realiza un círculo completo, la rueda delantera -->
<!-- habrá descrito una trayectoria circular de 2 * pi * b la  distancia alrededor de CG -->
<!-- en 1 / (2.pi.omega) segundos, donde b es la distancia desde el eje -->
<!-- delantero al CG. Esto se traduce en una velocidad lateral de omega * -->
<!-- b. Para las ruedas traseras, esto es -omega * c. Tenga en cuenta la -->
<!-- inversión del signo. Para expresar esto como un ángulo, se debe tomar el arco -->
<!-- tangente de la velocidad lateral dividida por la velocidad -->
<!-- longtitudinal (tal como lo hicimos para la beta). Para ángulos -->
<!-- pequeños podemos aproximar arctan (vy / vx) por vx / vy. -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/ctav.gif -->
<!--  -->
<!-- El ángulo de dirección (delta) es el ángulo que las ruedas delanteras -->
<!-- hacen en relación a la orientación del coche. No hay ángulo de dirección -->
<!-- de las ruedas traseras, ya que siempre están alineadas con la orientación -->
<!-- del cuerpo del coche. En el caso de coches con tracción delantera, el efecto de la -->
<!-- dirección invierte. -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/ctdeltapic.gif -->
<!--  -->
<!-- Los ángulos de deslizamiento para las ruedas delanteras y traseras -->
<!-- están dadas por las siguientes ecuaciones: -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/ct_alphas.gif -->
<!--  -->
<!-- La fuerza lateral ejercida por el neumático es una función del ángulo -->
<!-- de deslizamiento. De hecho, para los neumáticos reales es una función -->
<!-- bastante complejo una vez mejor descrito por diagramas de curvas, -->
<!-- tales como las siguientes: -->
<!--  -->
<!-- file:///home/isaac/Documentos/tfg/fisicas/Car%20Physics_files/ctsacurve.gif -->
<!--  -->
<!-- El diagrama anterior muestra cómo se comporta la fuerza lateral para -->
<!-- cualquier valor particular del ángulo de deslizamiento. Este tipo de -->
<!-- diagrama es específico para un tipo particular de neumático, siendo el -->
<!-- diagrama anterior un ejemplo ficticio. El pico está alrededor de los 3 -->
<!-- grados. En ese punto la fuerza lateral supera incluso ligeramente la -->
<!-- carga de 5 kN en el neumático. -->
<!--  -->
<!-- Este diagrama es similar a la curva de relación de deslizamiento visto -->
<!-- anteriormente lo que puede llevar a confusión. La curva de relación de -->
<!-- deslizamiento nos da la fuerza de avance en función de cantidad de -->
<!-- deslizamiento longtitudinal. La curva anterior nos da la fuerza -->
<!-- lateral en función del ángulo de deslizamiento. -->
<!--  -->
<!--  -->
<!-- La fuerza lateral no sólo depende del ángulo de -->
<!-- deslizamiento, sino también de la carga en el neumático. La -->
<!-- gráfica anterior muestra una gráfica donde el valor máximo de -->
<!-- la fuerza lateral asciende a 5000N; es decir, la fuerza -->
<!-- ejercida por 500 kg de masa empujando contra la superficie del -->
<!-- neumático. Diferentes curvas de fuerza aplican diferentes -->
<!-- fuerzas debido a que el peso cambia la forma del neumático y -->
<!-- por lo tanto sus propiedades. Pero la forma de la curva es muy -->
<!-- similar, aparte de la escala, por lo que se puede aproximar a -->
<!-- que la fuerza lateral es lineal con la carga y creamos un -->
<!-- diagrama de fuerza lateral normalizada dividiendo la fuerza -->
<!-- lateral por el 5 kN de carga. -->
<!--  -->
<!-- Flateral = Fn, lat * Fz -->
<!-- donde Fnlat es la fuerza lateral normaliazda para un angulo de deslizamiento dado y -->
<!-- Fz es la carga del neumático. -->
<!--  -->
<!-- Para ángulos muy pequeños (por debajo del máximo) la fuerza lateral -->
<!-- puede ser aproximado por una función lineal: -->
<!--  -->
<!-- Flateral = Ca * alpha -->
<!-- La constante de Ca se conoce con el -->
<!-- nombre de la rigidez de las curvas. Esta es la pendiente del -->
<!-- diagrama en ángulo de deslizamiento 0. -->
<!--  -->
<!-- Si desea una mejor aproximación de la relación entre el ángulo de -->
<!-- deslizamiento y la fuerza lateral debe usar la fórmula mágica Pacejka -->
<!-- , desarrollada en la Universidad de Delft. Dicha fórmula es la que -->
<!-- usan los físicos para modelar el comportamiento de los -->
<!-- neumáticos. Es un conjunto de ecuaciones con una gran cantidad de -->
<!-- constantes "mágicas". Al elegir las constantes adecuadas estas -->
<!-- ecuaciones proporcionan una muy buena aproximación de curvas que se -->
<!-- encuentran a través de pruebas de neumáticos. El problema es que los -->
<!-- fabricantes de neumáticos son muy reservado acerca de los valores de -->
<!-- estas constantes toman. Así, por un lado, es una técnica de modelado -->
<!-- muy precisas. Por otro lado, usted tendrá un tiempo para encontrar -->
<!-- valores adecuados a los neumáticos que se estén usando. -->
<!--  -->
<!-- Las fuerzas laterales de los cuatro neumáticos tienen dos resultados: -->
<!-- una fuerza neta en las curvas y un par alrededor del eje de giro. La -->
<!-- fuerza de viraje es la fuerza sobre el centro de gravedad en un ángulo -->
<!-- recto con la orientación del coche y sirve como la fuerza centrípeta -->
<!-- que es necesaria para describir una trayectoria circular. La -->
<!-- contribución de las ruedas traseras a la fuerza de viraje es la misma -->
<!-- que la fuerza lateral. Para las ruedas delanteras, multiplicar la -->
<!-- fuerza lateral por cos (delta) para permitir el ángulo de dirección. -->
<!--  -->
<!-- Fcornering = Flat, rear + cos(delta) * Flat, front -->
<!--  -->
<!-- Como punto de interés, podemos encontrar el radio del círculo ahora -->
<!-- que sabemos la fuerza centrípeta utilizando la siguiente ecuación -->
<!--  -->
<!-- Fcentripetal = M v2 / radius -->
<!--  -->
<!-- La fuerza lateral también introducir un par que hace que el cuerpo del -->
<!-- coche para encender. Después de todo, sería muy tonto si el coche está -->
<!-- describiendo un círculo, pero sigue apuntando en la misma -->
<!-- dirección. La fuerza de viraje se asegura la CG describe un círculo, -->
<!-- pero ya que opera sobre una masa puntual no hace nada sobre la -->
<!-- orientación coche. Eso es lo que necesitamos el par alrededor del eje -->
<!-- de guiñada para.  El torque es la fuerza multiplicada por la distancia -->
<!-- perpendicular entre el punto donde se aplica la fuerza y el punto de -->
<!-- pivote. Así que para las ruedas traseras de la contribución a la par -->
<!-- es -Flat, trasera * c y para las ruedas delanteras es cos (delta) * -->
<!-- Piso *, delante b. Tenga en cuenta que el signo es diferente. -->
<!--  -->
<!-- La aplicación de par de torsión sobre la carrocería del vehículo -->
<!-- introduce la aceleración angular. Al igual que la segunda ley de -->
<!-- Newton F = ma, hay una ley para el par y aceleración angular: -->
<!--  -->
<!-- Torque = Inertia * angular acceleration. -->
<!--  -->
<!-- La inercia de un cuerpo rígido es una constante que depende de su masa -->
<!-- y la geometría (y la distribución de la masa dentro de su -->
<!-- geometría). Manuales de ingeniería proporcionan fórmulas para la -->
<!-- inercia de las formas comunes tales como esferas, cubos, etc. -->
<!--  -->
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/roadmap/roadmap-del-proyecto.html" class="u-url">Roadmap del proyecto</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/roadmap/roadmap-del-proyecto.html" rel="bookmark"><time class="published dt-published" datetime="2015-02-22T17:15:49+01:00" itemprop="datePublished" title="2015-02-22 17:15">2015-02-22 17:15</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<p>En esta entrada se va a mostrar cuál es el estado actual del proyecto, qué objetivos se han cumplido y en qué porcentaje. Además se hablará en qué se está trabajando actualmente.</p>
<div class="section" id="estado-del-proyecto">
<h2>Estado del proyecto</h2>
<p>En primer lugar, recordemos cuál es la lista de hitos que se pretenden cumplir en este proyecto:</p>
<ul class="simple">
<li>Desarrollar un videojuego utilizando gráficos 3D.</li>
<li>Implementar mecanismos de instrumentación que permitan aplicar técnicas de testing automático.</li>
<li>Diseñar e implementar un modelo de red para permitir modo multijugador.</li>
</ul>
<p>Como subobjetivo, se pretende que dicho videojuego pueda servir a futuros programadores para aprender técnicas básicas y fundamentos esenciales del desarrollo de un videojuego. Por esta razón se hará énfasis en los siguientes aspectos:</p>
<ul class="simple">
<li>Claridad del código.</li>
<li>Uso de patrones de diseño.</li>
<li>Técnicas de introspección de objetos.</li>
<li>Acceso al código fuente y al propio proyecto. Por esta razón se distribuirá bajo una licencia libre.</li>
</ul>
<div class="section" id="grado-de-cumplimiento-de-los-objetivos">
<h3>Grado de cumplimiento de los objetivos</h3>
<p>Hasta la fecha se han cumplido los siguientes objetivos:</p>
<ol class="arabic simple">
<li>Desarrollo de un videojuego utilizando gráficos 3D: Se ha conseguido desarrollar una primera versión del juego de carreras. En el siguiente vídeo se ve una muestra de lo desarrollado hasta la fecha. Aunque el vídeo no tiene sonido, el motor de juego que se ha desarrollado para este proyecto sí que cuenta con el soporte para incluirlos.<ul>
<li>
<em>Trabajo futuro</em>: animaciones y efectos de partículas, así
como mejorar el aspecto visual de los menús, seleccionar sonidos
adecuados para este juego(música y efectos). En cuanto al gameplay, se
pretende dar la oportunidad al jugador de mejorar su coche mediante la
compra de mejoras.</li>
</ul>
</li>
</ol>
<iframe width="425" height="344" src="//www.youtube.com/embed/Rn_WwsMEW_4?rel=0&amp;hd=1&amp;wmode=transparent"></iframe><ol class="arabic simple" start="2">
<li>Implementar mecanismos de instrumentación que permitan aplicar técnicas de testing automático: gran parte de la arquitectura del motor de juego que se ha desarrollado para este proyecto ha surgido a partir de las pruebas que se han escrito. Son pruebas muy sencillas basadas en log escritas a modo de pequeños <a class="reference external" href="https://bitbucket.org/arco_group/tfg.tinman/src/e56b57a12b1661caa19d066f3127827e28a36186/examples/?at=master">ejemplos</a>. Dichos ejemplos son en realidad pruebas de comportamiento; es decir, lo que se persigue no es comprobar que el valor de retorno de una determinada función es correcto, sino que el funcionamiento en conjunto del sistema es el adecuado. La ventaja es que las pruebas se han escrito con la hoja de especificación de requisitos en la mano, lo que nos permite afirmar que se están implementando al pie de la letra. Las pruebas sacan obtienen la información del sistema a través de un sistema de logs que se ha añadido al motor, el cuál facilita la labor de depuración. Además, dado que la salida de las pruebas se registra en ficheros de texto, es posible automatizar la ejecución de las pruebas y mas tarde comprobar los resultados.<ul>
<li>
<em>Trabajo futuro</em>: La limitación del sistema de log que usamos es que sólo puede proporcionar información relativa a los objetos del juego, la traza de ejecución o las excepciones lanzadas. Cuándo queremos comprobar cualquier aspecto referente a la interfaz gráfica, nos encontramos con que no tenemos el soporte necesario. Una posible forma de hacer frente a esta limitación consistiría en hacer uso de una biblioteca de analisis de imagen, a la cuál le pasaríamos una captura de pantalla. En teoría, este tipo de pruebas nos permitirían asegurarnos que la construcción de los escenarios es correcta, así como los menús y demás elementos gráficos, aunque queda mucho trabajo de investigación por delante para ver hasta qué punto es realmente útil la implementación de pruebas de este tipo.</li>
</ul>
</li>
<li>Diseñar e implementar un modelo de red para permitir modo multijugador: actualmente se está trabajando en el modelo de red del juego. Para ello, se está utilizando <a class="reference external" href="https://www.zeroc.com/">ZeroC Ice</a>, un middleware de red orientado a objetos. Cuenta con implementación en python, C++, java, etcétera.<ul>
<li>
<em>Trabajo futuro</em>: Generalmente se suele decir que los middleware de
red añaden demasiada sobrecarga y, por esta razón, no son adecuados
para juegos que requieren reacciones rápidas por parte de los
jugadores, como son los juegos de carreras. Con el uso de este
middleware se pretende probar que el uso de un middleware de red, si
es lo suficientemente flexible, permite adecuarse a las necesidades de
los desarrolladores y, aunque añada una mayor sobrecarga que una
implementación que sólo ofrezca soporte para sockets, los mecanismos
de alto nivel que proporciona hace que merezca la pena.</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/introduccion-bullet/introduccion-a-bullet-physics.html" class="u-url">Introducción a Bullet Physics</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/introduccion-bullet/introduccion-a-bullet-physics.html" rel="bookmark"><time class="published dt-published" datetime="2015-02-07T17:21:22+01:00" itemprop="datePublished" title="2015-02-07 17:21">2015-02-07 17:21</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="bullet_logo.png" class="align-center" src="posts/introduccion-bullet/bullet_logo.png">
<p>En esta nueva entrada se va a hablar de Bullet Physics, el motor de
físicas y detección de colisiones usado en el proyecto Tinman.Se va a
explicar brevemente la razón de la elección, se enumerarán las
características principales y, a continuación, se mostrará un breve
programa que ilustrará cómo integrar Bullet junto a <a class="reference external" href="http://isaaclacoba.github.io/tinman/posts/introduccion-ogre3d/introduccion-a-ogre3d.html">Ogre3D</a>,
la biblioteca de renderizado usada en este proyecto.</p>
<div class="section" id="que-es-bullet-physics">
<h2>¿Qué es Bullet Physics?</h2>
<p><a class="reference external" href="http://bulletphysics.org/wordpress/">Bullet Physics</a> es una
biblioteca de físicas y detección de colisiones. Se distribuye bajo
licencia ZLib y está desarrollada usando el lenguaje de programación
C++. El código fuente se encuentra disponible en el <a class="reference external" href="https://github.com/bulletphysics/bullet3">repositorio</a>
oficial del proyecto.</p>
<p>Bullet ha sido usado en multitud de películas, tales como Hancock o
Sherlock Holmes, así como videojuegos comerciales AAA, entre los que
destacan Grand Theft auto IV, Grand Theft auto V o Red Dead
Redemption. Como curiosidadw, la NASA está utilizando Bullet en un
<a class="reference external" href="http://bulletphysics.org/wordpress/?p=413">framework</a> de desarrollo
propio que tiene como propósito el cálculo de integridad tensional en
robots.</p>
<p>Entre las principales característica de Bullet podemos enumerar las siguientes:
- Soporte para una gran multitud de plataformas, tales
como PlayStation 3 y 4, Xbox 360 y One, Wii, Gnu/Linux, Windows,
MacOSX, iPhone, Android y <a class="reference external" href="http://bulletphysics.org/wordpress/?p=333">navegador web</a>.</p>
<ul class="simple">
<li>Elección entre precisión simple y doble en operaciones de punto flotante.</li>
<li>Detección de colisiones, tanto continua como discreta, incluyendo rayqueries y tests de colisión de formas convexas (<em>sweep test</em>). Permite realizar test de colisión con mallas convexas y cóncavas, además de con todo tipo de formas primitivas: cubos, esferas, planos, etcétera.</li>
<li>Dinámica de cuerpos rígidos, de vehículos, controladores de personajes, creación de <a class="reference external" href="http://es.wikipedia.org/wiki/F%C3%ADsica_ragdoll">ragdolls</a>, restricciones de tipo slider, bisagra y 6DOF (6 grados de libertad).</li>
<li>Dinámica de cuerpos fluidos que permite modelar ropa, tela y volumenes deformables, permitiendo interacción con cuerpos rígidos.</li>
<li>Existen plugins para dar soporte a Maya, Cinema 4D, está integrado con Blender, soporta ficheros COLLADA.</li>
</ul>
<div class="section" id="porque-es-necesario-utilizar-un-motor-de-fisicas">
<h3>¿Porqué es necesario utilizar un motor de físicas?</h3>
<p>Como se explicó en el <a class="reference external" href="http://isaaclacoba.github.io/tinman/posts/justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html">post anterior</a>,
uno de los objetivos de este proyecto es desarrollar un videojuego de
carreras 3D. Aunque se trata de un videojuego arcade, es necesario
modelar el comportamiento del coche de una forma mínimamente realista,
además de poder detectar y gestionar colisiones entre los coches y el
escenario.</p>
<p>Como puede verse en este <a class="reference external" href="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html">artículo</a>
modelar el comportamiento de un coche presenta algunos problemas,
entre los que podemos destacar la distribución de la carga del coche
derivada de la aceleración y frenado de este o la gran cantidad de
propiedades físicas que intervienen en el movimiento del coche, como
la tracción, el par motor que se ejerce sobre las ruedas a través de
la transmisión, la inercia del coche, etcétera.</p>
<p>El uso de un motor de físicas nos permite juegos mas realistas, al
tiempo que abstrae al desarrollador de los detalles de bajo nivel, ofreciéndonos una implementación bien probada y eficiente.</p>
</div>
<div class="section" id="porque-elegir-bullet-antes-que-otras-bibliotecas-de-fisicas">
<h3>¿Porqué elegir Bullet antes que otras bibliotecas de físicas?</h3>
<p>Unas de los requisitos que existen en este proyecto es el uso de
tecnologías de código libre. A la hora de elegir un motor de físicas se descartaron por defecto los motores comerciales privativos, entre los que se pueden destacar Havok y PhysX. Entre los motores libres, se encontraron tres que podrían competir en calidad con los dos mencionados anteriormente: Bullet Physics, Open Dynamics Engine (mas conocido como ODE) y Newton Physics.</p>
<p>Se eligió Bullet debido a que de los tres motores anteriores, era el que mas facilidades daba a la hora de integrarlo con OGRE3D, ofrece dinámica de vehículos basada en rayqueries, es un proyecto mas moderno y mirando a largo plazo, el equipo de desarrollo de Bullet está actualmente implementando soporte sobre GPU sin necesidad de usar OpenCL ni Cuda. Bullet en su versión 2.8 ofrece soporte para las dos bibliotecas anteriores. Por último, el hecho de que existan proyectos comerciales de gran renombre, como es la saga <em>Grand Thef Auto</em>, terminaron de decantar la balanza a favor de esta biblioteca.</p>
<p>Aunque es cierto que los tres motores de físicas ofrecen
implementaciones de dinámica de cuerpos rígidos muy eficientes, una
búsqueda por las páginas oficiales de los proyectos revela que Bullet
es el más activo de los tres, disponiendo de una mayor cantidad de
documentación, teniendo como único punto negativo que la documentación
del <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/annotated.html">API</a>
no ofrece información acerca del uso de los métodos, mas allá del
nombre del mismo y una referencia a la línea en la que se encuentra la
definición de dicho método dentro del fichero fuente donde se haya
implementado.</p>
<p>Todas estas razones sumadas han hecho que se elija Bullet Physics como motor de físicas en este proyecto.</p>
</div>
</div>
<div class="section" id="arquitectura">
<h2>Arquitectura</h2>
<p>Bullet ha sido diseñado para ser modular y adaptable. La biblioteca da
la libertad al desarrollador de usar los componentes que necesite en
cada momento, ignorando los demás. Por ejemplo, se podría hacer uso de
la capa de detección de colisiones sin hacer uso de las capas
superiores. En la siguiente figura se puede observar un esquema
general de la organización por capas de la biblioteca.</p>
<img alt="organizacion-bullet.png" class="align-center" src="posts/introduccion-bullet/organizacion-bullet.png">
<div class="section" id="pipeline-de-simulacion-de-cuerpos-rigidos">
<h3>Pipeline de simulación de cuerpos rígidos</h3>
<p>El siguiente diagrama muestra las estructuras de datos mas
importantes, así como las etapas del encauzamiento dentro de
Bullet. Este encauzamiento se ejecuta de izquierda a derecha,
comenzando por aplicar la gravedad y terminando por integrar las
posiciones de los cuerpos.</p>
<img alt="pipeline-bullet.png" class="align-center" src="posts/introduccion-bullet/pipeline-bullet.png">
<p>El encauzamiento y las estructuras de datos están representados en
Bullet a través de la clase DynamicsWorld. Cuando se ejecuta el método
"stepSimulation de dicha clase, en realidad se está ejecutando el
encauzamiento anterior. La implementación por defecto se encuentra en
la clase btDiscreteDynamicsWorld.</p>
<p>Bullet permite trabajar al desarrollador con subfases del
encauzamiento, como la de detección de colisiones, la fase en la que
se aplican los efectos de las colisiones a los cuerpos
físicos(narrowphase) o la fase de resolución de restricciones.</p>
</div>
</div>
<div class="section" id="veamos-algo-de-codigo">
<h2>Veamos algo de código</h2>
<p>A continuación veremos un sencillo ejemplo en el que generaremos
esferas que rebotarán contra el suelo. Estas esferas se crearán
dinámicamente al pulsar la tecla 'B'.</p>
<p>Usaremos la biblioteca <a class="reference external" href="http://sourceforge.net/projects/wgois/">OIS</a>
para gestionar los eventos de teclado y Ogre3D como motor de
renderizado, que nos permitirá representar la escena. En este post se
dará por supuesto los conceptos básicos de Ogre3D. Para el lector que
no esté acostumbrado a trabajar con esta biblioteca, se aconseja
conocer al menos como inicializar el motor de renderizado, así como
gestionar nodos de escena y entidades. El código fuente se puede
encontrar en el repositorio de este <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-bullet">tutorial</a>.</p>
<div class="section" id="instalacion">
<h3>Instalación</h3>
<p>Las explicaciones dadas en este post están orientadas a un sistema operativo GNU/Linux. En el repositorio anterior podemos encontrar un fichero <a class="reference external" href="http://goo.gl/cKHhq9">DEPENDS</a> donde se listan los paquetes necesarios. Para instalar dichos paquetes tan sólo tenemos que ejecutar en un terminal los siguientes comandos. Para instalar Ogre, así como algunas dependencias de OpenGL y el driver gráfico mesa:</p>
<pre class="code bash literal-block">
sudo apt-get install libogre-1.8.0 libogre-1.8-dev freeglut3-dev libfreetype6 libfreetype6-dev libgl1-mesa-dev libgl1-mesa-glx
</pre>
<p>En el caso de OIS:</p>
<pre class="code bash literal-block">
sudo apt-get install libois-1.3.0 libois-dev
</pre>
<p>Y en el de Bullet:</p>
<pre class="code bash literal-block">
sudo apt-get install libbullet-dev libbullet2.82-dbg libbullet-extras-dev
</pre>
</div>
<div class="section" id="inicializacion">
<h3>Inicialización</h3>
<p>En este ejemplo, todo lo relativo a la inicialización de Bullet se
puede encontrar en los ficheros <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-bullet/src/ed9787be35bf81cb7cc61246e73729d96a42d374/src/managers/physics.cpp?at=master">physics.cpp</a> y
<a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-bullet/src/ed9787be35bf81cb7cc61246e73729d96a42d374/src/managers/physics.h?at=master">physics.h</a>. En él, se van a modelar las esferas usando cuerpos
rígidos. Los cuerpos rígidos tienen como principal característica que
no se deforman; es decir, la distancia entre cualquier par de vértices
que forman la malla nunca varía. Por el contrario, los cuerpos fluidos
son aquellos que permiten deformaciones. En este post se va a
intentar obviar toda la base matemática y se va a centrar la
explicación en los aspectos referentes a la biblioteca.</p>
<p>El elemento mas importante en Bullet es el <em>Mundo</em>. El <em>Mundo</em>
dentro de Bullet tiene varias responsabilidades, entre las que
podemos destacar:</p>
<ul class="simple">
<li>servir como estructura de datos donde almacenar los cuerpos
físicos que lo conforman.</li>
<li>aplicar una serie de restricciones a estos cuerpos, como la
fuerza de la gravedad, detectar y aplicar colisiones entre estos
cuerpos y actualizar su posición automáticamente cuando se aplique
cualquier tipo de fuerza sobre estos.</li>
</ul>
<p>El <em>Mundo</em> tiene diversas implementaciones dentro de la bibilioteca,
dependiendo de si utilizamos cuerpos rígidos o fluidos.  En este caso
se están usando cuerpos rígidos, de modo que la clase que se utilizará
será <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtDiscreteDynamicsWorld.html">btDiscreteDynamicsWorld</a>. En el siguiente listado de código se muestra el constructor del gestor de
físicas, que inicializa el objeto <em>btDiscreteDynamicsWorld</em>:</p>
<pre class="code c++ literal-block">
<span class="n">Physics</span><span class="o">::</span><span class="n">Physics</span><span class="p">(</span><span class="n">btVector3</span> <span class="n">gravity</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">gravity_</span> <span class="o">=</span> <span class="n">gravity</span><span class="p">;</span>

       <span class="n">broadphase_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btDbvtBroadphase</span><span class="p">();</span>

       <span class="n">solver_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btSequentialImpulseConstraintSolver</span><span class="p">();</span>
       <span class="n">collision_configuration_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btDefaultCollisionConfiguration</span><span class="p">();</span>
       <span class="n">dispatcher_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btCollisionDispatcher</span><span class="p">(</span><span class="n">collision_configuration_</span><span class="p">);</span>
       <span class="n">dynamics_world_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btDiscreteDynamicsWorld</span><span class="p">(</span><span class="n">dispatcher_</span><span class="p">,</span>
       <span class="n">broadphase_</span><span class="p">,</span> <span class="n">solver_</span><span class="p">,</span> <span class="n">collision_configuration_</span><span class="p">);</span>
       <span class="n">dynamics_world_</span><span class="o">-&gt;</span><span class="n">setGravity</span><span class="p">(</span><span class="n">gravity_</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Cada uno de los objetos que recibe el constructor de la clase
<em>btDiscreteDynamicsWorld</em> corresponde con una de las fases del
pipeline físico. El objeto broadphase corresponde a la fase de
detección de colisiones. Existen tres implementaciones de esta fase
que trabajan con diferentes estructuras de datos, lo que permite
acelerar la búsqueda de pares de colisión dependiendo de nuestras
necesidades:</p>
<ul class="simple">
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/structbtDbvtBroadphase.html">btDbvtBroadphase</a> usa una jerarquía de volumenes delimitantes
basada en un arbol AABB.</li>
<li>
<a class="reference external" href="http://www.bulletphysics.com/Bullet/BulletFull/classbtAxisSweep3.html">btAxisSweep3</a> y <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbt32BitAxisSweep3.html">bt32BitAxisSweep3</a> implementa  un algoritmo 3d de barrido y poda.</li>
<li>
<a class="reference external" href="http://bullet.googlecode.com/svn/trunk/Extras/CUDA/btCudaBroadphase.h">btCudaBroadphase</a> implementa un grid usando el hardware de la
GPU. Hace uso de Cuda, una tecnología para tarjetas gráficas Nvidia.</li>
</ul>
<p>La fase de detección de colisiones hace uso de una serie de estructuras de datos:</p>
<ul class="simple">
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCollisionObject.html">btCollisionObject</a>:
almacena formas de colisión y las transformaciones de éstas.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCollisionShape.html">btCollisionShape</a>:
describe la forma de colisión de un objeto de colisión, tal como una
caja, una esfera, una forma convexa(convex hull) o una malla de
triángulos. Una forma de colisión puede ser compartida entre
múltiples objetos de colisión.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtGhostObject.html">btGhostObject</a>: es un
caso especial de cuerpo de colisión útil para realizar consultas de
colisión de una forma rápida.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCollisionWorld.html">btCollisionWorld</a>:
almacena todos los objetos de colisión y proporciona una interfaz
que permite realizar peticiones de forma eficiente. Nuestro objeto
dynamics_world_ es de tipo btDiscreteDynamicsWorld, que es una
subclase de ésta.</li>
</ul>
<p>El objeto dispatcher_ pertenece a la clase <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCollisionDispatcher.html">btCollisionDispatcher</a>, la
cuál ofrece algoritmos que manejan pares de colisión ConvexConvex y
ConvexConcave. Esta clase corresponde a la etapa <em>Narrowphase</em>, usando
los pares de colisión generados en la fase <em>Broadphase</em>.</p>
<p>El objeto collisionConfiguration_, de la clase
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtDefaultCollisionConfiguration.html">btDefaultCollisionConfiguration</a>,
ofrece una configuración por defecto que define aspectos internos del
asignador de la pila de detección de colisiones, del asignador de la
pila de memoria de bullet, etcétera.</p>
<p>Por último, el objeto solver_, de la clase
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtSequentialImpulseConstraintSolver.html">btSequentialImpulseConstraintSolver</a>, ofrece una implementación del
método <a class="reference external" href="http://es.wikipedia.org/wiki/M%C3%A9todo_de_Gauss-Seidel">Gauss-Seidel</a> usado en analisis numérico para resolución de
sistemas de ecuaciones lineales. Esta clase está implementada usando paralelización SIMD(<em>Single Instruction, Multiple Data</em>), una técnica
utilizada para conseguir paralelismo a nivel de datos. Sin entrar en
detalles, consiste en aplicar una misma operación sobre un conjunto de
datos.</p>
<p>Tras inicializar la biblioteca, el siguiente paso consiste en crear
cuerpos y formas de colisión.</p>
</div>
<div class="section" id="creando-los-cuerpos-rigidos-de-las-esferas">
<h3>Creando los cuerpos rígidos de las esferas</h3>
<p>El siguiente listado de código muestra cómo se crean los cuerpos
rígidos en nuestro ejemplo:</p>
<pre class="code c++ literal-block">
<span class="n">btRigidBody</span><span class="o">*</span>
<span class="n">Physics</span><span class="o">::</span><span class="n">create_rigid_body</span><span class="p">(</span><span class="k">const</span> <span class="n">btTransform</span> <span class="o">&amp;</span><span class="n">worldTransform</span><span class="p">,</span>
                  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span>
                  <span class="n">btCollisionShape</span><span class="o">*</span> <span class="n">shape</span><span class="p">,</span>
                  <span class="n">btScalar</span> <span class="n">mass</span><span class="p">){</span>
  <span class="n">btVector3</span> <span class="n">inertia</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">mass</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="n">shape</span><span class="o">-&gt;</span><span class="n">calculateLocalInertia</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">inertia</span><span class="p">);</span>

  <span class="n">MotionState</span><span class="o">*</span> <span class="n">motionState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MotionState</span><span class="p">(</span><span class="n">worldTransform</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
  <span class="n">btRigidBody</span><span class="o">::</span><span class="n">btRigidBodyConstructionInfo</span>
    <span class="n">rigidBodyCI</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">motionState</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">inertia</span><span class="p">);</span>

  <span class="n">btRigidBody</span><span class="o">*</span> <span class="n">rigidBody</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btRigidBody</span><span class="p">(</span><span class="n">rigidBodyCI</span><span class="p">);</span>
  <span class="n">dynamics_world_</span><span class="o">-&gt;</span><span class="n">addRigidBody</span><span class="p">(</span><span class="n">rigidBody</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">rigidBody</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>El constructor de la clase <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtRigidBody.html">btRigidBody</a> recibe un objeto <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/structbtRigidBody_1_1btRigidBodyConstructionInfo.html">btRigidBody::btRigidBodyConstructionInfo</a>. Este objeto sirve para inyectar al constructor de la clase información relativa al cuerpo rígido que se va a crear . Los argumentos que recibe son la masa del objeto, el estado del cuerpo(<em>Motion State</em> del cuál
hablaremos mas adelante), la forma física del cuerpo(<em>btCollisionShape</em>) y el vector de inercia.</p>
<p>En el método <em>Physics::create_rigid_body</em>, listado anteriormente, se
comprueba que la masa del cuerpo sea distinta de cero, ya que Bullet
interpreta que un cuerpo sin masa es equivalente a uno con masa
infinita; es decir, es inamovible. A partir de la forma del cuerpo y
de la masa de este, Bullet calcula la inercia del cuerpo físico que
estamos construyendo a través del método
<em>btCollisionShape::calculateLocalInertia</em>. Una vez creado el cuerpo, hay que
añadirlo al mundo a través del método btDiscreteDynamicsWorld::addRigidBody.</p>
<p>Bullet ofrece una gran variedad de formas primitivas de colisión, entre las que podemos listar:</p>
<ul class="simple">
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtBoxShape.html">btBoxShape</a>: caja definida por el tamaño de sus lados.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtSphereShape.html">btSphereShape</a>: esfera definida por su radio.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCapsuleShape.html">btCapsuleShape</a>: capsula alrededor del eje Y. Tambien existen btCapsuleShapeX/Z.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCylinderShape.html">btCylinderShape</a>.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtConeShape.html">btConeShape</a>: cono alrededor del eje Y. Tambien existen btConeShapeX/Z.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtMultiSphereShape.html">btMultiSphereShap</a>: cascarón convexo formado a partir de varias esferas que puede ser usado para crear una capsula( a partir de dos esferas) u otras formas convexas.</li>
</ul>
<p>Bullet tambien ofrece formas compuestas, pudiendo combinar múltiples
formas convexas en una única usando la clase <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCompoundShape.html">btCompoundShape</a>. Cada una de las formas que dan lugar a la malla principal se llama <em>forma hija</em>. Cada <em>forma hija</em> tiene sus propias transformaciones locales, relativas a la forma compuesta. Existen algunas formas de colisión mas avanzadas que
permiten ajustarse a geometrías que no corresponden con formas
primitivas. Para mas información, se aconseja consultar el <a class="reference external" href="http://www.cs.uu.nl/docs/vakken/mgp/assignment/Bullet%20-%20User%20Manual.pdf">manual
oficial</a> de Bullet. En la figura siguiente se muestra que ayuda en la elección de la forma  de colisión adecuada dependiendo de la situación.</p>
<img alt="esquema-formas.png" class="align-center" src="posts/introduccion-bullet/esquema-formas.png">
<p>Ya se ha visto la lógica que permite crear cuerpos rígidos, de modo que sólo queda crear nuestras esferas:</p>
<pre class="code c++ literal-block">
<span class="kt">void</span>
<span class="n">Game</span><span class="o">::</span><span class="n">create_sphere</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">create_graphic_element</span><span class="p">();</span> <span class="c1">//crea un nodo y una entidad de Ogre
</span>  <span class="n">create_physic_element</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Game</span><span class="o">::</span><span class="n">create_physic_element</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">btQuaternion</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">btQuaternion</span><span class="p">(</span><span class="n">btVector3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                             <span class="n">random_</span><span class="p">.</span><span class="n">real</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">90.f</span><span class="p">));</span>
        <span class="n">btVector3</span> <span class="n">translation</span> <span class="o">=</span> <span class="n">btVector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">btTransform</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">btTransform</span><span class="p">(</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">mass</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
        <span class="n">btScalar</span> <span class="nf">radio</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="n">btSphereShape</span><span class="o">*</span> <span class="n">sphere_shape</span> <span class="o">=</span>
              <span class="n">physics_</span><span class="o">-&gt;</span><span class="n">create_shape</span><span class="p">(</span><span class="n">radio</span><span class="p">);</span>

        <span class="n">ball_bodies</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">physics_</span><span class="o">-&gt;</span>
          <span class="n">create_rigid_body</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">ball_nodes</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">sphere_shape</span><span class="p">,</span> <span class="n">mass</span><span class="p">));</span>
        <span class="n">ball_bodies</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setRestitution</span><span class="p">(</span><span class="mf">0.8f</span><span class="p">);</span>
        <span class="n">ball_bodies</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setFriction</span><span class="p">(</span><span class="mf">1.5f</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>En el listado anterior se crea el cuerpo rígido y la forma de colisión de la esfera. Para construir el cuerpo rígido, se crea un <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtTransform.html">btTransform</a> que recibe un cuaternio y un vector. El cuaternio recibe un vector, mediante el cuál le indicamos en qué ejes sufrirá rotaciones nuestra esfera, y un float aleatorio entre 0 y 90, con el que indicamos los grados de rotación. Esto lo hacemos así para que cada bola que creamos rebote de una forma ligeramente distinta contra el suelo. El segundo parámetro de la transformación es el vector de traslación, que indica el lugar donde se creará la esfera. En este caso a 100 unidades sobre el eje Y.</p>
<p>Para crear la forma de colisión esférica, se hace uso de una factoría de btCollisionShape implementada en el gestor de físicas. Lo único que hay que hacer es pasarle el radio de la esfera, en metros, y se creará la forma de colisión.</p>
<p>Con estos parámetros se crea un cuerpo rígido haciendo uso del gestor de físicas. Una vez creado el cuerpo rígido, se configuran el <a class="reference external" href="http://es.wikipedia.org/wiki/Coeficiente_de_restituci%C3%B3n">coeficiente de restitución</a>, que indica una medida del grado de conservación de la energía cinética en un choque entre partículas clásicas, y el <a class="reference external" href="http://es.wikipedia.org/wiki/Coeficiente_de_rozamiento">coeficiente de fricción</a>, que indica la oposición al deslizamiento que ofrecen dos superficies en contacto.</p>
<p>Por último, falta integrar el cuerpo físico de Bullet con el cuerpo gráfico de Ogre.</p>
</div>
<div class="section" id="integrar-ogre3d-con-bullet">
<h3>Integrar Ogre3D con Bullet</h3>
<p>Primero de todo, hay que entender que los cuerpos gráficos de Ogre3D y
los cuerpos físicos de Bullet son entidades completamente distintas y
separadas. Si no se implementa algún mecanismos mediante el cuál
Bullet actualice la posición y rotación de dicho cuerpo gráfico, se creará una situación de incoherencia en la cuál la posición del cuerpo gráfico permanecerá estática, al contrario que la del cuerpo físico que se verá actualizada. Esto provocará que el vídeo asociado a nuestro juego no se actualice, ya que Ogre es el encargado de crear las imágenes, mientras que Bullet tiene la responsabilidad de modelar un comportamiento realista sobre los cuerpos.</p>
<p>Para solucionar este problema se crea la clase MotionState. Podemos ver su implementación en el siguiente listado:</p>
<pre class="code c++ literal-block">
<span class="k">class</span> <span class="nc">MyMotionState</span> <span class="o">:</span> <span class="k">public</span> <span class="n">btMotionState</span>
      <span class="p">{</span>
      <span class="nl">protected:</span>
          <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">mSceneNode</span><span class="p">;</span>
          <span class="n">btTransform</span> <span class="n">mInitialPosition</span><span class="p">;</span>

      <span class="nl">public:</span>
          <span class="n">MyMotionState</span><span class="p">(</span><span class="k">const</span> <span class="n">btTransform</span> <span class="o">&amp;</span><span class="n">initialPosition</span><span class="p">,</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">mSceneNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
              <span class="n">mInitialPosition</span> <span class="o">=</span> <span class="n">initialPosition</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="k">virtual</span> <span class="o">~</span><span class="n">MyMotionState</span><span class="p">()</span>
          <span class="p">{</span>
          <span class="p">}</span>

          <span class="kt">void</span> <span class="n">setNode</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">mSceneNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="k">virtual</span> <span class="kt">void</span> <span class="n">getWorldTransform</span><span class="p">(</span><span class="n">btTransform</span> <span class="o">&amp;</span><span class="n">worldTrans</span><span class="p">)</span> <span class="k">const</span>
          <span class="p">{</span>
              <span class="n">worldTrans</span> <span class="o">=</span> <span class="n">mInitialPosition</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setWorldTransform</span><span class="p">(</span><span class="k">const</span> <span class="n">btTransform</span> <span class="o">&amp;</span><span class="n">worldTrans</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="k">if</span><span class="p">(</span><span class="n">mSceneNode</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span>
                  <span class="k">return</span><span class="p">;</span> <span class="c1">// silently return before we set a node
</span>
              <span class="n">btQuaternion</span> <span class="n">rot</span> <span class="o">=</span> <span class="n">worldTrans</span><span class="p">.</span><span class="n">getRotation</span><span class="p">();</span>
              <span class="n">mSceneNode</span> <span class="o">-&gt;</span><span class="n">setOrientation</span><span class="p">(</span><span class="n">rot</span><span class="p">.</span><span class="n">w</span><span class="p">(),</span> <span class="n">rot</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">rot</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">rot</span><span class="p">.</span><span class="n">z</span><span class="p">());</span>
              <span class="n">btVector3</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">worldTrans</span><span class="p">.</span><span class="n">getOrigin</span><span class="p">();</span>
              <span class="n">mSceneNode</span> <span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">pos</span><span class="p">.</span><span class="n">z</span><span class="p">());</span>
          <span class="p">}</span>
      <span class="p">};</span>
</pre>
<p>En el constructor de la clase se le pasa un nodo de escena de Ogre y la transformación inicial de dicho nodo. Es en el constructor de la clase btRigidBody donde se le pasa dicho objeto MotionState, que en nuestro caso se crea dentro del método <em>Physics::create_rigid_body</em>.</p>
<p>Hecho esto, el método que se encarga de sincronizar la posición del nodo de ogre asociado a un cuerpo rígido es el método <em>setWorldTransform</em>. Este método se invoca de forma interna por parte Bullet cada vez que el cuerpo rígido ve modificado su estado en el transcurso normal de la simulación física del <em>Mundo</em>.</p>
<p>Por último, sólo queda invocar el método btDiscreteDynamicsWorld::stepSimulation en cada iteración del bucle principal de juego, indicándole el tiempo transcurrido entre la llamada anterior y la siguiente. Dicho método implementa el pipeline físico donde se ejecuta la simulación. En el siguiente listado de código podemos ver el bucle principal del ejemplo:</p>
<pre class="code c++ literal-block">
<span class="kt">void</span>
<span class="n">Game</span><span class="o">::</span><span class="n">game_loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">delta_time</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">exit_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delta_time</span> <span class="o">+=</span> <span class="n">timer_</span><span class="p">.</span><span class="n">get_delta_time</span><span class="p">();</span>
    <span class="n">input_</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">delta_time</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">input_</span><span class="o">-&gt;</span><span class="n">check_events</span><span class="p">();</span>
      <span class="n">physics_</span><span class="o">-&gt;</span><span class="n">step_simulation</span><span class="p">(</span><span class="n">delta_time</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
      <span class="n">scene_</span><span class="o">-&gt;</span><span class="n">render_one_frame</span><span class="p">();</span>
      <span class="n">delta_time</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>El método step_simulation  del gestor de físicas simplemente encapsula la misma llamada al objeto <em>btDiscreteDynamicsWorld</em>, que recibe como parámetros el delta time que hemos indicado y un entero que indica el número de subpasos que debe realizar dentro de la simulación física a la hora de interpolar la posición de los objetos físicos.</p>
</div>
</div>
<div class="section" id="aclaraciones-del-autor">
<h2>Aclaraciones del autor</h2>
<p>En este post he intentado llegar a un equilibrio entre el nivel de profundidad de la explicación de los aspectos relacionados con Bullet y la sencillez del código fuente que ejemplifica dichos conceptos. He intentado que el ejemplo sea lo mas sencillo posible pero con la funcionalidad mínima que permita ver una utilidad real por parte del motor de físicas. Aún así el nivel de complejidad del ejemplo no es todo lo bajo que yo hubiese querido en un principio, pero creo que lo que presento aquí es el ejemplo mínimo de cómo integrar rápidamente Ogre3D con Bullet, de modo que pueda verse reflejado una de las primeras etapas que yo tuve que pasar en el proceso de aprendizaje que he sufrido a lo largo del desarrollo de mi proyecto.</p>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html" class="u-url">Justificación y objetivos del proyecto</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html" rel="bookmark"><time class="published dt-published" datetime="2015-01-24T11:06:19+01:00" itemprop="datePublished" title="2015-01-24 11:06">2015-01-24 11:06</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="tinman.jpg" class="align-center" id="logo-tinman" src="posts/justificacion-objetivos/tinman.jpg">
<p>En esta entrada se explicará brevemente qué es el proyecto Tinman, se
justificarán las razones por las cuales se está realizando este
proyecto, y por último, se listarán los objetivos que se pretenden
cumplir con el desarrollo del mismo.</p>
<div class="section" id="que-es-tinman">
<h2>¿Qué es Tinman?</h2>
<p><em>Tinman</em> es el nombre corto de mi trabajo fin de Grado(TFG), que se titula: "Instrumentación de un videojuego 3D con fines docentes". El videojuego será un clon del famoso juego de carreras arcade "<a class="reference external" href="http://es.wikipedia.org/wiki/Super_Off_Road">Super Off Road</a>", y de aquí es de donde surge <em>Tinman</em> como nombre de mi proyecto, a modo de broma, dado que el juego original llevó el nombre de Ivan "Ironman" Stewart, un famoso piloto del estilo <em>Off-Road</em>.</p>
<p>Este proyecto nació con el espíritu de crear un videojuego que fuese útil como caso práctico sobre el que estudiar toda una serie de técnicas relacionadas con el desarrollo de videojuegos. Es obvio que se trata de un proyecto muy ambicioso y por ello se ha de acotar el alcance del mismo. Del título, lo que más puede llevar a confusión sea la última parte, con fines docentes. Debido a que desarrollar un <em>Serius Game</em> específicamente orientado a desarrolladores se desmarca del objeto de evaluación dentro de un TFG, e incluso en una tesis de máster, el esfuerzo en este proyecto se ha centrado en desarrollar un código lo más limpio posible, sobre el que poder ejemplificar el uso de técnicas avanzadas como patrones de diseño o como <a class="reference external" href="http://programmers.stackexchange.com/a/94567">idioms</a> en C++, por poner algunos ejemplos.</p>
<p>Para que lo anterior fuese posible se decidió licenciar el código del proyecto, así como todo el contenido generado, bajo una licencia libre. En nuestro caso, el proyecto se licencia bajo GPLv3.Se decidió usar una licencia libre porque si se pretendía enseñar a quien lo deseara cómo fue creado el proyecto, la forma mas sencilla pasaba por dar libertad para leer el código, modificarlo y distribuir tanto modificaciones del proyecto original como copias del mismo. Creo que la mejor forma de aprender a programar es programando, y a mí me resulta mas sencillo si tengo algo sobre lo que empezar.</p>
<p>Por otra parte, no abundan proyectos libres en el mundo de los videojuegos y los que existen, o bien no se ha dado al código fuente el mimo que merece, o los creadores son ingenieros con una larga trayectoria, por lo que el código, aunque mantenible, flexible y bien estructurado, se hace difícil de estudiar para quien está comenzando a aprender y más complicado si estos proyectos están escritos en C++. Este lenguaje se ha convertido en estándar para la industria del videojuego, por múltiples razones. No sólo ofrece tanto mecanismos de muy alto nivel, tambien permite trabajar a nivel de dirección de memoria, de registro,...con lo que ofrece al ingeniero una flexibilidad que no se encuentra en otros lenguajes. Además, al ser compilado, permite optimizaciones de bajo nivel que no ofrecen otros lenguajes basados en máquinas virtuales o interpretados.</p>
<p>Pero alguien podría estar preguntándose: ¿realmente un videojuego se justifica como trabajo fin de Grado?</p>
<p>Según la "<a class="reference external" href="http://webpub.esi.uclm.es/archivos/336/Normativa-TFGs">Normativa sobre la elaboración y defensa del Trabajo Fin
de Grado</a>"
de la Escuela Superior de Informática de Ciudad Real, su artículo 2º
<em>Naturaleza del Trabajo Fin de Grado</em>, estipula lo siguiente:</p>
<p>"El Trabajo Fin de Grado supone la realización por parte del estudiante, y de forma
individual, de un proyecto, memoria o estudio bajo la supervisión de
uno o más tutores/as, en el que se integren y desarrollen los
contenidos formativos recibidos, capacidades, competencias y
habilidades adquiridas durante el periodo de docencia del Grado en
Ingeniería Informática"</p>
<p>El apaertado anterior señala que el TFG consiste en desarrollar, de manera individual, un proyecto, memoria o estudio; es decir, que no es requerida implementación alguna. El proyecto Tinman requiere la aplicación de técnicas avanzadas de ingeniería del Software, sigue una metodología concreta de desarrollo (<em>desarrollo orientado por pruebas</em>), requiere la capacidad para resolver problemas complejos, hace uso de un software de control de versiones, que ayuda a realizar un seguimiento del progreso del proyecto, etc. Todo esto hace que se cumpla  lo previamente citado para considerar este proyecto como TFG.</p>
<p>Por otra parte, en todo proyecto debe contemplarse, de una forma u otra, el contexto económico. En ese sentido, el sector de los videojuegos está en pleno auge. Por aportar algunas cifras, la empresa NewZoo en su <a class="reference external" href="http://www.newzoo.com/insights/global-games-market-will-reach-102-9-billion-2017-2/">publicación</a> sobre la situación mundial del mercado del videojuego señalaba que si la progresión de crecimiento actual se mantiene, se espera que la cifra de facturación mundial ascienda desde los 81.400 millones de dólares actuales en 2014 hasta los 102.900 millones en 2017. No hace es necesario ser economista para darse cuenta que el volumen de facturación es impresionante y que por sí sólo justifica la creación de nuevos proyectos orientados a este sector.</p>
<img alt="mercado-videojuego.png" class="align-center" id="grafico-mercado" src="posts/justificacion-objetivos/mercado-videojuego.png">
<p>Para finalizar, se listarán los objetivos que se pretenden cumplir.</p>
</div>
<div class="section" id="objetivos">
<h2>Objetivos</h2>
<p>En primer lugar se pretende desarrollar de un videojuego, utilizando
gráficos en 3D. Aunque el videojuego en sí ya es un objetivo de envergadura, este proyecto pretende utilizarlo como base para dos objetivos adicionales:</p>
<ul class="simple">
<li>Diseño e implementación de mecanismos de instrumentación del juego que permitan
aplicar técnicas de testing automático y al mismo tiempo exponer los mecanismos internos con fines didácticos y de depuración.</li>
<li>Diseño e implementación de un modelo de red para una modalidad multijugador, que
aprovechará los citados mecanismos de instrumentación con los mismos fines.</li>
</ul>
<p>Otro objetivo no menos importante es crear un ejemplo completo de videojuego que pueda servir a futuros programadores a aprender las técnicas básicas y los fundamentos técnicos esenciales del desarrollo de un videojuego. Por ese motivo se hará énfasis en los siguientes aspectos:</p>
<ul class="simple">
<li>Claridad del código.</li>
<li>Uso de patrones de diseño.</li>
<li>Técnicas de introspección de objetos.</li>
<li>Acceso al código fuente y al propio proyecto. Por esta razón se
distribuirá bajo una licencia libre.</li>
</ul>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/introduccion-ogre3d/introduccion-a-ogre3d.html" class="u-url">Introducción a Ogre3D</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/introduccion-ogre3d/introduccion-a-ogre3d.html" rel="bookmark"><time class="published dt-published" datetime="2015-01-03T10:41:32+01:00" itemprop="datePublished" title="2015-01-03 10:41">2015-01-03 10:41</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="ogre-logo.png" class="align-center" src="posts/introduccion-ogre3d/ogre-logo.png">
<p>En esta primera entrada hablaremos brevemente de Ogre3D, y de porqué
se ha elegido como biblioteca de renderizado. Para ejemplificarlo, se
ha creado un pequeño programa usando Ogre en el que se renderiza su
mascota, Sinbad, al mismo tiempo que servirá como ejemplo para mostrar
la estructura típica de un programa que hace uso de esta biblioteca.</p>
<p>Este post es una adaptación del tutorial que realicé hace unos meses y que podeis encontrar aquí: <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/overview">https://bitbucket.org/IsaacLacoba/intro-ogre/overview</a></p>
<div class="section" id="que-es-ogre3d">
<h2>¿Qué es Ogre3D?</h2>
<p>Ogre3D(<a class="reference external" href="http://www.ogre3d.org/">Object-Oriented Graphic Engine</a>) es
un motor de renderizado de propósito general creado por Steve
Streeting(tambien conocido como Sinbad) distribuido bajo licencia
LGPL(<a class="reference external" href="https://bitbucket.org/sinbad/ogre">repositorio-ogre3d</a>). Fue
creado en 2001(<a class="reference external" href="http://www.gamasutra.com/view/news/105533/QA_Steve_Streeting_On_Open_Source_3D_Engine_OGRE_3D.php">entrevista-streeting</a>)
con el propósito de crear un componente de renderizado en tiempo real
sin hacer asunciones a nivel de aplicación. El objetivo era crear un
componente genérico que pudiese ser ampliado a través de
plugins. Desde un principio el proyecto se diseñó teniendo en cuenta
la mantenibilidad y la facilidad de ampliación.</p>
<p>Ogre3D no fue concebido como un motor de juegos. Se pretendía cubrir
el mayor espectro posible,de manera que no sólo sirviese a campos como
el de los videojuegos, sino tambien a los de simulación, realidad
aumentada, realidad virtual,...y en general, cualquier campo que
requiriese del uso de herramientas de renderizado en tiempo real.</p>
<p>Además, el hecho de que se distribuya bajo una licencia de código
libre contribuye muchísimo más a su éxito. Esto es así debido a que la
comunidad está muy involucrada con el proyecto, cosa que podemos
observar en el <a class="reference external" href="http://www.ogre3d.org/forums/">foro oficial</a> del
proyecto, donde se resuelven dudas de desarrollo, se discute el
roadmap, etc. En cuanto a las <a class="reference external" href="http://www.ogre3d.org/developers/submit-patch">politica de contribuciones</a>, los usuarios de la
comunidad pueden colaborar bien realizando pull-request al repositorio
oficial con sus parches o bien reportando
bugs al <a class="reference external" href="https://ogre3d.atlassian.net/browse/OGRE/?selectedTab=com.atlassian.jira.jira-projects-plugin:summary-panel">Jira del proyecto</a></p>
<p>Como hemos dicho antes, Ogre3D no es un motor de juego. Esto implica
que será el desarrollador quien tenga que encargarse de aspectos como
la gestión de eventos de entrada (teclado,ratón,...), físicas, networking,
interfaces, etc. En el caso del desarrollo de interfaces existen maneras de crearlas
con Ogre a través del uso de overlays; sin embargo, esta
aproximación no es lo suficientemente flexible como para crear interfaces
avanzadas. Las características principales de Ogre son:</p>
<ul class="simple">
<li>
<strong>Mutiplataforma</strong>: permite el desarrollo para sistemas Windows, GNU/Linux y Mac OS X.</li>
<li>
<strong>Diseño a alto nivel</strong>: Ogre3D encapsula llamadas a las librerías
gráficas DirectX y OpenGL. Además, hace uso de patrones de diseño:
<em>observer</em> para informar de eventos y cambios de estado,
<em>singleton</em> para evitar que exista mas de una instancia de
cualquier manager, <em>visitor</em> para realizar operaciones sobre
un objeto y evitar modificarlo (por ejemplo, en los nodos del grafo
de escena), <em>façade</em> para unificar el acceso a operaciones,
<em>factory</em> para creación de objetos concretos de interfaces
abstractas, etc.</li>
<li>
<strong>Grafo de escena</strong>: una de las características mas
importantes del grafo de escena de Ogre es que desacopla el propio
grafo del contenido de la escena, definiendo una arquitectura de
pugins. A diferencia de otros motores gráficos, como Irrlicht3D,
Blitz3D o Unreal, Ogre no se basa en la herencia como principio de
diseño del grafo, sino en la composición. Esto permite expandir el
diseño para soportar otros tipos de datos, como audio o elementos de
simulación física. En la siguiente figura podemos ver
el esquema general del grafo de escena de Ogre.</li>
</ul>
<div class="line-block">
<div class="line"><br></div>
</div>
<img alt="Jerarquía general del grafo de escena." class="align-center" id="my-picture" src="posts/introduccion-ogre3d/grafo-escena.png" style="width: 250px;">
<div class="line-block">
<div class="line"><br></div>
</div>
<ul class="simple">
<li>
<strong>Aceleración Hardware</strong>: OGRE permite definir el comportamiento
de la parte programable de la GPU mediante la definición de Shaders,
estando al mismo nivel de otros motores como Unreal o CryEngine.</li>
<li>
<strong>Materiales</strong>: se definen mediante un sistema de scripts y permiten
asignar o cambiar los materiales de los elementos de la escena sin
modificar el código fuente.</li>
<li>
<strong>Animación</strong>: tres tipos(skeletal, morph y pose). La animación y la
geometría asociada a los modelos se almacena en un único formato
binario optimizado. El proceso mas empleado se basa en la
exportación desde la aplicación de modelado y animación 3D a un
formato XML (Ogre XML) para convertirlo posteriormente al formato
binario optimizado mediante la herramienta de línea de órdenes
OgreXMLConverter.</li>
<li>
<strong>Composición y Postprocesado</strong>.</li>
<li>
<strong>Plugins</strong>.</li>
<li>
<strong>Gestión de Recursos</strong>: Ogre ofrece una serie de gestores de
recursos, organizados jerárquicamente por grupos.</li>
<li>
<strong>Características específicas avanzadas</strong>: El motor soporta gran
cantidad de características de visualización avanzadas, tales como
sombras dinámicas (basadas en diversas técnicas de cálculo),
sistemas de partículas, animación basada en esqueletos y de
vértices, y un largo etcétera. OGRE soporta además el uso de otras
bibliotecas auxiliares mediante plugins y conectores. Entre los más
utilizados cabe destacar las bibliotecas de simulación física ODE,
el soporte del metaformato Collada, o la reproducción de streaming
de vídeo con Theora.</li>
</ul>
</div>
<div class="section" id="veamos-algo-de-codigo">
<h2>Veamos algo de código</h2>
<p>El código fuente del ejemplo que vamos a estudiar lo podemos encontrar
en el siguiente repositorio:
<a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/overview">https://bitbucket.org/IsaacLacoba/intro-ogre/overview</a>.</p>
<p>Se ha creado un <em>¡Hola Mundo!</em> en Ogre3D con la intención de que fuese
lo más sencillo posible. Por esta razón, lo único que hace el ejemplo
es renderizar la mascota de Ogre, Sinbad. En la <a class="reference external" href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Tutorials">wiki del proyecto
Ogre</a>
hay una colección muy interesante de tutoriales que es recomendable
que el lector interesado estudie. En los listados de código, intentaremos mostrar únicamente el código que se añade en cada paso.</p>
<p>Pero antes de empezar, vamos a explicar como instalar Ogre3D en un
sistema operativo GNU/Linux. Consulta este <a class="reference external" href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Installing+the+Ogre+SDK">tutorial</a>
para saber como instalar Ogre3D en un sistema Microsoft Windows.</p>
</div>
<div class="section" id="instalacion">
<h2>Instalación</h2>
<p>En distribuciones de GNU/Linux, la instalación de Ogre3D pasa por
instalar los siguientes paquetes:</p>
<pre class="code bash literal-block">
<span class="c"># apt-get update apt-get install libogre-1.8.0 libogre-1.8-dev libogre-1.8.0-dbg freeglut3-dev libfreetype6 libfreetype6-dev libgl1-mesa-dev libgl1-mesa-glx</span>
</pre>
<p>Los tres primeros paquetes nos instalarán Ogre3D. Los siguientes
paquetes son dependencias indirectas de Ogre, los primeros de OpenGL y
los dos últimos instalarán el driver gráfico mesa.</p>
<div class="section" id="comprobando-la-instalacion">
<h3>Comprobando la instalación</h3>
<p>Aunque el proceso de instalación ha sido extremadamente complejo, no
está de más comprobar que todo haya ido bien. Para comprobar que Ogre
se ha instalado correctamente, crearemos una instancia del objeto Root
y compilaremos el código.</p>
<p>Primero, crearemos un fichero de texto llamado <em>main.cpp</em> con el siguiente código:</p>
<pre class="code c++ literal-block">
<span class="cp">#include &lt;OgreRoot.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">argv</span><span class="o">*</span><span class="p">[])</span> <span class="p">{</span>
   <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="p">(</span><span class="s">"config/plugins.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.log"</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Para poder compilarlo, crearemos un sencillo makefile con el siguiente
código. Crea un fichero llamado Makefile y escribe el siguiente
codigo:</p>
<pre class="code make literal-block">
<span class="nv">CXX</span><span class="o">=</span>g++
<span class="nv">CXXFLAGS</span> <span class="o">=</span> -std<span class="o">=</span>c++11 -ggdb <span class="k">$(</span>shell pkg-config --cflags OGRE OIS<span class="k">)</span>
<span class="nv">LDLIBS</span> <span class="o">=</span> <span class="k">$(</span>shell pkg-config --libs OGRE OIS<span class="k">)</span>

<span class="nf">main</span><span class="o">:</span> <span class="m">main.cpp</span>
</pre>
<p>Para compilarlo, abriremos un terminal en la carpeta donde
tengamos el codigo fuente y ejecutaremos:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>make
</pre>
<p>Esto compilara nuestro codigo. Si la compilación se realizó sin
problemas, procederemos a ejecutar el binario:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>./main
</pre>
<p>Si todo ha ido bien, la traza de inicialización de Ogre debiera
mostrarse por terminal y en el fichero "config/ogre.log". Hecho
esto, habremos comprobado que hemos instalado correctamente Ogre en
nuestro sistema. Ahora, continuemos construyendo nuestro ejemplo.</p>
</div>
</div>
<div class="section" id="sigamos-programando">
<h2>Sigamos programando</h2>
<p>El objeto que acabamos de crear es el objeto principal de Ogre, el
cual inicializa todos los componentes internos. Recibe hasta tres
parámetros, los cuales son las rutas a tres ficheros de configuración:
el primero indica la ruta de los plugins que se van a usar, el segundo
indica la configuración básica del sistema de renderizado(OpenGL o
DirectX, tamaño de la pantalla, frecuencia de refresco,...) y el
tercero es la ruta hacia el log donde Ogre volcará la traza, tanto de
inicialización como de destrucción de los recursos. Indicándole la
ruta hacia los ficheros, Ogre se encargará de crearlos si no
existiesen, únicamente en los dos últimos casos. En el caso del
fichero de plugins, hay que indicarle la ruta, ya que por defecto Ogre
no sabe donde buscarlos.</p>
<p>Una vez hecho esto, añadiremos el siguiente código que permite indicar
a Ogre la configuración básica del sistema de renderizado:</p>
<pre class="code c++ literal-block">
<span class="kt">void</span> <span class="nf">check_config</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">restoreConfig</span><span class="p">()</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">showConfigDialog</span><span class="p">()))</span> <span class="p">{</span>
      <span class="n">Ogre</span><span class="o">::</span><span class="n">LogManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">().</span><span class="n">logMessage</span><span class="p">(</span><span class="s">"Initialize::configure_ogre =&gt; "</span> <span class="o">+</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"ERROR: unable to configure Ogre"</span><span class="p">));</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="p">(</span><span class="s">"config/plugins.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.log"</span><span class="p">);</span>
  <span class="n">check_config</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>Al ejecutarlo por primera vez, debería aparecer una pantalla como la siguiente:</p>
<div class="line-block">
<div class="line"><br></div>
</div>
<img alt="configuracion-ogre.png" class="align-center" src="posts/introduccion-ogre3d/configuracion-ogre.png">
<div class="line-block">
<div class="line"><br></div>
</div>
<p>Este dialogo aparecerá cuando Ogre no encuentre el fichero
"config/ogre.cfg" (es decir, Ogre::Root::restoreConfig() devuelva
falso) e invoque al método Ogre::Root::showConfigDialog(). Debemos
asegurarnos de que la opción <em>Full Screen</em> este marcada como
<em>No</em>, de modo que podamos cerrar la aplicación de forma
correcta mas adelante. Hecho esto, podemos pulsar
<em>Accept</em>. Internamente, Ogre invocará a los métodos
Ogre::Root::SetRenderSystem, Ogre::RenderSystem::setConfigOption y
Ogre::Root::saveConfig que establecen el sistema de renderizado, la
configuración del mismo y guardan dicha configuración en un fichero de
texto.</p>
<p>El siguiente paso consiste en crear la ventana de nuestra aplicación,
donde se renderizará la escena. Existen dos formas de crear una
ventana: la primera es usando el constructor de la clase
Ogre::RenderWindow. La segunda, mas sencilla, es dejar que Ogre cree
una por defecto, basándose en la configuración obtenida del paso
anterior:</p>
<pre class="code c++ literal-block">
<span class="cp">#include &lt;OgreRenderWindow.h&gt;
</span><span class="p">(...)</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
   <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="p">(</span><span class="s">"config/plugins.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.log"</span><span class="p">);</span>
   <span class="n">check_config</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
   <span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="s">"Titulo"</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Añadimos el fichero de cabecera y creamos la ventana por defecto con el método
Ogre::Root:initialize. El primer parámetro indica a Ogre que queremos que cree un
Ogre::RenderWindow. Internamente se invocará al método
Ogre::Root::createRenderWindow. Es importante señalar que solo se
puede invocar este método después de haber obtenido la configuración
básica del sistema de renderizado.</p>
<p>Tras esto, procederemos a inicializar el gestor de escena:</p>
<pre class="code c++ literal-block">
<span class="p">(...)</span>

 <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

 <span class="p">(...)</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">scene_manager</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">createSceneManager</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">ST_GENERIC</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>La clase Ogre::SceneManager se encarga de organizar el
<em>culling</em> y el proceso de renderizado de la escena, junto con
la clase Ogre::RenderQueue. Del mismo modo que antes, hacemos uso de
la instancia del objeto Root para inicializar el gestor de escena. El
método Ogre::Root::createSceneManager acepta un tipo enumerado llamado
<a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/group___scene.html#gga7383602bd480d43b80c626969b9af914a0af8f844019e52fe112e9a946a919fcd">Ogre::SceneType</a>. Este tipo enumerado le indica a
Ogre qué tipo de <a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/class_ogre_1_1_scene_manager.html">SceneManger</a> tiene que
devolver (para mas información ver el <a class="reference external" href="http://www.ogre3d.org/tikiwiki/SceneManagersFAQ#Selecting_a_Scene_Manager">faq</a> ).</p>
<p>El gestor de escena nos permitirá crear nuestros nodos de escena y
las entidades donde se cargarán las mallas 3D. Para ello, necesitamos
tener algo que renderizar, de modo que vamos a descargarnos las
mallas.</p>
<div class="section" id="obteniendo-recursos-multimedia">
<h3>Obteniendo recursos multimedia</h3>
<p>En Internet podemos encontrar gran cantidad de contenido con licencia
creative commons que nos permitirá trabajar libremente con él, aunque
siempre hay que mirar cuidadosamente qué tipo de licencia tiene el
contenido multimedia que vamos a usar y respetarla en todo
momento. Para nuestro primer ejemplo, utilizaremos la mascota de
Ogre3D, Sinbad. Para ello, nos iremos al repositorio del
<a class="reference external" href="https://bitbucket.org/sinbad/ogre/src/046a0d6687d11a4413db3bbb8d49cc721b083a48/Samples/Media/packs/?at=default">proyecto</a>, a la carpeta <strong>Samples/Media/Packs</strong>,
donde podremos encontrar mallas listas para ser usadas. Nos
descargaremos el pack llamadado <em>Sinbad.zip</em>. A continuación,
crearemos una carpeta llamada <em>media</em> dentro del directorio de
nuestro proyecto y descompromimos el contenido del archivo .zip allí.</p>
<p>Hecho esto, los siguientes pasos que nos quedan son crear un nodo y
una entidad, adjuntar la entidad al nodo, así como crear un foco de
luz y una cámara.</p>
</div>
<div class="section" id="creando-nuestra-escena">
<h3>Creando nuestra escena</h3>
<p>El siguiente paso que deberemos realizar será crear un fichero que
permita saber a Ogre donde están los recursos multimedia. Dentro de la
carpeta <em>config</em> crearemos un fichero llamado "resources.cfg"
con el siguiente contenido:</p>
<pre class="code bash literal-block">
<span class="o">[</span>General<span class="o">]</span>
<span class="nv">FileSystem</span><span class="o">=</span>media
</pre>
<p>Esto simplemente le indica a Ogre que dentro de la carpeta media
encontrara los recursos multimedia. Pero primero hay que parsear el
fichero y cargar dichos recursos.</p>
</div>
<div class="section" id="cargando-los-recursos">
<h3>Cargando los recursos</h3>
<pre class="code c++ literal-block">
<span class="p">(...)</span>
<span class="cp">#include &lt;OgreResourceGroupManager.h&gt;
#include &lt;OgreConfigFile.h&gt;
</span>
<span class="kt">void</span> <span class="n">load_resources</span><span class="p">(</span><span class="n">string</span> <span class="n">resources_file</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">ConfigFile</span> <span class="n">cf</span><span class="p">;</span>
    <span class="n">cf</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">resources_file</span><span class="p">);</span>

    <span class="n">Ogre</span><span class="o">::</span><span class="n">ConfigFile</span><span class="o">::</span><span class="n">SectionIterator</span> <span class="n">seci</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">getSectionIterator</span><span class="p">();</span>

    <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">secName</span><span class="p">,</span> <span class="n">typeName</span><span class="p">,</span> <span class="n">archName</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">seci</span><span class="p">.</span><span class="n">hasMoreElements</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">secName</span> <span class="o">=</span> <span class="n">seci</span><span class="p">.</span><span class="n">peekNextKey</span><span class="p">();</span>
      <span class="n">Ogre</span><span class="o">::</span><span class="n">ConfigFile</span><span class="o">::</span><span class="n">SettingsMultiMap</span> <span class="o">*</span><span class="n">settings</span> <span class="o">=</span> <span class="n">seci</span><span class="p">.</span><span class="n">getNext</span><span class="p">();</span>
      <span class="n">Ogre</span><span class="o">::</span><span class="n">ConfigFile</span><span class="o">::</span><span class="n">SettingsMultiMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">settings</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">settings</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">typeName</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">archName</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="n">Ogre</span><span class="o">::</span><span class="n">ResourceGroupManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">()</span>
          <span class="p">.</span><span class="n">addResourceLocation</span><span class="p">(</span><span class="n">archName</span><span class="p">,</span> <span class="n">typeName</span><span class="p">,</span> <span class="n">secName</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Ogre</span><span class="o">::</span><span class="n">ResourceGroupManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">()</span>
      <span class="p">.</span><span class="n">initialiseAllResourceGroups</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">(...)</span>
  <span class="n">load_resources</span><span class="p">(</span><span class="s">"config/resources.cfg"</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>La función anterior abre el fichero y lo va
recorriendo buscando claves. Cada clave indica el nombre de
un directorio donde hay recursos multimedia. Estos directorios los
recorre en el bucle <em>for</em> buscando archivos de los que saca
el tipo, el nombre y los registra dentro del gestor de recursos
(Ogre::ResourcerGroupManager). Tras registrar todos los recursos que
haya encontrado, los inicializa.</p>
<p>Es importante que se invoque la función
<em>load_resources(string)</em> antes que la función
<em>check_config(Ogre::Root)</em> en el caso en el que usemos
Ogre::Overlay. Si se invoca en orden contrario, el programa compilará
correctamente, pero lanzará un error de segmento.</p>
<p>Este paso nos permitirá utilizar los recursos multimedia en nuestra
escena. Pero primero, deberemos crearemos la cámara y un foco de
luz.</p>
</div>
<div class="section" id="creando-nuestra-camara">
<h3>Creando nuestra cámara</h3>
<p>El objeto Ogre::Camera define la cámara de la escena. Este objeto es
imprescindible, pues sin él no podremos ver nada en nuestra
ventana. Para ello, añadiremos el siguiente código:</p>
<pre class="code c++ literal-block">
<span class="p">(...)</span>
<span class="cp">#include &lt;OgreCamera.h&gt;
</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">Camera</span><span class="o">*</span> <span class="n">create_camera</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Camera</span><span class="o">*</span> <span class="n">camera</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">getSceneManager</span><span class="p">(</span><span class="s">"SceneManager"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">createCamera</span><span class="p">(</span><span class="s">"Camera"</span><span class="p">);</span>

  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">160</span><span class="p">));</span>
  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">lookAt</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">setNearClipDistance</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">setFarClipDistance</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>


  <span class="n">Ogre</span><span class="o">::</span><span class="n">Viewport</span><span class="o">*</span> <span class="n">viewport</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">getAutoCreatedWindow</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addViewport</span><span class="p">(</span><span class="n">camera</span><span class="p">);</span>
  <span class="n">viewport</span><span class="o">-&gt;</span><span class="n">setBackgroundColour</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">ColourValue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">setAspectRatio</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Real</span><span class="p">(</span><span class="n">viewport</span><span class="o">-&gt;</span><span class="n">getActualWidth</span><span class="p">())</span> <span class="o">/</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">Real</span><span class="p">(</span><span class="n">viewport</span><span class="o">-&gt;</span><span class="n">getActualHeight</span><span class="p">()));</span>

  <span class="k">return</span> <span class="n">camera</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
 <span class="p">(...)</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Camera</span><span class="o">*</span> <span class="n">camera</span> <span class="o">=</span> <span class="n">create_camera</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>En esta ocasión, utilizamos el gestor de escena para crear una cámara
asociada a él. Ogre permite tener mas de un gestor de escena, e ir
cambiando entre ellos. Es por esta razón que hay que asociar la cámara
a un gestor de escena.</p>
<p>El objeto Ogre::Viewport es el equivalente al frustrum de la cámara;
es decir, indica la región que sera renderizada.</p>
<p>Una vez inicializada la cámara, es importante añadir una fuente de
luz, ya que por defecto el mundo se haya en tinieblas:</p>
<pre class="code c++ literal-block">
<span class="kt">void</span> <span class="nf">create_light</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">getSceneManager</span><span class="p">(</span><span class="s">"SceneManager"</span><span class="p">);</span>
  <span class="n">manager</span><span class="o">-&gt;</span><span class="n">setShadowTechnique</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SHADOWTYPE_STENCIL_ADDITIVE</span><span class="p">);</span>

  <span class="n">manager</span><span class="o">-&gt;</span><span class="n">setAmbientLight</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">ColourValue</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">));</span>

  <span class="n">Ogre</span><span class="o">::</span><span class="n">Light</span><span class="o">*</span> <span class="n">light</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">createLight</span><span class="p">(</span><span class="s">"MainLight"</span><span class="p">);</span>
  <span class="n">light</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
  <span class="n">light</span><span class="o">-&gt;</span><span class="n">setCastShadows</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">(...)</span>
  <span class="n">create_light</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>El método Ogre::SceneManager:setShadowTechnique(Ogre::ShadowTechnique)
asigna la técnica de generación de sombras que sera usada por este
gestor de escena. El tipo <a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/group___general.html#ga79dcd426d291c31072c1ad6f183715d6">Ogre::ShadowTechnique</a>
es un tipo enumerado que permite seleccionar una técnica de generación
de sombra.</p>
<p>Una vez que tenemos listo todo lo necesario para que pueda renderizarse
nuestra escena, procederemos a crearla añadiendo nodos de escena.</p>
</div>
<div class="section" id="anadiendo-nodos-a-nuestra-escena">
<h3>Añadiendo nodos a nuestra escena</h3>
<p>La forma en que Ogre desencapsula el grafo de escena y los objetos de
los mismos es mediante el objeto Ogre::SceneNode. Los objeto SceneNode
son los cuerpos gráficos genéricos sobre los que se realizarán las
operaciones de traslación, rotación, etc. A estos nodos hay que
adjuntarles un contenido, típicamente un objeto de tipo Ogre::Entity,
aunque se pueden adjuntar otros tipos de objetos. Veamos el código:</p>
<pre class="code c++ literal-block">
<span class="p">(...)</span>
<span class="cp">#include &lt;OgreEntity.h&gt;
#include &lt;OgreVector3.h&gt;
#include &lt;OgreMath.h&gt;
#include &lt;OgreMeshManager.h&gt;
</span>
<span class="p">(...)</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">get_node_by_name</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span><span class="p">,</span>
                                 <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">node_name</span><span class="o">=</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node_name</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">getRootSceneNode</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">getSceneNode</span><span class="p">(</span><span class="n">node_name</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Ogre</span><span class="o">::</span><span class="n">Entity</span><span class="o">*</span> <span class="n">create_entity_and_attach</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span><span class="p">,</span>
                                       <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span>
                                       <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">mesh</span><span class="p">,</span>
                                       <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">target_node</span><span class="o">=</span><span class="s">""</span><span class="p">,</span>
                                       <span class="kt">bool</span> <span class="n">cast_shadows</span><span class="o">=</span><span class="nb">true</span><span class="p">){</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_node_by_name</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">target_node</span><span class="p">);</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Entity</span><span class="o">*</span> <span class="n">entity</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">createEntity</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mesh</span><span class="p">);</span>
  <span class="n">entity</span><span class="o">-&gt;</span><span class="n">setCastShadows</span><span class="p">(</span><span class="n">cast_shadows</span><span class="p">);</span>

  <span class="n">node</span><span class="o">-&gt;</span><span class="n">attachObject</span><span class="p">(</span><span class="n">entity</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">entity</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">create_node</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span><span class="p">,</span>
                             <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span>
                             <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">parent</span><span class="o">=</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">parent_node</span> <span class="o">=</span> <span class="n">get_node_by_name</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">createChildSceneNode</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">create_node_and_entity</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span><span class="p">,</span>
                                        <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span>
                                        <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">mesh</span><span class="p">,</span>
                                        <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">parent</span><span class="o">=</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">create_node</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Entity</span><span class="o">*</span> <span class="n">entity</span> <span class="o">=</span> <span class="n">create_entity_and_attach</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="p">(...)</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">create_node_and_entity</span><span class="p">(</span><span class="n">scene_manager</span><span class="p">,</span> <span class="s">"SinbadNode"</span><span class="p">,</span> <span class="s">"Sinbad.mesh"</span><span class="p">);</span>

<span class="p">}</span>
</pre>
<p>Las funciones anteriores son funciones de alto nivel que encapsulan
una funcionalidad relacionada con el nombre de la función. Aunque
parezca mucho código, las sentencias mas importantes son:</p>
<pre class="code c++ literal-block">
<span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">createChildSceneNode</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</pre>
<p>La sentencia anterior genera un nodo hijo cuyo nodo raíz es el nodo
padre(<em>parent_node</em>). Esto es muy útil, ya que todas las
transformaciones que sufra el padre tambien las sufrirá el hijo. De
esta forma, podemos generar cuerpos compuestos y mover únicamente el
nodo padre, sabiendo que los nodos hijos se moverán de igual forma.</p>
<pre class="code c++ literal-block">
<span class="n">Ogre</span><span class="o">::</span><span class="n">Entity</span><span class="o">*</span> <span class="n">entity</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">createEntity</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mesh</span><span class="p">);</span>
</pre>
<p>Esta sentencia crea una instancia de un objeto tipo Ogre::Mesh. La
clase Ogre::Mesh almacena los datos necesarios para representar un
objeto tridimensional. Dicha malla la hemos cargado anteriormente en
el método <em>load_resources(std::string)</em>.</p>
<p>Por último, utilizamos dos funciones muy similares para obtener la
referencia a los SceneNode por su nombre:</p>
<pre class="code c++ literal-block">
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">::</span><span class="n">getRootSceneNode</span><span class="p">();</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">::</span><span class="n">getSceneNode</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">node_name</span><span class="p">);</span>
</pre>
<p>El primero devuelve la referencia al nodo raíz del grafo de escena y
el segundo al nodo que coincida con el nombre que se le pase por
argumentos.</p>
<p>Por último, debemos añadir la sentencia que renderiza la escena. Para
poder parar nuestra aplicación, en este documento se hará uso de la
clase Ogre::WindowEventListener, que cuenta con el método
WindowClosing y windowClosed. Para ello crearemos una clase y haremos
que herede de Ogre::WindowEventListener:</p>
<pre class="code c++ literal-block">
<span class="cp">#include &lt;OgreWindowEventUtilities.h&gt;
</span>
<span class="k">class</span> <span class="nc">WindowManager</span><span class="o">:</span> <span class="k">public</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">WindowEventListener</span><span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window_</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="kt">bool</span> <span class="n">exit</span><span class="p">;</span>

  <span class="n">WindowManager</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">){</span>
    <span class="n">window_</span> <span class="o">=</span> <span class="n">window</span><span class="p">;</span>
    <span class="n">exit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">WindowEventUtilities</span><span class="o">::</span><span class="n">addWindowEventListener</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">windowClosing</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">){</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">LogManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">().</span><span class="n">logMessage</span><span class="p">(</span><span class="s">"Closing window..."</span><span class="p">);</span>
    <span class="n">exit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">windowClosed</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">LogManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">().</span><span class="n">logMessage</span><span class="p">(</span><span class="s">"Window closed."</span><span class="p">);</span>
    <span class="n">exit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">(...)</span>
  <span class="n">WindowManager</span> <span class="n">windowManager</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">windowManager</span><span class="p">.</span><span class="n">exit</span><span class="p">){</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">renderOneFrame</span><span class="p">();</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">WindowEventUtilities</span><span class="o">::</span><span class="n">messagePump</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</pre>
<p>La clase Ogre::WindowEventListener se encarga de gestionar todos los
eventos relacionados con una ventana.</p>
<pre class="code c++ literal-block">
<span class="n">Ogre</span><span class="o">::</span><span class="n">WindowEventUtilities</span><span class="o">::</span><span class="n">addWindowEventListener</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</pre>
<p>La sentencia anterior se encarga de registrar la instancia de la clase
WindowManager como gestor de todos los eventos producidos en
<em>window</em>. Los métodos <em>windowClosed</em> y
<em>windowClosing</em> se ejecutan cuando se detecta un evento de
cierre de ventana; es decir, cuando se pulsa el botón de salir de la
esquina superior derecha de la ventana.</p>
<p>Se ha añadido el bucle principal a la función principal. El método
<em>renderOneFrame</em> indica a Ogre que debe actualizar los cuerpos
gráficos de la escena, muestras que la sentencia
<em>messagePump()</em> debe ser llamada una vez por frame, ya que
actualizará todas las ventanas que hayan sido registradas.</p>
<p>Hecho esto, habremos terminado. Sólo faltará compilar y ejecutar
nuestra aplicación. El resultado deberá ser parecido al de la
siguiente figura.</p>
<div class="line-block">
<div class="line"><br></div>
</div>
<blockquote>
<img alt="captura-ejecucion.png" class="align-center" src="posts/introduccion-ogre3d/captura-ejecucion.png">
</blockquote>
<div class="line-block">
<div class="line"><br></div>
</div>
<p>El código final debe parecerse al del fichero que podremos encontrar
en el <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/src/47e9565d0897607426587ef70798496f44f23ec8/src/main.cpp?at=master">repositorio de este tutorial</a></p>
<!-- LocalWords:  renderizada -->
</div>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/presentacion/presentacion.html" class="u-url">Presentación</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/presentacion/presentacion.html" rel="bookmark"><time class="published dt-published" datetime="2014-12-03T23:07:15+01:00" itemprop="datePublished" title="2014-12-03 23:07">2014-12-03 23:07</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="tinman.jpg" class="align-center" src="posts/presentacion/tinman.jpg">
<p>Este blog servirá como registro donde quedará plasmada la evolución de mi proyecto fin de grado.</p>
<p>En él se explicará el porqué de cada decisión que se ha tomado y se tomará durante el desarrollo
del mismo de una forma sencilla y concisa, desarrollando las distintas alternativas que se han tenido
en consideración en cada momento.</p>
<p>El código fuente del proyecto se puede encontrar en el siguiente link: <a class="reference external" href="https://bitbucket.org/arco_group/tfg.tinman">https://bitbucket.org/arco_group/tfg.tinman</a></p>
<div class="section" id="acerca-de-mi">
<h2>Acerca de mí:</h2>
<p>Me llamo Isaac y actualmente soy estudiante de Grado en Ingeniería Informática en la Escuela Superior de Informática de Ciudad Real.
Soy oootro apasionado mas de la tecnología, prueba de ello es que haya elegido usar Nikola como generador de mi blog y github pages
como lugar donde alojarlo, en lugar de las miles de soluciones existentes que te facilitan la vida. Porque pudiendo seguir la solución dificil, ¿para qué vas a seguir la fácil?</p>
<p>Esto último define bien mis preferencias. Desde siempre he sido un apasionado de los videojuegos. Y ya que el proyecto fin de grado es el broche final a lo que ha sido, hasta el momento, mi experiencia como estudiante universitario, decidí que sería perfecto finalizar con un proyecto que me definiese como ingeniero y como persona.</p>
</div>
</div>
    </div>
    </article>
</div>





        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});</script>
        <script src="assets/js/mathjax.js"></script>


        </div>
        <!--End of body content-->

        <footer>
            Contents © 2015         <a href="mailto:isaac.lacoba@gmail.com">Isaac Lacoba Molina</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
    </div>
</div>


            <script src="assets/js/all-nocdn.js"></script>
        <script src="assets/js/colorbox-i18n/jquery.colorbox-es.js"></script>
    
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul>
<li>
<a class="addthis_button_facebook"></a>
</li>
<li>
<a class="addthis_button_google_plusone_share"></a>
</li>
<li>
<a class="addthis_button_linkedin"></a>
</li>
<li>
<a class="addthis_button_twitter"></a>
</li>
</ul>
</div>
<script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script>jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    <!-- fancy dates -->
    <script>
    moment.locale("es");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script>
    <!-- end fancy dates -->
    
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-57580832-1', 'auto');ga('send', 'pageview');</script>

</body>
</html>
