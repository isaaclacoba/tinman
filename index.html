<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="es">
    <head>
    <meta charset="utf-8">
    <meta name="description" content="blog del proyecto Tinman">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Tinman | Tinman</title>

    
            <link href="assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
        <link href="assets/css/rst.css" rel="stylesheet" type="text/css">
        <link href="assets/css/code.css" rel="stylesheet" type="text/css">
        <link href="assets/css/colorbox.css" rel="stylesheet" type="text/css">
        <link href="assets/css/theme.css" rel="stylesheet" type="text/css">

    
            <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

      <link rel="canonical" href="http://isaaclacoba.github.io/tinman/index.html">




    
        <!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->

    




</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://isaaclacoba.github.io/tinman/">

                <span id="blog-title">Tinman</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li>
<a href="archive.html">Archivo</a>
                </li>
<li>
<a href="categories/index.html">Tags</a>
                </li>
<li>
<a href="rss.xml">feed RSS</a>

                
            </li>
</ul>

            <ul class="nav navbar-nav navbar-right">
                
                
                    
                
            </ul>
        </div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav>

<!-- End of Menubar -->

<div class="container" id="content">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<div class="postindex">
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/introduccion-bullet/introduccion-a-bullet-physics.html" class="u-url">Introducción a Bullet Physics</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/introduccion-bullet/introduccion-a-bullet-physics.html" rel="bookmark"><time class="published dt-published" datetime="2015-02-07T17:21:22+01:00" itemprop="datePublished" title="2015-02-07 17:21">2015-02-07 17:21</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="bullet_logo.png" class="align-center" src="posts/introduccion-bullet/bullet_logo.png">
<p>En esta nueva entrada se va a hablar de Bullet Physics, el motor de
físicas y detección de colisiones usado en el proyecto Tinman.Se va a
explicar brevemente la razón de la elección, se enumerarán las
características principales y, a continuación, se mostrará un breve
programa que ilustrará cómo integrar Bullet junto a <a class="reference external" href="http://isaaclacoba.github.io/tinman/posts/introduccion-ogre3d/introduccion-a-ogre3d.html">Ogre3D</a>,
la biblioteca de renderizado usada en este proyecto.</p>
<div class="section" id="que-es-bullet-physics">
<h2>¿Qué es Bullet Physics?</h2>
<p><a class="reference external" href="http://bulletphysics.org/wordpress/">Bullet Physics</a> es una
biblioteca de físicas y detección de colisiones. Se distribuye bajo
licencia ZLib y está desarrollada usando el lenguaje de programación
C++. El código fuente se encuentra disponible en el <a class="reference external" href="https://github.com/bulletphysics/bullet3">repositorio</a>
oficial del proyecto.</p>
<p>Bullet ha sido usado en multitud de películas, tales como Hancock o
Sherlock Holmes, así como videojuegos comerciales AAA, entre los que
destacan Grand Theft auto IV, Grand Theft auto V o Red Dead
Redemption. Como curiosidadw, la NASA está utilizando Bullet en un
<a class="reference external" href="http://bulletphysics.org/wordpress/?p=413">framework</a> de desarrollo
propio que tiene como propósito el cálculo de integridad tensional en
robots.</p>
<p>Entre las principales característica de Bullet podemos enumerar las siguientes:
- Soporte para una gran multitud de plataformas, tales
como PlayStation 3 y 4, Xbox 360 y One, Wii, Gnu/Linux, Windows,
MacOSX, iPhone, Android y <a class="reference external" href="http://bulletphysics.org/wordpress/?p=333">navegador web</a>.</p>
<ul class="simple">
<li>Elección entre precisión simple y doble en operaciones de punto flotante.</li>
<li>Detección de colisiones, tanto continua como discreta, incluyendo rayqueries y tests de colisión de formas convexas (<em>sweep test</em>). Permite realizar test de colisión con mallas convexas y cóncavas, además de con todo tipo de formas primitivas: cubos, esferas, planos, etcétera.</li>
<li>Dinámica de cuerpos rígidos, de vehículos, controladores de personajes, creación de <a class="reference external" href="http://es.wikipedia.org/wiki/F%C3%ADsica_ragdoll">ragdolls</a>, restricciones de tipo slider, bisagra y 6DOF (6 grados de libertad).</li>
<li>Dinámica de cuerpos fluidos que permite modelar ropa, tela y volumenes deformables, permitiendo interacción con cuerpos rígidos.</li>
<li>Existen plugins para dar soporte a Maya, Cinema 4D, está integrado con Blender, soporta ficheros COLLADA.</li>
</ul>
<div class="section" id="porque-es-necesario-utilizar-un-motor-de-fisicas">
<h3>¿Porqué es necesario utilizar un motor de físicas?</h3>
<p>Como se explicó en el <a class="reference external" href="http://isaaclacoba.github.io/tinman/posts/justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html">post anterior</a>,
uno de los objetivos de este proyecto es desarrollar un videojuego de
carreras 3D. Aunque se trata de un videojuego arcade, es necesario
modelar el comportamiento del coche de una forma mínimamente realista,
además de poder detectar y gestionar colisiones entre los coches y el
escenario.</p>
<p>Como puede verse en este <a class="reference external" href="http://www.asawicki.info/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html">artículo</a>
modelar el comportamiento de un coche presenta algunos problemas,
entre los que podemos destacar la distribución de la carga del coche
derivada de la aceleración y frenado de este o la gran cantidad de
propiedades físicas que intervienen en el movimiento del coche, como
la tracción, el par motor que se ejerce sobre las ruedas a través de
la transmisión, la inercia del coche, etcétera.</p>
<p>El uso de un motor de físicas nos permite juegos mas realistas, al
tiempo que abstrae al desarrollador de los detalles de bajo nivel, ofreciéndonos una implementación bien probada y eficiente.</p>
</div>
<div class="section" id="porque-elegir-bullet-antes-que-otras-bibliotecas-de-fisicas">
<h3>¿Porqué elegir Bullet antes que otras bibliotecas de físicas?</h3>
<p>Unas de los requisitos que existen en este proyecto es el uso de
tecnologías de código libre. A la hora de elegir un motor de físicas se descartaron por defecto los motores comerciales privativos, entre los que se pueden destacar Havok y PhysX. Entre los motores libres, se encontraron tres que podrían competir en calidad con los dos mencionados anteriormente: Bullet Physics, Open Dynamics Engine (mas conocido como ODE) y Newton Physics.</p>
<p>Se eligió Bullet debido a que de los tres motores anteriores, era el que mas facilidades daba a la hora de integrarlo con OGRE3D, ofrece dinámica de vehículos basada en rayqueries, es un proyecto mas moderno y mirando a largo plazo, el equipo de desarrollo de Bullet está actualmente implementando soporte sobre GPU sin necesidad de usar OpenCL ni Cuda. Bullet en su versión 2.8 ofrece soporte para las dos bibliotecas anteriores. Por último, el hecho de que existan proyectos comerciales de gran renombre, como es la saga <em>Grand Thef Auto</em>, terminaron de decantar la balanza a favor de esta biblioteca.</p>
<p>Aunque es cierto que los tres motores de físicas ofrecen
implementaciones de dinámica de cuerpos rígidos muy eficientes, una
búsqueda por las páginas oficiales de los proyectos revela que Bullet
es el más activo de los tres, disponiendo de una mayor cantidad de
documentación, teniendo como único punto negativo que la documentación
del <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/annotated.html">API</a>
no ofrece información acerca del uso de los métodos, mas allá del
nombre del mismo y una referencia a la línea en la que se encuentra la
definición de dicho método dentro del fichero fuente donde se haya
implementado.</p>
<p>Todas estas razones sumadas han hecho que se elija Bullet Physics como motor de físicas en este proyecto.</p>
</div>
</div>
<div class="section" id="arquitectura">
<h2>Arquitectura</h2>
<p>Bullet ha sido diseñado para ser modular y adaptable. La biblioteca da
la libertad al desarrollador de usar los componentes que necesite en
cada momento, ignorando los demás. Por ejemplo, se podría hacer uso de
la capa de detección de colisiones sin hacer uso de las capas
superiores. En la siguiente figura se puede observar un esquema
general de la organización por capas de la biblioteca.</p>
<img alt="organizacion-bullet.png" class="align-center" src="posts/introduccion-bullet/organizacion-bullet.png">
<div class="section" id="pipeline-de-simulacion-de-cuerpos-rigidos">
<h3>Pipeline de simulación de cuerpos rígidos</h3>
<p>El siguiente diagrama muestra las estructuras de datos mas
importantes, así como las etapas del encauzamiento dentro de
Bullet. Este encauzamiento se ejecuta de izquierda a derecha,
comenzando por aplicar la gravedad y terminando por integrar las
posiciones de los cuerpos.</p>
<img alt="pipeline-bullet.png" class="align-center" src="posts/introduccion-bullet/pipeline-bullet.png">
<p>El encauzamiento y las estructuras de datos están representados en
Bullet a través de la clase DynamicsWorld. Cuando se ejecuta el método
"stepSimulation de dicha clase, en realidad se está ejecutando el
encauzamiento anterior. La implementación por defecto se encuentra en
la clase btDiscreteDynamicsWorld.</p>
<p>Bullet permite trabajar al desarrollador con subfases del
encauzamiento, como la de detección de colisiones, la fase en la que
se aplican los efectos de las colisiones a los cuerpos
físicos(narrowphase) o la fase de resolución de restricciones.</p>
</div>
</div>
<div class="section" id="veamos-algo-de-codigo">
<h2>Veamos algo de código</h2>
<p>A continuación veremos un sencillo ejemplo en el que generaremos
esferas que rebotarán contra el suelo. Estas esferas se crearán
dinámicamente al pulsar la tecla 'B'.</p>
<p>Usaremos la biblioteca <a class="reference external" href="http://sourceforge.net/projects/wgois/">OIS</a>
para gestionar los eventos de teclado y Ogre3D como motor de
renderizado, que nos permitirá representar la escena. En este post se
dará por supuesto los conceptos básicos de Ogre3D. Para el lector que
no esté acostumbrado a trabajar con esta biblioteca, se aconseja
conocer al menos como inicializar el motor de renderizado, así como
gestionar nodos de escena y entidades. El código fuente se puede
encontrar en el repositorio de este <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-bullet">tutorial</a>.</p>
<div class="section" id="instalacion">
<h3>Instalación</h3>
<p>Las explicaciones dadas en este post están orientadas a un sistema operativo GNU/Linux. En el repositorio anterior podemos encontrar un fichero <a class="reference external" href="http://goo.gl/cKHhq9">DEPENDS</a> donde se listan los paquetes necesarios. Para instalar dichos paquetes tan sólo tenemos que ejecutar en un terminal los siguientes comandos. Para instalar Ogre, así como algunas dependencias de OpenGL y el driver gráfico mesa:</p>
<pre class="code bash literal-block">
sudo apt-get install libogre-1.8.0 libogre-1.8-dev freeglut3-dev libfreetype6 libfreetype6-dev libgl1-mesa-dev libgl1-mesa-glx
</pre>
<p>En el caso de OIS:</p>
<pre class="code bash literal-block">
sudo apt-get install libois-1.3.0 libois-dev
</pre>
<p>Y en el de Bullet:</p>
<pre class="code bash literal-block">
sudo apt-get install libbullet-dev libbullet2.82-dbg libbullet-extras-dev
</pre>
</div>
<div class="section" id="inicializacion">
<h3>Inicialización</h3>
<p>En este ejemplo, todo lo relativo a la inicialización de Bullet se
puede encontrar en los ficheros <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-bullet/src/ed9787be35bf81cb7cc61246e73729d96a42d374/src/managers/physics.cpp?at=master">physics.cpp</a> y
<a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-bullet/src/ed9787be35bf81cb7cc61246e73729d96a42d374/src/managers/physics.h?at=master">physics.h</a>. En él, se van a modelar las esferas usando cuerpos
rígidos. Los cuerpos rígidos tienen como principal característica que
no se deforman; es decir, la distancia entre cualquier par de vértices
que forman la malla nunca varía. Por el contrario, los cuerpos fluidos
son aquellos que permiten deformaciones. En este post se va a
intentar obviar toda la base matemática y se va a centrar la
explicación en los aspectos referentes a la biblioteca.</p>
<p>El elemento mas importante en Bullet es el <em>Mundo</em>. El <em>Mundo</em>
dentro de Bullet tiene varias responsabilidades, entre las que
podemos destacar:</p>
<ul class="simple">
<li>servir como estructura de datos donde almacenar los cuerpos
físicos que lo conforman.</li>
<li>aplicar una serie de restricciones a estos cuerpos, como la
fuerza de la gravedad, detectar y aplicar colisiones entre estos
cuerpos y actualizar su posición automáticamente cuando se aplique
cualquier tipo de fuerza sobre estos.</li>
</ul>
<p>El <em>Mundo</em> tiene diversas implementaciones dentro de la bibilioteca,
dependiendo de si utilizamos cuerpos rígidos o fluidos.  En este caso
se están usando cuerpos rígidos, de modo que la clase que se utilizará
será <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtDiscreteDynamicsWorld.html">btDiscreteDynamicsWorld</a>. En el siguiente listado de código se muestra el constructor del gestor de
físicas, que inicializa el objeto <em>btDiscreteDynamicsWorld</em>:</p>
<pre class="code c++ literal-block">
<span class="n">Physics</span><span class="o">::</span><span class="n">Physics</span><span class="p">(</span><span class="n">btVector3</span> <span class="n">gravity</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">gravity_</span> <span class="o">=</span> <span class="n">gravity</span><span class="p">;</span>

       <span class="n">broadphase_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btDbvtBroadphase</span><span class="p">();</span>

       <span class="n">solver_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btSequentialImpulseConstraintSolver</span><span class="p">();</span>
       <span class="n">collision_configuration_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btDefaultCollisionConfiguration</span><span class="p">();</span>
       <span class="n">dispatcher_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btCollisionDispatcher</span><span class="p">(</span><span class="n">collision_configuration_</span><span class="p">);</span>
       <span class="n">dynamics_world_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btDiscreteDynamicsWorld</span><span class="p">(</span><span class="n">dispatcher_</span><span class="p">,</span>
       <span class="n">broadphase_</span><span class="p">,</span> <span class="n">solver_</span><span class="p">,</span> <span class="n">collision_configuration_</span><span class="p">);</span>
       <span class="n">dynamics_world_</span><span class="o">-&gt;</span><span class="n">setGravity</span><span class="p">(</span><span class="n">gravity_</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Cada uno de los objetos que recibe el constructor de la clase
<em>btDiscreteDynamicsWorld</em> corresponde con una de las fases del
pipeline físico. El objeto broadphase corresponde a la fase de
detección de colisiones. Existen tres implementaciones de esta fase
que trabajan con diferentes estructuras de datos, lo que permite
acelerar la búsqueda de pares de colisión dependiendo de nuestras
necesidades:</p>
<ul class="simple">
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/structbtDbvtBroadphase.html">btDbvtBroadphase</a> usa una jerarquía de volumenes delimitantes
basada en un arbol AABB.</li>
<li>
<a class="reference external" href="http://www.bulletphysics.com/Bullet/BulletFull/classbtAxisSweep3.html">btAxisSweep3</a> y <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbt32BitAxisSweep3.html">bt32BitAxisSweep3</a> implementa  un algoritmo 3d de barrido y poda.</li>
<li>
<a class="reference external" href="http://bullet.googlecode.com/svn/trunk/Extras/CUDA/btCudaBroadphase.h">btCudaBroadphase</a> implementa un grid usando el hardware de la
GPU. Hace uso de Cuda, una tecnología para tarjetas gráficas Nvidia.</li>
</ul>
<p>La fase de detección de colisiones hace uso de una serie de estructuras de datos:</p>
<ul class="simple">
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCollisionObject.html">btCollisionObject</a>:
almacena formas de colisión y las transformaciones de éstas.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCollisionShape.html">btCollisionShape</a>:
describe la forma de colisión de un objeto de colisión, tal como una
caja, una esfera, una forma convexa(convex hull) o una malla de
triángulos. Una forma de colisión puede ser compartida entre
múltiples objetos de colisión.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtGhostObject.html">btGhostObject</a>: es un
caso especial de cuerpo de colisión útil para realizar consultas de
colisión de una forma rápida.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCollisionWorld.html">btCollisionWorld</a>:
almacena todos los objetos de colisión y proporciona una interfaz
que permite realizar peticiones de forma eficiente. Nuestro objeto
dynamics_world_ es de tipo btDiscreteDynamicsWorld, que es una
subclase de ésta.</li>
</ul>
<p>El objeto dispatcher_ pertenece a la clase <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCollisionDispatcher.html">btCollisionDispatcher</a>, la
cuál ofrece algoritmos que manejan pares de colisión ConvexConvex y
ConvexConcave. Esta clase corresponde a la etapa <em>Narrowphase</em>, usando
los pares de colisión generados en la fase <em>Broadphase</em>.</p>
<p>El objeto collisionConfiguration_, de la clase
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtDefaultCollisionConfiguration.html">btDefaultCollisionConfiguration</a>,
ofrece una configuración por defecto que define aspectos internos del
asignador de la pila de detección de colisiones, del asignador de la
pila de memoria de bullet, etcétera.</p>
<p>Por último, el objeto solver_, de la clase
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtSequentialImpulseConstraintSolver.html">btSequentialImpulseConstraintSolver</a>, ofrece una implementación del
método <a class="reference external" href="http://es.wikipedia.org/wiki/M%C3%A9todo_de_Gauss-Seidel">Gauss-Seidel</a> usado en analisis numérico para resolución de
sistemas de ecuaciones lineales. Esta clase está implementada usando paralelización SIMD(<em>Single Instruction, Multiple Data</em>), una técnica
utilizada para conseguir paralelismo a nivel de datos. Sin entrar en
detalles, consiste en aplicar una misma operación sobre un conjunto de
datos.</p>
<p>Tras inicializar la biblioteca, el siguiente paso consiste en crear
cuerpos y formas de colisión.</p>
</div>
<div class="section" id="creando-los-cuerpos-rigidos-de-las-esferas">
<h3>Creando los cuerpos rígidos de las esferas</h3>
<p>El siguiente listado de código muestra cómo se crean los cuerpos
rígidos en nuestro ejemplo:</p>
<pre class="code c++ literal-block">
<span class="n">btRigidBody</span><span class="o">*</span>
<span class="n">Physics</span><span class="o">::</span><span class="n">create_rigid_body</span><span class="p">(</span><span class="k">const</span> <span class="n">btTransform</span> <span class="o">&amp;</span><span class="n">worldTransform</span><span class="p">,</span>
                  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span>
                  <span class="n">btCollisionShape</span><span class="o">*</span> <span class="n">shape</span><span class="p">,</span>
                  <span class="n">btScalar</span> <span class="n">mass</span><span class="p">){</span>
  <span class="n">btVector3</span> <span class="n">inertia</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">mass</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="n">shape</span><span class="o">-&gt;</span><span class="n">calculateLocalInertia</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">inertia</span><span class="p">);</span>

  <span class="n">MotionState</span><span class="o">*</span> <span class="n">motionState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MotionState</span><span class="p">(</span><span class="n">worldTransform</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
  <span class="n">btRigidBody</span><span class="o">::</span><span class="n">btRigidBodyConstructionInfo</span>
    <span class="n">rigidBodyCI</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">motionState</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">inertia</span><span class="p">);</span>

  <span class="n">btRigidBody</span><span class="o">*</span> <span class="n">rigidBody</span> <span class="o">=</span> <span class="k">new</span> <span class="n">btRigidBody</span><span class="p">(</span><span class="n">rigidBodyCI</span><span class="p">);</span>
  <span class="n">dynamics_world_</span><span class="o">-&gt;</span><span class="n">addRigidBody</span><span class="p">(</span><span class="n">rigidBody</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">rigidBody</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>El constructor de la clase <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtRigidBody.html">btRigidBody</a> recibe un objeto <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/structbtRigidBody_1_1btRigidBodyConstructionInfo.html">btRigidBody::btRigidBodyConstructionInfo</a>. Este objeto sirve para inyectar al constructor de la clase información relativa al cuerpo rígido que se va a crear . Los argumentos que recibe son la masa del objeto, el estado del cuerpo(<em>Motion State</em> del cuál
hablaremos mas adelante), la forma física del cuerpo(<em>btCollisionShape</em>) y el vector de inercia.</p>
<p>En el método <em>Physics::create_rigid_body</em>, listado anteriormente, se
comprueba que la masa del cuerpo sea distinta de cero, ya que Bullet
interpreta que un cuerpo sin masa es equivalente a uno con masa
infinita; es decir, es inamovible. A partir de la forma del cuerpo y
de la masa de este, Bullet calcula la inercia del cuerpo físico que
estamos construyendo a través del método
<em>btCollisionShape::calculateLocalInertia</em>. Una vez creado el cuerpo, hay que
añadirlo al mundo a través del método btDiscreteDynamicsWorld::addRigidBody.</p>
<p>Bullet ofrece una gran variedad de formas primitivas de colisión, entre las que podemos listar:</p>
<ul class="simple">
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtBoxShape.html">btBoxShape</a>: caja definida por el tamaño de sus lados.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtSphereShape.html">btSphereShape</a>: esfera definida por su radio.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCapsuleShape.html">btCapsuleShape</a>: capsula alrededor del eje Y. Tambien existen btCapsuleShapeX/Z.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCylinderShape.html">btCylinderShape</a>.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtConeShape.html">btConeShape</a>: cono alrededor del eje Y. Tambien existen btConeShapeX/Z.</li>
<li>
<a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtMultiSphereShape.html">btMultiSphereShap</a>: cascarón convexo formado a partir de varias esferas que puede ser usado para crear una capsula( a partir de dos esferas) u otras formas convexas.</li>
</ul>
<p>Bullet tambien ofrece formas compuestas, pudiendo combinar múltiples
formas convexas en una única usando la clase <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtCompoundShape.html">btCompoundShape</a>. Cada una de las formas que dan lugar a la malla principal se llama <em>forma hija</em>. Cada <em>forma hija</em> tiene sus propias transformaciones locales, relativas a la forma compuesta. Existen algunas formas de colisión mas avanzadas que
permiten ajustarse a geometrías que no corresponden con formas
primitivas. Para mas información, se aconseja consultar el <a class="reference external" href="http://www.cs.uu.nl/docs/vakken/mgp/assignment/Bullet%20-%20User%20Manual.pdf">manual
oficial</a> de Bullet. En la figura siguiente se muestra que ayuda en la elección de la forma  de colisión adecuada dependiendo de la situación.</p>
<img alt="esquema-formas.png" class="align-center" src="posts/introduccion-bullet/esquema-formas.png">
<p>Ya se ha visto la lógica que permite crear cuerpos rígidos, de modo que sólo queda crear nuestras esferas:</p>
<pre class="code c++ literal-block">
<span class="kt">void</span>
<span class="n">Game</span><span class="o">::</span><span class="n">create_sphere</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">create_graphic_element</span><span class="p">();</span> <span class="c1">//crea un nodo y una entidad de Ogre
</span>  <span class="n">create_physic_element</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Game</span><span class="o">::</span><span class="n">create_physic_element</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">btQuaternion</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">btQuaternion</span><span class="p">(</span><span class="n">btVector3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                             <span class="n">random_</span><span class="p">.</span><span class="n">real</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">90.f</span><span class="p">));</span>
        <span class="n">btVector3</span> <span class="n">translation</span> <span class="o">=</span> <span class="n">btVector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">btTransform</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">btTransform</span><span class="p">(</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">mass</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
        <span class="n">btScalar</span> <span class="nf">radio</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="n">btSphereShape</span><span class="o">*</span> <span class="n">sphere_shape</span> <span class="o">=</span>
              <span class="n">physics_</span><span class="o">-&gt;</span><span class="n">create_shape</span><span class="p">(</span><span class="n">radio</span><span class="p">);</span>

        <span class="n">ball_bodies</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">physics_</span><span class="o">-&gt;</span>
          <span class="n">create_rigid_body</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">ball_nodes</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">sphere_shape</span><span class="p">,</span> <span class="n">mass</span><span class="p">));</span>
        <span class="n">ball_bodies</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setRestitution</span><span class="p">(</span><span class="mf">0.8f</span><span class="p">);</span>
        <span class="n">ball_bodies</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setFriction</span><span class="p">(</span><span class="mf">1.5f</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>En el listado anterior se crea el cuerpo rígido y la forma de colisión de la esfera. Para construir el cuerpo rígido, se crea un <a class="reference external" href="http://bulletphysics.org/Bullet/BulletFull/classbtTransform.html">btTransform</a> que recibe un cuaternio y un vector. El cuaternio recibe un vector, mediante el cuál le indicamos en qué ejes sufrirá rotaciones nuestra esfera, y un float aleatorio entre 0 y 90, con el que indicamos los grados de rotación. Esto lo hacemos así para que cada bola que creamos rebote de una forma ligeramente distinta contra el suelo. El segundo parámetro de la transformación es el vector de traslación, que indica el lugar donde se creará la esfera. En este caso a 100 unidades sobre el eje Y.</p>
<p>Para crear la forma de colisión esférica, se hace uso de una factoría de btCollisionShape implementada en el gestor de físicas. Lo único que hay que hacer es pasarle el radio de la esfera, en metros, y se creará la forma de colisión.</p>
<p>Con estos parámetros se crea un cuerpo rígido haciendo uso del gestor de físicas. Una vez creado el cuerpo rígido, se configuran el <a class="reference external" href="http://es.wikipedia.org/wiki/Coeficiente_de_restituci%C3%B3n">coeficiente de restitución</a>, que indica una medida del grado de conservación de la energía cinética en un choque entre partículas clásicas, y el <a class="reference external" href="http://es.wikipedia.org/wiki/Coeficiente_de_rozamiento">coeficiente de fricción</a>, que indica la oposición al deslizamiento que ofrecen dos superficies en contacto.</p>
<p>Por último, falta integrar el cuerpo físico de Bullet con el cuerpo gráfico de Ogre.</p>
</div>
<div class="section" id="integrar-ogre3d-con-bullet">
<h3>Integrar Ogre3D con Bullet</h3>
<p>Primero de todo, hay que entender que los cuerpos gráficos de Ogre3D y
los cuerpos físicos de Bullet son entidades completamente distintas y
separadas. Si no se implementa algún mecanismos mediante el cuál
Bullet actualice la posición y rotación de dicho cuerpo gráfico, se creará una situación de incoherencia en la cuál la posición del cuerpo gráfico permanecerá estática, al contrario que la del cuerpo físico que se verá actualizada. Esto provocará que el vídeo asociado a nuestro juego no se actualice, ya que Ogre es el encargado de crear las imágenes, mientras que Bullet tiene la responsabilidad de modelar un comportamiento realista sobre los cuerpos.</p>
<p>Para solucionar este problema se crea la clase MotionState. Podemos ver su implementación en el siguiente listado:</p>
<pre class="code c++ literal-block">
<span class="k">class</span> <span class="nc">MyMotionState</span> <span class="o">:</span> <span class="k">public</span> <span class="n">btMotionState</span>
      <span class="p">{</span>
      <span class="k">protected</span><span class="o">:</span>
          <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">mSceneNode</span><span class="p">;</span>
          <span class="n">btTransform</span> <span class="n">mInitialPosition</span><span class="p">;</span>

      <span class="k">public</span><span class="o">:</span>
          <span class="n">MyMotionState</span><span class="p">(</span><span class="k">const</span> <span class="n">btTransform</span> <span class="o">&amp;</span><span class="n">initialPosition</span><span class="p">,</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">mSceneNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
              <span class="n">mInitialPosition</span> <span class="o">=</span> <span class="n">initialPosition</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="k">virtual</span> <span class="o">~</span><span class="n">MyMotionState</span><span class="p">()</span>
          <span class="p">{</span>
          <span class="p">}</span>

          <span class="kt">void</span> <span class="n">setNode</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">mSceneNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="k">virtual</span> <span class="kt">void</span> <span class="n">getWorldTransform</span><span class="p">(</span><span class="n">btTransform</span> <span class="o">&amp;</span><span class="n">worldTrans</span><span class="p">)</span> <span class="k">const</span>
          <span class="p">{</span>
              <span class="n">worldTrans</span> <span class="o">=</span> <span class="n">mInitialPosition</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setWorldTransform</span><span class="p">(</span><span class="k">const</span> <span class="n">btTransform</span> <span class="o">&amp;</span><span class="n">worldTrans</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="k">if</span><span class="p">(</span><span class="n">mSceneNode</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
                  <span class="k">return</span><span class="p">;</span> <span class="c1">// silently return before we set a node
</span>
              <span class="n">btQuaternion</span> <span class="n">rot</span> <span class="o">=</span> <span class="n">worldTrans</span><span class="p">.</span><span class="n">getRotation</span><span class="p">();</span>
              <span class="n">mSceneNode</span> <span class="o">-&gt;</span><span class="n">setOrientation</span><span class="p">(</span><span class="n">rot</span><span class="p">.</span><span class="n">w</span><span class="p">(),</span> <span class="n">rot</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">rot</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">rot</span><span class="p">.</span><span class="n">z</span><span class="p">());</span>
              <span class="n">btVector3</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">worldTrans</span><span class="p">.</span><span class="n">getOrigin</span><span class="p">();</span>
              <span class="n">mSceneNode</span> <span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">(),</span> <span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">(),</span> <span class="n">pos</span><span class="p">.</span><span class="n">z</span><span class="p">());</span>
          <span class="p">}</span>
      <span class="p">};</span>
</pre>
<p>En el constructor de la clase se le pasa un nodo de escena de Ogre y la transformación inicial de dicho nodo. Es en el constructor de la clase btRigidBody donde se le pasa dicho objeto MotionState, que en nuestro caso se crea dentro del método <em>Physics::create_rigid_body</em>.</p>
<p>Hecho esto, el método que se encarga de sincronizar la posición del nodo de ogre asociado a un cuerpo rígido es el método <em>setWorldTransform</em>. Este método se invoca de forma interna por parte Bullet cada vez que el cuerpo rígido ve modificado su estado en el transcurso normal de la simulación física del <em>Mundo</em>.</p>
<p>Por último, sólo queda invocar el método btDiscreteDynamicsWorld::stepSimulation en cada iteración del bucle principal de juego, indicándole el tiempo transcurrido entre la llamada anterior y la siguiente. Dicho método implementa el pipeline físico donde se ejecuta la simulación. En el siguiente listado de código podemos ver el bucle principal del ejemplo:</p>
<pre class="code c++ literal-block">
<span class="kt">void</span>
<span class="n">Game</span><span class="o">::</span><span class="n">game_loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">delta_time</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">exit_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delta_time</span> <span class="o">+=</span> <span class="n">timer_</span><span class="p">.</span><span class="n">get_delta_time</span><span class="p">();</span>
    <span class="n">input_</span><span class="o">-&gt;</span><span class="n">capture</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">delta_time</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">input_</span><span class="o">-&gt;</span><span class="n">check_events</span><span class="p">();</span>
      <span class="n">physics_</span><span class="o">-&gt;</span><span class="n">step_simulation</span><span class="p">(</span><span class="n">delta_time</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
      <span class="n">scene_</span><span class="o">-&gt;</span><span class="n">render_one_frame</span><span class="p">();</span>
      <span class="n">delta_time</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>El método step_simulation  del gestor de físicas simplemente encapsula la misma llamada al objeto <em>btDiscreteDynamicsWorld</em>, que recibe como parámetros el delta time que hemos indicado y un entero que indica el número de subpasos que debe realizar dentro de la simulación física a la hora de interpolar la posición de los objetos físicos.</p>
</div>
</div>
<div class="section" id="aclaraciones-del-autor">
<h2>Aclaraciones del autor</h2>
<p>En este post he intentado llegar a un equilibrio entre el nivel de profundidad de la explicación de los aspectos relacionados con Bullet y la sencillez del código fuente que ejemplifica dichos conceptos. He intentado que el ejemplo sea lo mas sencillo posible pero con la funcionalidad mínima que permita ver una utilidad real por parte del motor de físicas. Aún así el nivel de complejidad del ejemplo no es todo lo bajo que yo hubiese querido en un principio, pero creo que lo que presento aquí es el ejemplo mínimo de cómo integrar rápidamente Ogre3D con Bullet, de modo que pueda verse reflejado una de las primeras etapas que yo tuve que pasar en el proceso de aprendizaje que he sufrido a lo largo del desarrollo de mi proyecto.</p>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html" class="u-url">Justificación y objetivos del proyecto</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html" rel="bookmark"><time class="published dt-published" datetime="2015-01-24T11:06:19+01:00" itemprop="datePublished" title="2015-01-24 11:06">2015-01-24 11:06</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="tinman.jpg" class="align-center" id="logo-tinman" src="posts/justificacion-objetivos/tinman.jpg">
<p>En esta entrada se explicará brevemente qué es el proyecto Tinman, se
justificarán las razones por las cuales se está realizando este
proyecto, y por último, se listarán los objetivos que se pretenden
cumplir con el desarrollo del mismo.</p>
<div class="section" id="que-es-tinman">
<h2>¿Qué es Tinman?</h2>
<p><em>Tinman</em> es el nombre corto de mi trabajo fin de Grado(TFG), que se titula: "Instrumentación de un videojuego 3D con fines docentes". El videojuego será un clon del famoso juego de carreras arcade "<a class="reference external" href="http://es.wikipedia.org/wiki/Super_Off_Road">Super Off Road</a>", y de aquí es de donde surge <em>Tinman</em> como nombre de mi proyecto, a modo de broma, dado que el juego original llevó el nombre de Ivan "Ironman" Stewart, un famoso piloto del estilo <em>Off-Road</em>.</p>
<!-- Mi motivación principal para hacer este proyecto es mi pasión por los videojuegos. La razón por la que comencé a estudiar Ingeniería Informática no era otra que la de convertirme en programador de videojuegos, y creo que esto queda reflejado en la pasión con la que este proyecto se está desarrollando. -->
<p>Este proyecto nació con el espíritu de crear un videojuego que fuese útil como caso práctico sobre el que estudiar toda una serie de técnicas relacionadas con el desarrollo de videojuegos. No hace falta decir que se trata de un proyecto muy ambicioso, y es por esto que hay que acotar el alcance del mismo. Del título lo que más puede llevar a confusión sea la última parte "con fines docentes". Debido a que desarrollar un <em>Serius Game</em> específicamente orientado a desarrolladores escapa por mucho a lo que se pretende evaluar dentro de un TFG, e incluso en una tesis de Master, el esfuerzo en este proyecto se ha centrado en desarrollar un código lo más limpio posible, sobre el que poder ejemplificar el uso de técnicas avanzadas como patrones de diseño o <a class="reference external" href="http://programmers.stackexchange.com/a/94567">idioms</a> en C++, por poner algunos ejemplos.</p>
<p>Para que lo anterior fuese posible se decidió licenciar el código del proyecto, así como todo el contenido generado, bajo una licencia libre. En nuestro caso, el proyecto se licencia bajo GPLv3. La principal razón por la que se decidió usar una licencia libre, fue que si se pretendía dar facilidades a quien desease aprender sobre cómo fue creado el proyecto, la forma mas sencilla pasaba por darle la libertad tanto de leer el código, cómo de modificarlo, así como de distribuir tanto sus propias modificaciones del proyecto original como copias de este. Creo que la mejor forma de aprender a programar es programando, y a mí me resulta mas sencillo si tengo algo sobre lo que empezar.</p>
<p>Por otra parte, no abundan los proyectos libres en el mundo de los videojuegos y los que existen o bien no se ha dado al código fuente el mimo que merece , o los creadores son ingenieros con una larga experiencia, con lo cuál el código, aunque mantenible, flexible y bien estructurado, se hace difícil de estudiar para quien está comenzando a aprender y mucho más si estos proyectos están escritos en C++. Este lenguaje se ha convertido en estándar para la industria del videojuego, por múltiples razones: no sólo ofrece tanto mecanismos de muy alto nivel, sino que permite trabajar a nivel de dirección de memoria, de registro,...con lo que ofrece una flexibilidad al ingeniero que no ofrecen otros lenguajes, además al ser compilado permite optimizaciones de bajo nivel que no ofrecen otros lenguajes basados en máquinas virtuales o interpretados.</p>
<p>Pero alguien podría estar preguntandose ¿realmente un videojuego se justifica como trabajo fin de Grado?</p>
<p>Según la "<a class="reference external" href="http://webpub.esi.uclm.es/archivos/336/Normativa-TFGs">normativa sobre la elaboración y defensa del trabajo fin de grado</a>" de la Escuela Superior de Informática de Ciudad Real, en sus artículos 2.1:</p>
<p>Art. 2.1- "El TFG supone la realización por parte del estudiante, y de
forma individual, de un proyecto, memoria o estudio bajo la
supervisión de uno o más tutores/as, en el que se integren y
desarrollen los contenidos formativos recibidos, capacidades,
competencias y habilidades adquiridas durante el periodo de docencia
del Grado en Ingeniería Informática"</p>
<p>El artículo anterior señala que el TFG consiste en desarrollar, de manera individual, un proyecto, memoria o estudio; es decir, que ni siquiera se requiere implementación alguna. El proyecto Tinman requiere la aplicación de técnicas avanzadas de ingeniería del Software, sigue una metodología concreta en el desarrollo(TDD), requiere la capacidad para resolver problemas complejos, hace uso de un software de control de versiones, que ayuda a realizar un seguimiento del progreso del proyecto, etc. Todo esto hace que se cumpla lo necesario para poder considerar este proyecto como un TFG.</p>
<p>Por otra parte, todo proyecto debe tener en mente, de una forma u otra, el contexto económico. En ese sentido, el sector de los videojuegos está en pleno auge. Por aportar algunas cifras, la empresa NewZoo en su <a class="reference external" href="http://www.newzoo.com/insights/global-games-market-will-reach-102-9-billion-2017-2/">publicación</a> sobre la situación mundial del mercado del videojuego señalaba que de seguir la progresión de crecimiento actual, se espera que la cifra de facturación mundial ascienda de los 81.400 millones actuales en 2014 hasta los 102.900 millones en 2017. No hace falta ser economista para darse cuenta que el volumen de facturación es impresionante y, por sí sólo, justifica la creación de nuevos proyectos orientados a este sector.</p>
<img alt="mercado-videojuego.png" class="align-center" id="grafico-mercado" src="posts/justificacion-objetivos/mercado-videojuego.png">
<p>Para finalizar, se listarán los objetivos que se pretenden cumplir.</p>
</div>
<div class="section" id="objetivos">
<h2>Objetivos</h2>
<p>En primer lugar se pretende desarrollar de un videojuego, utilizando
gráficos en 3D. Aunque el videojuego en sí ya es un objetivo de envergadura, este proyecto pretende utilizarlo como base para dos objetivos adicionales:</p>
<ul class="simple">
<li>Diseño e implementación de mecanismos de instrumentación del juego que permitan
aplicar técnicas de testing automático y al mismo tiempo exponer los mecanismos internos con fines didácticos y de depuración.</li>
<li>Diseño e implementación de un modelo de red para una modalidad multijugador, que
aprovechará los citados mecanismos de instrumentación con los mismos fines.</li>
</ul>
<p>Otro objetivo no menos importante es crear un ejemplo completo de videojuego que pueda servir a futuros programadores a aprender las técnicas básicas y los fundamentos técnicos esenciales del desarrollo de un videojuego. Por ese motivo se hará énfasis en los siguientes aspectos:</p>
<ul class="simple">
<li>Claridad del código.</li>
<li>Uso de patrones de diseño.</li>
<li>Técnicas de introspección de objetos.</li>
<li>Acceso al código fuente y al propio proyecto. Por esta razón se
distribuirá bajo una licencia libre.</li>
</ul>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/introduccion-ogre3d/introduccion-a-ogre3d.html" class="u-url">Introducción a Ogre3D</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/introduccion-ogre3d/introduccion-a-ogre3d.html" rel="bookmark"><time class="published dt-published" datetime="2015-01-03T10:41:32+01:00" itemprop="datePublished" title="2015-01-03 10:41">2015-01-03 10:41</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="ogre-logo.png" class="align-center" src="posts/introduccion-ogre3d/ogre-logo.png">
<p>En esta primera entrada hablaremos brevemente de Ogre3D, y de porqué
se ha elegido como biblioteca de renderizado. Para ejemplificarlo, se
ha creado un pequeño programa usando Ogre en el que se renderiza su
mascota, Sinbad, al mismo tiempo que servirá como ejemplo para mostrar
la estructura típica de un programa que hace uso de esta biblioteca.</p>
<p>Este post es una adaptación del tutorial que realicé hace unos meses y que podeis encontrar aquí: <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/overview">https://bitbucket.org/IsaacLacoba/intro-ogre/overview</a></p>
<div class="section" id="que-es-ogre3d">
<h2>¿Qué es Ogre3D?</h2>
<p>Ogre3D(<a class="reference external" href="http://www.ogre3d.org/">Object-Oriented Graphic Engine</a>) es
un motor de renderizado de propósito general creado por Steve
Streeting(tambien conocido como Sinbad) distribuido bajo licencia
LGPL(<a class="reference external" href="https://bitbucket.org/sinbad/ogre">repositorio-ogre3d</a>). Fue
creado en 2001(<a class="reference external" href="http://www.gamasutra.com/view/news/105533/QA_Steve_Streeting_On_Open_Source_3D_Engine_OGRE_3D.php">entrevista-streeting</a>)
con el propósito de crear un componente de renderizado en tiempo real
sin hacer asunciones a nivel de aplicación. El objetivo era crear un
componente genérico que pudiese ser ampliado a través de
plugins. Desde un principio el proyecto se diseñó teniendo en cuenta
la mantenibilidad y la facilidad de ampliación.</p>
<p>Ogre3D no fue concebido como un motor de juegos. Se pretendía cubrir
el mayor espectro posible,de manera que no sólo sirviese a campos como
el de los videojuegos, sino tambien a los de simulación, realidad
aumentada, realidad virtual,...y en general, cualquier campo que
requiriese del uso de herramientas de renderizado en tiempo real.</p>
<p>Además, el hecho de que se distribuya bajo una licencia de código
libre contribuye muchísimo más a su éxito. Esto es así debido a que la
comunidad está muy involucrada con el proyecto, cosa que podemos
observar en el <a class="reference external" href="http://www.ogre3d.org/forums/">foro oficial</a> del
proyecto, donde se resuelven dudas de desarrollo, se discute el
roadmap, etc. En cuanto a las <a class="reference external" href="http://www.ogre3d.org/developers/submit-patch">politica de contribuciones</a>, los usuarios de la
comunidad pueden colaborar bien realizando pull-request al repositorio
oficial con sus parches o bien reportando
bugs al <a class="reference external" href="https://ogre3d.atlassian.net/browse/OGRE/?selectedTab=com.atlassian.jira.jira-projects-plugin:summary-panel">Jira del proyecto</a></p>
<p>Como hemos dicho antes, Ogre3D no es un motor de juego. Esto implica
que será el desarrollador quien tenga que encargarse de aspectos como
la gestión de eventos de entrada (teclado,ratón,...), físicas, networking,
interfaces, etc. En el caso del desarrollo de interfaces existen maneras de crearlas
con Ogre a través del uso de overlays; sin embargo, esta
aproximación no es lo suficientemente flexible como para crear interfaces
avanzadas. Las características principales de Ogre son:</p>
<ul class="simple">
<li>
<strong>Mutiplataforma</strong>: permite el desarrollo para sistemas Windows, GNU/Linux y Mac OS X.</li>
<li>
<strong>Diseño a alto nivel</strong>: Ogre3D encapsula llamadas a las librerías
gráficas DirectX y OpenGL. Además, hace uso de patrones de diseño:
<em>observer</em> para informar de eventos y cambios de estado,
<em>singleton</em> para evitar que exista mas de una instancia de
cualquier manager, <em>visitor</em> para realizar operaciones sobre
un objeto y evitar modificarlo (por ejemplo, en los nodos del grafo
de escena), <em>façade</em> para unificar el acceso a operaciones,
<em>factory</em> para creación de objetos concretos de interfaces
abstractas, etc.</li>
<li>
<strong>Grafo de escena</strong>: una de las características mas
importantes del grafo de escena de Ogre es que desacopla el propio
grafo del contenido de la escena, definiendo una arquitectura de
pugins. A diferencia de otros motores gráficos, como Irrlicht3D,
Blitz3D o Unreal, Ogre no se basa en la herencia como principio de
diseño del grafo, sino en la composición. Esto permite expandir el
diseño para soportar otros tipos de datos, como audio o elementos de
simulación física. En la siguiente figura podemos ver
el esquema general del grafo de escena de Ogre.</li>
</ul>
<div class="line-block">
<div class="line"><br></div>
</div>
<img alt="Jerarquía general del grafo de escena." class="align-center" id="my-picture" src="posts/introduccion-ogre3d/grafo-escena.png" style="width: 250px;">
<div class="line-block">
<div class="line"><br></div>
</div>
<ul class="simple">
<li>
<strong>Aceleración Hardware</strong>: OGRE permite definir el comportamiento
de la parte programable de la GPU mediante la definición de Shaders,
estando al mismo nivel de otros motores como Unreal o CryEngine.</li>
<li>
<strong>Materiales</strong>: se definen mediante un sistema de scripts y permiten
asignar o cambiar los materiales de los elementos de la escena sin
modificar el código fuente.</li>
<li>
<strong>Animación</strong>: tres tipos(skeletal, morph y pose). La animación y la
geometría asociada a los modelos se almacena en un único formato
binario optimizado. El proceso mas empleado se basa en la
exportación desde la aplicación de modelado y animación 3D a un
formato XML (Ogre XML) para convertirlo posteriormente al formato
binario optimizado mediante la herramienta de línea de órdenes
OgreXMLConverter.</li>
<li>
<strong>Composición y Postprocesado</strong>.</li>
<li>
<strong>Plugins</strong>.</li>
<li>
<strong>Gestión de Recursos</strong>: Ogre ofrece una serie de gestores de
recursos, organizados jerárquicamente por grupos.</li>
<li>
<strong>Características específicas avanzadas</strong>: El motor soporta gran
cantidad de características de visualización avanzadas, tales como
sombras dinámicas (basadas en diversas técnicas de cálculo),
sistemas de partículas, animación basada en esqueletos y de
vértices, y un largo etcétera. OGRE soporta además el uso de otras
bibliotecas auxiliares mediante plugins y conectores. Entre los más
utilizados cabe destacar las bibliotecas de simulación física ODE,
el soporte del metaformato Collada, o la reproducción de streaming
de vídeo con Theora.</li>
</ul>
</div>
<div class="section" id="veamos-algo-de-codigo">
<h2>Veamos algo de código</h2>
<p>El código fuente del ejemplo que vamos a estudiar lo podemos encontrar
en el siguiente repositorio:
<a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/overview">https://bitbucket.org/IsaacLacoba/intro-ogre/overview</a>.</p>
<p>Se ha creado un <em>¡Hola Mundo!</em> en Ogre3D con la intención de que fuese
lo más sencillo posible. Por esta razón, lo único que hace el ejemplo
es renderizar la mascota de Ogre, Sinbad. En la <a class="reference external" href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Tutorials">wiki del proyecto
Ogre</a>
hay una colección muy interesante de tutoriales que es recomendable
que el lector interesado estudie. En los listados de código, intentaremos mostrar únicamente el código que se añade en cada paso.</p>
<p>Pero antes de empezar, vamos a explicar como instalar Ogre3D en un
sistema operativo GNU/Linux. Consulta este <a class="reference external" href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Installing+the+Ogre+SDK">tutorial</a>
para saber como instalar Ogre3D en un sistema Microsoft Windows.</p>
</div>
<div class="section" id="instalacion">
<h2>Instalación</h2>
<p>En distribuciones de GNU/Linux, la instalación de Ogre3D pasa por
instalar los siguientes paquetes:</p>
<pre class="code bash literal-block">
<span class="c"># apt-get update apt-get install libogre-1.8.0 libogre-1.8-dev libogre-1.8.0-dbg freeglut3-dev libfreetype6 libfreetype6-dev libgl1-mesa-dev libgl1-mesa-glx</span>
</pre>
<p>Los tres primeros paquetes nos instalarán Ogre3D. Los siguientes
paquetes son dependencias indirectas de Ogre, los primeros de OpenGL y
los dos últimos instalarán el driver gráfico mesa.</p>
<div class="section" id="comprobando-la-instalacion">
<h3>Comprobando la instalación</h3>
<p>Aunque el proceso de instalación ha sido extremadamente complejo, no
está de más comprobar que todo haya ido bien. Para comprobar que Ogre
se ha instalado correctamente, crearemos una instancia del objeto Root
y compilaremos el código.</p>
<p>Primero, crearemos un fichero de texto llamado <em>main.cpp</em> con el siguiente código:</p>
<pre class="code C++ literal-block">
<span class="cp">#include &lt;OgreRoot.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">argv</span><span class="o">*</span><span class="p">[])</span> <span class="p">{</span>
   <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="p">(</span><span class="s">"config/plugins.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.log"</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Para poder compilarlo, crearemos un sencillo makefile con el siguiente
código. Crea un fichero llamado Makefile y escribe el siguiente
codigo:</p>
<pre class="code make literal-block">
<span class="nv">CXX</span><span class="o">=</span>g++
<span class="nv">CXXFLAGS</span> <span class="o">=</span> -std<span class="o">=</span>c++11 -ggdb <span class="k">$(</span>shell pkg-config --cflags OGRE OIS<span class="k">)</span>
<span class="nv">LDLIBS</span> <span class="o">=</span> <span class="k">$(</span>shell pkg-config --libs OGRE OIS<span class="k">)</span>

<span class="nf">main</span><span class="o">:</span> <span class="n">main</span>.<span class="n">cpp</span>
</pre>
<p>Para compilarlo, abriremos un terminal en la carpeta donde
tengamos el codigo fuente y ejecutaremos:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>make
</pre>
<p>Esto compilara nuestro codigo. Si la compilación se realizó sin
problemas, procederemos a ejecutar el binario:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>./main
</pre>
<p>Si todo ha ido bien, la traza de inicialización de Ogre debiera
mostrarse por terminal y en el fichero "config/ogre.log". Hecho
esto, habremos comprobado que hemos instalado correctamente Ogre en
nuestro sistema. Ahora, continuemos construyendo nuestro ejemplo.</p>
</div>
</div>
<div class="section" id="sigamos-programando">
<h2>Sigamos programando</h2>
<p>El objeto que acabamos de crear es el objeto principal de Ogre, el
cual inicializa todos los componentes internos. Recibe hasta tres
parámetros, los cuales son las rutas a tres ficheros de configuración:
el primero indica la ruta de los plugins que se van a usar, el segundo
indica la configuración básica del sistema de renderizado(OpenGL o
DirectX, tamaño de la pantalla, frecuencia de refresco,...) y el
tercero es la ruta hacia el log donde Ogre volcará la traza, tanto de
inicialización como de destrucción de los recursos. Indicándole la
ruta hacia los ficheros, Ogre se encargará de crearlos si no
existiesen, únicamente en los dos últimos casos. En el caso del
fichero de plugins, hay que indicarle la ruta, ya que por defecto Ogre
no sabe donde buscarlos.</p>
<p>Una vez hecho esto, añadiremos el siguiente código que permite indicar
a Ogre la configuración básica del sistema de renderizado:</p>
<pre class="code C++ literal-block">
<span class="kt">void</span> <span class="nf">check_config</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">restoreConfig</span><span class="p">()</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">showConfigDialog</span><span class="p">()))</span> <span class="p">{</span>
      <span class="n">Ogre</span><span class="o">::</span><span class="n">LogManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">().</span><span class="n">logMessage</span><span class="p">(</span><span class="s">"Initialize::configure_ogre =&gt; "</span> <span class="o">+</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"ERROR: unable to configure Ogre"</span><span class="p">));</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="p">(</span><span class="s">"config/plugins.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.log"</span><span class="p">);</span>
  <span class="n">check_config</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>Al ejecutarlo por primera vez, debería aparecer una pantalla como la siguiente:</p>
<div class="line-block">
<div class="line"><br></div>
</div>
<img alt="configuracion-ogre.png" class="align-center" src="posts/introduccion-ogre3d/configuracion-ogre.png">
<div class="line-block">
<div class="line"><br></div>
</div>
<p>Este dialogo aparecerá cuando Ogre no encuentre el fichero
"config/ogre.cfg" (es decir, Ogre::Root::restoreConfig() devuelva
falso) e invoque al método Ogre::Root::showConfigDialog(). Debemos
asegurarnos de que la opción <em>Full Screen</em> este marcada como
<em>No</em>, de modo que podamos cerrar la aplicación de forma
correcta mas adelante. Hecho esto, podemos pulsar
<em>Accept</em>. Internamente, Ogre invocará a los métodos
Ogre::Root::SetRenderSystem, Ogre::RenderSystem::setConfigOption y
Ogre::Root::saveConfig que establecen el sistema de renderizado, la
configuración del mismo y guardan dicha configuración en un fichero de
texto.</p>
<p>El siguiente paso consiste en crear la ventana de nuestra aplicación,
donde se renderizará la escena. Existen dos formas de crear una
ventana: la primera es usando el constructor de la clase
Ogre::RenderWindow. La segunda, mas sencilla, es dejar que Ogre cree
una por defecto, basándose en la configuración obtenida del paso
anterior:</p>
<pre class="code C++ literal-block">
<span class="cp">#include &lt;OgreRenderWindow.h&gt;
</span><span class="p">(...)</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
   <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="p">(</span><span class="s">"config/plugins.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.cfg"</span><span class="p">,</span> <span class="s">"config/ogre.log"</span><span class="p">);</span>
   <span class="n">check_config</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
   <span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="s">"Titulo"</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Añadimos el fichero de cabecera y creamos la ventana por defecto con el método
Ogre::Root:initialize. El primer parámetro indica a Ogre que queremos que cree un
Ogre::RenderWindow. Internamente se invocará al método
Ogre::Root::createRenderWindow. Es importante señalar que solo se
puede invocar este método después de haber obtenido la configuración
básica del sistema de renderizado.</p>
<p>Tras esto, procederemos a inicializar el gestor de escena:</p>
<pre class="code C++ literal-block">
<span class="p">(...)</span>

 <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

 <span class="p">(...)</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">scene_manager</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">createSceneManager</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">ST_GENERIC</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>La clase Ogre::SceneManager se encarga de organizar el
<em>culling</em> y el proceso de renderizado de la escena, junto con
la clase Ogre::RenderQueue. Del mismo modo que antes, hacemos uso de
la instancia del objeto Root para inicializar el gestor de escena. El
método Ogre::Root::createSceneManager acepta un tipo enumerado llamado
<a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/group___scene.html#gga7383602bd480d43b80c626969b9af914a0af8f844019e52fe112e9a946a919fcd">Ogre::SceneType</a>. Este tipo enumerado le indica a
Ogre qué tipo de <a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/class_ogre_1_1_scene_manager.html">SceneManger</a> tiene que
devolver (para mas información ver el <a class="reference external" href="http://www.ogre3d.org/tikiwiki/SceneManagersFAQ#Selecting_a_Scene_Manager">faq</a> ).</p>
<p>El gestor de escena nos permitirá crear nuestros nodos de escena y
las entidades donde se cargarán las mallas 3D. Para ello, necesitamos
tener algo que renderizar, de modo que vamos a descargarnos las
mallas.</p>
<div class="section" id="obteniendo-recursos-multimedia">
<h3>Obteniendo recursos multimedia</h3>
<p>En Internet podemos encontrar gran cantidad de contenido con licencia
creative commons que nos permitirá trabajar libremente con él, aunque
siempre hay que mirar cuidadosamente qué tipo de licencia tiene el
contenido multimedia que vamos a usar y respetarla en todo
momento. Para nuestro primer ejemplo, utilizaremos la mascota de
Ogre3D, Sinbad. Para ello, nos iremos al repositorio del
<a class="reference external" href="https://bitbucket.org/sinbad/ogre/src/046a0d6687d11a4413db3bbb8d49cc721b083a48/Samples/Media/packs/?at=default">proyecto</a>, a la carpeta <strong>Samples/Media/Packs</strong>,
donde podremos encontrar mallas listas para ser usadas. Nos
descargaremos el pack llamadado <em>Sinbad.zip</em>. A continuación,
crearemos una carpeta llamada <em>media</em> dentro del directorio de
nuestro proyecto y descompromimos el contenido del archivo .zip allí.</p>
<p>Hecho esto, los siguientes pasos que nos quedan son crear un nodo y
una entidad, adjuntar la entidad al nodo, así como crear un foco de
luz y una cámara.</p>
</div>
<div class="section" id="creando-nuestra-escena">
<h3>Creando nuestra escena</h3>
<p>El siguiente paso que deberemos realizar será crear un fichero que
permita saber a Ogre donde están los recursos multimedia. Dentro de la
carpeta <em>config</em> crearemos un fichero llamado "resources.cfg"
con el siguiente contenido:</p>
<pre class="code bash literal-block">
<span class="o">[</span>General<span class="o">]</span>
<span class="nv">FileSystem</span><span class="o">=</span>media
</pre>
<p>Esto simplemente le indica a Ogre que dentro de la carpeta media
encontrara los recursos multimedia. Pero primero hay que parsear el
fichero y cargar dichos recursos.</p>
</div>
<div class="section" id="cargando-los-recursos">
<h3>Cargando los recursos</h3>
<pre class="code C++ literal-block">
<span class="p">(...)</span>
<span class="cp">#include &lt;OgreResourceGroupManager.h&gt;
#include &lt;OgreConfigFile.h&gt;
</span>
<span class="kt">void</span> <span class="n">load_resources</span><span class="p">(</span><span class="n">string</span> <span class="n">resources_file</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">ConfigFile</span> <span class="n">cf</span><span class="p">;</span>
    <span class="n">cf</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">resources_file</span><span class="p">);</span>

    <span class="n">Ogre</span><span class="o">::</span><span class="n">ConfigFile</span><span class="o">::</span><span class="n">SectionIterator</span> <span class="n">seci</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">getSectionIterator</span><span class="p">();</span>

    <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">secName</span><span class="p">,</span> <span class="n">typeName</span><span class="p">,</span> <span class="n">archName</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">seci</span><span class="p">.</span><span class="n">hasMoreElements</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">secName</span> <span class="o">=</span> <span class="n">seci</span><span class="p">.</span><span class="n">peekNextKey</span><span class="p">();</span>
      <span class="n">Ogre</span><span class="o">::</span><span class="n">ConfigFile</span><span class="o">::</span><span class="n">SettingsMultiMap</span> <span class="o">*</span><span class="n">settings</span> <span class="o">=</span> <span class="n">seci</span><span class="p">.</span><span class="n">getNext</span><span class="p">();</span>
      <span class="n">Ogre</span><span class="o">::</span><span class="n">ConfigFile</span><span class="o">::</span><span class="n">SettingsMultiMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">settings</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">settings</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">typeName</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">archName</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="n">Ogre</span><span class="o">::</span><span class="n">ResourceGroupManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">()</span>
          <span class="p">.</span><span class="n">addResourceLocation</span><span class="p">(</span><span class="n">archName</span><span class="p">,</span> <span class="n">typeName</span><span class="p">,</span> <span class="n">secName</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Ogre</span><span class="o">::</span><span class="n">ResourceGroupManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">()</span>
      <span class="p">.</span><span class="n">initialiseAllResourceGroups</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">(...)</span>
  <span class="n">load_resources</span><span class="p">(</span><span class="s">"config/resources.cfg"</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>La función anterior abre el fichero y lo va
recorriendo buscando claves. Cada clave indica el nombre de
un directorio donde hay recursos multimedia. Estos directorios los
recorre en el bucle <em>for</em> buscando archivos de los que saca
el tipo, el nombre y los registra dentro del gestor de recursos
(Ogre::ResourcerGroupManager). Tras registrar todos los recursos que
haya encontrado, los inicializa.</p>
<p>Es importante que se invoque la función
<em>load_resources(string)</em> antes que la función
<em>check_config(Ogre::Root)</em> en el caso en el que usemos
Ogre::Overlay. Si se invoca en orden contrario, el programa compilará
correctamente, pero lanzará un error de segmento.</p>
<p>Este paso nos permitirá utilizar los recursos multimedia en nuestra
escena. Pero primero, deberemos crearemos la cámara y un foco de
luz.</p>
</div>
<div class="section" id="creando-nuestra-camara">
<h3>Creando nuestra cámara</h3>
<p>El objeto Ogre::Camera define la cámara de la escena. Este objeto es
imprescindible, pues sin él no podremos ver nada en nuestra
ventana. Para ello, añadiremos el siguiente código:</p>
<pre class="code C++ literal-block">
<span class="p">(...)</span>
<span class="cp">#include &lt;OgreCamera.h&gt;
</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">Camera</span><span class="o">*</span> <span class="n">create_camera</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Camera</span><span class="o">*</span> <span class="n">camera</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">getSceneManager</span><span class="p">(</span><span class="s">"SceneManager"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">createCamera</span><span class="p">(</span><span class="s">"Camera"</span><span class="p">);</span>

  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">160</span><span class="p">));</span>
  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">lookAt</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">setNearClipDistance</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">setFarClipDistance</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>


  <span class="n">Ogre</span><span class="o">::</span><span class="n">Viewport</span><span class="o">*</span> <span class="n">viewport</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">getAutoCreatedWindow</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addViewport</span><span class="p">(</span><span class="n">camera</span><span class="p">);</span>
  <span class="n">viewport</span><span class="o">-&gt;</span><span class="n">setBackgroundColour</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">ColourValue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

  <span class="n">camera</span><span class="o">-&gt;</span><span class="n">setAspectRatio</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Real</span><span class="p">(</span><span class="n">viewport</span><span class="o">-&gt;</span><span class="n">getActualWidth</span><span class="p">())</span> <span class="o">/</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">Real</span><span class="p">(</span><span class="n">viewport</span><span class="o">-&gt;</span><span class="n">getActualHeight</span><span class="p">()));</span>

  <span class="k">return</span> <span class="n">camera</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
 <span class="p">(...)</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Camera</span><span class="o">*</span> <span class="n">camera</span> <span class="o">=</span> <span class="n">create_camera</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>En esta ocasión, utilizamos el gestor de escena para crear una cámara
asociada a él. Ogre permite tener mas de un gestor de escena, e ir
cambiando entre ellos. Es por esta razón que hay que asociar la cámara
a un gestor de escena.</p>
<p>El objeto Ogre::Viewport es el equivalente al frustrum de la cámara;
es decir, indica la región que sera renderizada.</p>
<p>Una vez inicializada la cámara, es importante añadir una fuente de
luz, ya que por defecto el mundo se haya en tinieblas:</p>
<pre class="code C++ literal-block">
<span class="kt">void</span> <span class="nf">create_light</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">Root</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">getSceneManager</span><span class="p">(</span><span class="s">"SceneManager"</span><span class="p">);</span>
  <span class="n">manager</span><span class="o">-&gt;</span><span class="n">setShadowTechnique</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SHADOWTYPE_STENCIL_ADDITIVE</span><span class="p">);</span>

  <span class="n">manager</span><span class="o">-&gt;</span><span class="n">setAmbientLight</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">ColourValue</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">));</span>

  <span class="n">Ogre</span><span class="o">::</span><span class="n">Light</span><span class="o">*</span> <span class="n">light</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">createLight</span><span class="p">(</span><span class="s">"MainLight"</span><span class="p">);</span>
  <span class="n">light</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
  <span class="n">light</span><span class="o">-&gt;</span><span class="n">setCastShadows</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">(...)</span>
  <span class="n">create_light</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>El método Ogre::SceneManager:setShadowTechnique(Ogre::ShadowTechnique)
asigna la técnica de generación de sombras que sera usada por este
gestor de escena. El tipo <a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/group___general.html#ga79dcd426d291c31072c1ad6f183715d6">Ogre::ShadowTechnique</a>
es un tipo enumerado que permite seleccionar una técnica de generación
de sombra.</p>
<p>Una vez que tenemos listo todo lo necesario para que pueda renderizarse
nuestra escena, procederemos a crearla añadiendo nodos de escena.</p>
</div>
<div class="section" id="anadiendo-nodos-a-nuestra-escena">
<h3>Añadiendo nodos a nuestra escena</h3>
<p>La forma en que Ogre desencapsula el grafo de escena y los objetos de
los mismos es mediante el objeto Ogre::SceneNode. Los objeto SceneNode
son los cuerpos gráficos genéricos sobre los que se realizarán las
operaciones de traslación, rotación, etc. A estos nodos hay que
adjuntarles un contenido, típicamente un objeto de tipo Ogre::Entity,
aunque se pueden adjuntar otros tipos de objetos. Veamos el código:</p>
<pre class="code C++ literal-block">
<span class="p">(...)</span>
<span class="cp">#include &lt;OgreEntity.h&gt;
#include &lt;OgreVector3.h&gt;
#include &lt;OgreMath.h&gt;
#include &lt;OgreMeshManager.h&gt;
</span>
<span class="p">(...)</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">get_node_by_name</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span><span class="p">,</span>
                                 <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">node_name</span><span class="o">=</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node_name</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">getRootSceneNode</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">getSceneNode</span><span class="p">(</span><span class="n">node_name</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Ogre</span><span class="o">::</span><span class="n">Entity</span><span class="o">*</span> <span class="n">create_entity_and_attach</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span><span class="p">,</span>
                                       <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span>
                                       <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">mesh</span><span class="p">,</span>
                                       <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">target_node</span><span class="o">=</span><span class="s">""</span><span class="p">,</span>
                                       <span class="kt">bool</span> <span class="n">cast_shadows</span><span class="o">=</span><span class="nb">true</span><span class="p">){</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_node_by_name</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">target_node</span><span class="p">);</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Entity</span><span class="o">*</span> <span class="n">entity</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">createEntity</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mesh</span><span class="p">);</span>
  <span class="n">entity</span><span class="o">-&gt;</span><span class="n">setCastShadows</span><span class="p">(</span><span class="n">cast_shadows</span><span class="p">);</span>

  <span class="n">node</span><span class="o">-&gt;</span><span class="n">attachObject</span><span class="p">(</span><span class="n">entity</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">entity</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">create_node</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span><span class="p">,</span>
                             <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span>
                             <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">parent</span><span class="o">=</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">parent_node</span> <span class="o">=</span> <span class="n">get_node_by_name</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">createChildSceneNode</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">create_node_and_entity</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">*</span> <span class="n">manager</span><span class="p">,</span>
                                        <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span>
                                        <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">mesh</span><span class="p">,</span>
                                        <span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">parent</span><span class="o">=</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">create_node</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">Entity</span><span class="o">*</span> <span class="n">entity</span> <span class="o">=</span> <span class="n">create_entity_and_attach</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="p">(...)</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">SceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">create_node_and_entity</span><span class="p">(</span><span class="n">scene_manager</span><span class="p">,</span> <span class="s">"SinbadNode"</span><span class="p">,</span> <span class="s">"Sinbad.mesh"</span><span class="p">);</span>

<span class="p">}</span>
</pre>
<p>Las funciones anteriores son funciones de alto nivel que encapsulan
una funcionalidad relacionada con el nombre de la función. Aunque
parezca mucho código, las sentencias mas importantes son:</p>
<pre class="code C++ literal-block">
<span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">createChildSceneNode</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</pre>
<p>La sentencia anterior genera un nodo hijo cuyo nodo raíz es el nodo
padre(<em>parent_node</em>). Esto es muy útil, ya que todas las
transformaciones que sufra el padre tambien las sufrirá el hijo. De
esta forma, podemos generar cuerpos compuestos y mover únicamente el
nodo padre, sabiendo que los nodos hijos se moverán de igual forma.</p>
<pre class="code C++ literal-block">
<span class="n">Ogre</span><span class="o">::</span><span class="n">Entity</span><span class="o">*</span> <span class="n">entity</span> <span class="o">=</span> <span class="n">manager</span><span class="o">-&gt;</span><span class="n">createEntity</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mesh</span><span class="p">);</span>
</pre>
<p>Esta sentencia crea una instancia de un objeto tipo Ogre::Mesh. La
clase Ogre::Mesh almacena los datos necesarios para representar un
objeto tridimensional. Dicha malla la hemos cargado anteriormente en
el método <em>load_resources(std::string)</em>.</p>
<p>Por último, utilizamos dos funciones muy similares para obtener la
referencia a los SceneNode por su nombre:</p>
<pre class="code C++ literal-block">
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">::</span><span class="n">getRootSceneNode</span><span class="p">();</span>
<span class="n">Ogre</span><span class="o">::</span><span class="n">SceneManager</span><span class="o">::</span><span class="n">getSceneNode</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">String</span> <span class="n">node_name</span><span class="p">);</span>
</pre>
<p>El primero devuelve la referencia al nodo raíz del grafo de escena y
el segundo al nodo que coincida con el nombre que se le pase por
argumentos.</p>
<p>Por último, debemos añadir la sentencia que renderiza la escena. Para
poder parar nuestra aplicación, en este documento se hará uso de la
clase Ogre::WindowEventListener, que cuenta con el método
WindowClosing y windowClosed. Para ello crearemos una clase y haremos
que herede de Ogre::WindowEventListener:</p>
<pre class="code C++ literal-block">
<span class="cp">#include &lt;OgreWindowEventUtilities.h&gt;
</span>
<span class="k">class</span> <span class="nc">WindowManager</span><span class="o">:</span> <span class="k">public</span> <span class="n">Ogre</span><span class="o">::</span><span class="n">WindowEventListener</span><span class="p">{</span>
  <span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">exit</span><span class="p">;</span>

  <span class="n">WindowManager</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">){</span>
    <span class="n">window_</span> <span class="o">=</span> <span class="n">window</span><span class="p">;</span>
    <span class="n">exit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">WindowEventUtilities</span><span class="o">::</span><span class="n">addWindowEventListener</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">windowClosing</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">){</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">LogManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">().</span><span class="n">logMessage</span><span class="p">(</span><span class="s">"Closing window..."</span><span class="p">);</span>
    <span class="n">exit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">windowClosed</span><span class="p">(</span><span class="n">Ogre</span><span class="o">::</span><span class="n">RenderWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">LogManager</span><span class="o">::</span><span class="n">getSingleton</span><span class="p">().</span><span class="n">logMessage</span><span class="p">(</span><span class="s">"Window closed."</span><span class="p">);</span>
    <span class="n">exit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="p">(...)</span>
  <span class="n">WindowManager</span> <span class="n">windowManager</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">windowManager</span><span class="p">.</span><span class="n">exit</span><span class="p">){</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">renderOneFrame</span><span class="p">();</span>
    <span class="n">Ogre</span><span class="o">::</span><span class="n">WindowEventUtilities</span><span class="o">::</span><span class="n">messagePump</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">};</span>
</pre>
<p>La clase Ogre::WindowEventListener se encarga de gestionar todos los
eventos relacionados con una ventana.</p>
<pre class="code C++ literal-block">
<span class="n">Ogre</span><span class="o">::</span><span class="n">WindowEventUtilities</span><span class="o">::</span><span class="n">addWindowEventListener</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</pre>
<p>La sentencia anterior se encarga de registrar la instancia de la clase
WindowManager como gestor de todos los eventos producidos en
<em>window</em>. Los métodos <em>windowClosed</em> y
<em>windowClosing</em> se ejecutan cuando se detecta un evento de
cierre de ventana; es decir, cuando se pulsa el botón de salir de la
esquina superior derecha de la ventana.</p>
<p>Se ha añadido el bucle principal a la función principal. El método
<em>renderOneFrame</em> indica a Ogre que debe actualizar los cuerpos
gráficos de la escena, muestras que la sentencia
<em>messagePump()</em> debe ser llamada una vez por frame, ya que
actualizará todas las ventanas que hayan sido registradas.</p>
<p>Hecho esto, habremos terminado. Sólo faltará compilar y ejecutar
nuestra aplicación. El resultado deberá ser parecido al de la
siguiente figura.</p>
<div class="line-block">
<div class="line"><br></div>
</div>
<blockquote>
<img alt="captura-ejecucion.png" class="align-center" src="posts/introduccion-ogre3d/captura-ejecucion.png">
</blockquote>
<div class="line-block">
<div class="line"><br></div>
</div>
<p>El código final debe parecerse al del fichero que podremos encontrar
en el <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/src/47e9565d0897607426587ef70798496f44f23ec8/src/main.cpp?at=master">repositorio de este tutorial</a></p>
<!-- LocalWords:  renderizada -->
</div>
</div>
</div>
    </div>
    </article>
    <article class="h-entry post-text">
    <header>
        <h1 class="p-name entry-title"><a href="posts/presentacion/presentacion.html" class="u-url">Presentación</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="posts/presentacion/presentacion.html" rel="bookmark"><time class="published dt-published" datetime="2014-12-03T23:07:15+01:00" itemprop="datePublished" title="2014-12-03 23:07">2014-12-03 23:07</time></a></p>
        </div>
    </header>
    <div class="e-content entry-content">
    <div>
<img alt="tinman.jpg" class="align-center" src="posts/presentacion/tinman.jpg">
<p>Este blog servirá como registro donde quedará plasmada la evolución de mi proyecto fin de grado.</p>
<p>En él se explicará el porqué de cada decisión que se ha tomado y se tomará durante el desarrollo
del mismo de una forma sencilla y concisa, desarrollando las distintas alternativas que se han tenido
en consideración en cada momento.</p>
<p>El código fuente del proyecto se puede encontrar en el siguiente link: <a class="reference external" href="https://bitbucket.org/arco_group/tfg.tinman">https://bitbucket.org/arco_group/tfg.tinman</a></p>
<div class="section" id="acerca-de-mi">
<h2>Acerca de mí:</h2>
<p>Me llamo Isaac y actualmente soy estudiante de Grado en Ingeniería Informática en la Escuela Superior de Informática de Ciudad Real.
Soy oootro apasionado mas de la tecnología, prueba de ello es que haya elegido usar Nikola como generador de mi blog y github pages
como lugar donde alojarlo, en lugar de las miles de soluciones existentes que te facilitan la vida. Porque pudiendo seguir la solución dificil, ¿para qué vas a seguir la fácil?</p>
<p>Esto último define bien mis preferencias. Desde siempre he sido un apasionado de los videojuegos. Y ya que el proyecto fin de grado es el broche final a lo que ha sido, hasta el momento, mi experiencia como estudiante universitario, decidí que sería perfecto finalizar con un proyecto que me definiese como ingeniero y como persona.</p>
</div>
</div>
    </div>
    </article>
</div>







        </div>
        <!--End of body content-->

        <footer>
            Contents © 2015         <a href="mailto:isaac.lacoba@gmail.com">Isaac Lacoba Molina</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
    </div>
</div>


            <script src="assets/js/jquery.min.js"></script>
            <script src="assets/js/bootstrap.min.js"></script>
            <script src="assets/js/moment-with-locales.min.js"></script>
            <script src="assets/js/fancydates.js"></script>
        <script src="assets/js/jquery.colorbox-min.js"></script>
        <script src="assets/js/colorbox-i18n/jquery.colorbox-es.js"></script>
    
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul>
<li>
<a class="addthis_button_facebook"></a>
</li>
<li>
<a class="addthis_button_google_plusone_share"></a>
</li>
<li>
<a class="addthis_button_linkedin"></a>
</li>
<li>
<a class="addthis_button_twitter"></a>
</li>
</ul>
</div>
<script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script>jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    <!-- fancy dates -->
    <script>
    moment.locale("es");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script>
    <!-- end fancy dates -->
    
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-57580832-1', 'auto');ga('send', 'pageview');</script>

</body>
</html>
