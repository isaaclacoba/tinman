<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="es">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Introducción a Ogre3D | Tinman</title>

    
            <link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">

    
            <link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">

      <link rel="canonical" href="http://isaaclacoba.github.io/tinman/posts/introduccion-ogre3d/introduccion-a-ogre3d.html">




    
        <!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]-->

    


    

    <meta name="author" content="Isaac Lacoba Molina">
        <link rel="prev" href="../presentacion/presentacion.html" title="Presentación" type="text/html">
        <link rel="next" href="../justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html" title="Justificación y objetivos del proyecto" type="text/html">
    
    <meta property="og:site_name" content="Tinman">
    <meta property="og:title" content="Introducción a Ogre3D">
    <meta property="og:url" content="http://isaaclacoba.github.io/tinman/posts/introduccion-ogre3d/introduccion-a-ogre3d.html">
    <meta property="og:description" content="En esta primera entrada hablaremos brevemente de Ogre3D, y de porqué
se ha elegido como biblioteca de renderizado. Para ejemplificarlo, se
ha creado un pequeño programa usando Ogre en el que se render">
    <meta property="og:type" content="article">
    <meta property="article:published_time" content="2015-01-03T10:41:32+01:00">

    

    



</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://isaaclacoba.github.io/tinman/">

                <span id="blog-title">Tinman</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                
                <li>
<a href="../../archive.html">Archivo</a>
                </li>
<li>
<a href="../../categories/index.html">Tags</a>
                </li>
<li>
<a href="../../rss.xml">feed RSS</a>

                
            </li>
</ul>

            <ul class="nav navbar-nav navbar-right">
                
                
                    
    <li>
    <a href="introduccion-a-ogre3d.rst" id="sourcelink">Código</a>
    </li>

                
            </ul>
        </div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav>

<!-- End of Menubar -->

<div class="container" id="content">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article">
    
    <header>
        
    <h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Introducción a Ogre3D</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Isaac Lacoba Molina</span></p>
            <p class="dateline"><a href="#" rel="bookmark"><time class="published dt-published" datetime="2015-01-03T10:41:32+01:00" itemprop="datePublished" title="2015-01-03 10:41">2015-01-03 10:41</time></a></p>
            
        <p class="sourceline"><a href="introduccion-a-ogre3d.rst" id="sourcelink">Código</a></p>

        </div>
        

    </header>

    <div class="e-content entry-content" itemprop="articleBody text">
    <div>
<img alt="ogre-logo.png" class="align-center" src="ogre-logo.png">
<p>En esta primera entrada hablaremos brevemente de Ogre3D, y de porqué
se ha elegido como biblioteca de renderizado. Para ejemplificarlo, se
ha creado un pequeño programa usando Ogre en el que se renderiza su
mascota, Sinbad, al mismo tiempo que servirá como ejemplo para mostrar
la estructura típica de un programa que hace uso de esta biblioteca.</p>
<p>Este post es una adaptación del tutorial que realicé hace unos meses y que podeis encontrar aquí: <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/overview">https://bitbucket.org/IsaacLacoba/intro-ogre/overview</a></p>
<div class="section" id="que-es-ogre3d">
<h2>¿Qué es Ogre3D?</h2>
<p>Ogre3D(<a class="reference external" href="http://www.ogre3d.org/">Object-Oriented Graphic Engine</a>) es
un motor de renderizado de propósito general creado por Steve
Streeting(tambien conocido como Sinbad) distribuido bajo licencia
LGPL(<a class="reference external" href="https://bitbucket.org/sinbad/ogre">repositorio-ogre3d</a>). Fue
creado en 2001(<a class="reference external" href="http://www.gamasutra.com/view/news/105533/QA_Steve_Streeting_On_Open_Source_3D_Engine_OGRE_3D.php">entrevista-streeting</a>)
con el propósito de crear un componente de renderizado en tiempo real
sin hacer asunciones a nivel de aplicación. El objetivo era crear un
componente genérico que pudiese ser ampliado a través de
plugins. Desde un principio el proyecto se diseñó teniendo en cuenta
la mantenibilidad y la facilidad de ampliación.</p>
<p>Ogre3D no fue concebido como un motor de juegos. Se pretendía cubrir
el mayor espectro posible,de manera que no sólo sirviese a campos como
el de los videojuegos, sino tambien a los de simulación, realidad
aumentada, realidad virtual,...y en general, cualquier campo que
requiriese del uso de herramientas de renderizado en tiempo real.</p>
<p>Además, el hecho de que se distribuya bajo una licencia de código
libre contribuye muchísimo más a su éxito. Esto es así debido a que la
comunidad está muy involucrada con el proyecto, cosa que podemos
observar en el <a class="reference external" href="http://www.ogre3d.org/forums/">foro oficial</a> del
proyecto, donde se resuelven dudas de desarrollo, se discute el
roadmap, etc. En cuanto a las <a class="reference external" href="http://www.ogre3d.org/developers/submit-patch">politica de contribuciones</a>, los usuarios de la
comunidad pueden colaborar bien realizando pull-request al repositorio
oficial con sus parches o bien reportando
bugs al <a class="reference external" href="https://ogre3d.atlassian.net/browse/OGRE/?selectedTab=com.atlassian.jira.jira-projects-plugin:summary-panel">Jira del proyecto</a></p>
<p>Como hemos dicho antes, Ogre3D no es un motor de juego. Esto implica
que será el desarrollador quien tenga que encargarse de aspectos como
la gestión de eventos de entrada (teclado,ratón,...), físicas, networking,
interfaces, etc. En el caso del desarrollo de interfaces existen maneras de crearlas
con Ogre a través del uso de overlays; sin embargo, esta
aproximación no es lo suficientemente flexible como para crear interfaces
avanzadas. Las características principales de Ogre son:</p>
<ul class="simple">
<li>
<strong>Mutiplataforma</strong>: permite el desarrollo para sistemas Windows, GNU/Linux y Mac OS X.</li>
<li>
<strong>Diseño a alto nivel</strong>: Ogre3D encapsula llamadas a las librerías
gráficas DirectX y OpenGL. Además, hace uso de patrones de diseño:
<em>observer</em> para informar de eventos y cambios de estado,
<em>singleton</em> para evitar que exista mas de una instancia de
cualquier manager, <em>visitor</em> para realizar operaciones sobre
un objeto y evitar modificarlo (por ejemplo, en los nodos del grafo
de escena), <em>façade</em> para unificar el acceso a operaciones,
<em>factory</em> para creación de objetos concretos de interfaces
abstractas, etc.</li>
<li>
<strong>Grafo de escena</strong>: una de las características mas
importantes del grafo de escena de Ogre es que desacopla el propio
grafo del contenido de la escena, definiendo una arquitectura de
pugins. A diferencia de otros motores gráficos, como Irrlicht3D,
Blitz3D o Unreal, Ogre no se basa en la herencia como principio de
diseño del grafo, sino en la composición. Esto permite expandir el
diseño para soportar otros tipos de datos, como audio o elementos de
simulación física. En la siguiente figura podemos ver
el esquema general del grafo de escena de Ogre.</li>
</ul>
<div class="line-block">
<div class="line"><br></div>
</div>
<img alt="Jerarquía general del grafo de escena." class="align-center" id="my-picture" src="grafo-escena.png" style="width: 250px;">
<div class="line-block">
<div class="line"><br></div>
</div>
<ul class="simple">
<li>
<strong>Aceleración Hardware</strong>: OGRE permite definir el comportamiento
de la parte programable de la GPU mediante la definición de Shaders,
estando al mismo nivel de otros motores como Unreal o CryEngine.</li>
<li>
<strong>Materiales</strong>: se definen mediante un sistema de scripts y permiten
asignar o cambiar los materiales de los elementos de la escena sin
modificar el código fuente.</li>
<li>
<strong>Animación</strong>: tres tipos(skeletal, morph y pose). La animación y la
geometría asociada a los modelos se almacena en un único formato
binario optimizado. El proceso mas empleado se basa en la
exportación desde la aplicación de modelado y animación 3D a un
formato XML (Ogre XML) para convertirlo posteriormente al formato
binario optimizado mediante la herramienta de línea de órdenes
OgreXMLConverter.</li>
<li>
<strong>Composición y Postprocesado</strong>.</li>
<li>
<strong>Plugins</strong>.</li>
<li>
<strong>Gestión de Recursos</strong>: Ogre ofrece una serie de gestores de
recursos, organizados jerárquicamente por grupos.</li>
<li>
<strong>Características específicas avanzadas</strong>: El motor soporta gran
cantidad de características de visualización avanzadas, tales como
sombras dinámicas (basadas en diversas técnicas de cálculo),
sistemas de partículas, animación basada en esqueletos y de
vértices, y un largo etcétera. OGRE soporta además el uso de otras
bibliotecas auxiliares mediante plugins y conectores. Entre los más
utilizados cabe destacar las bibliotecas de simulación física ODE,
el soporte del metaformato Collada, o la reproducción de streaming
de vídeo con Theora.</li>
</ul>
</div>
<div class="section" id="veamos-algo-de-codigo">
<h2>Veamos algo de código</h2>
<p>El código fuente del ejemplo que vamos a estudiar lo podemos encontrar
en el siguiente repositorio:
<a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/overview">https://bitbucket.org/IsaacLacoba/intro-ogre/overview</a>.</p>
<p>Se ha creado un <em>¡Hola Mundo!</em> en Ogre3D con la intención de que fuese
lo más sencillo posible. Por esta razón, lo único que hace el ejemplo
es renderizar la mascota de Ogre, Sinbad. En la <a class="reference external" href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Tutorials">wiki del proyecto
Ogre</a>
hay una colección muy interesante de tutoriales que es recomendable
que el lector interesado estudie. En los listados de código, intentaremos mostrar únicamente el código que se añade en cada paso.</p>
<p>Pero antes de empezar, vamos a explicar como instalar Ogre3D en un
sistema operativo GNU/Linux. Consulta este <a class="reference external" href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Installing+the+Ogre+SDK">tutorial</a>
para saber como instalar Ogre3D en un sistema Microsoft Windows.</p>
</div>
<div class="section" id="instalacion">
<h2>Instalación</h2>
<p>En distribuciones de GNU/Linux, la instalación de Ogre3D pasa por
instalar los siguientes paquetes:</p>
<pre class="code bash literal-block">
<span class="c"># apt-get update apt-get install libogre-1.8.0 libogre-1.8-dev libogre-1.8.0-dbg freeglut3-dev libfreetype6 libfreetype6-dev libgl1-mesa-dev libgl1-mesa-glx</span>
</pre>
<p>Los tres primeros paquetes nos instalarán Ogre3D. Los siguientes
paquetes son dependencias indirectas de Ogre, los primeros de OpenGL y
los dos últimos instalarán el driver gráfico mesa.</p>
<div class="section" id="comprobando-la-instalacion">
<h3>Comprobando la instalación</h3>
<p>Aunque el proceso de instalación ha sido extremadamente complejo, no
está de más comprobar que todo haya ido bien. Para comprobar que Ogre
se ha instalado correctamente, crearemos una instancia del objeto Root
y compilaremos el código.</p>
<p>Primero, crearemos un fichero de texto llamado <em>main.cpp</em> con el siguiente código:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 162)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   #include &lt;OgreRoot.h&gt;

   int main(int argc, char argv*[]) {
      Ogre::Root* root = new Ogre::Root("config/plugins.cfg", "config/ogre.cfg", "config/ogre.log");
   }

</pre>
</div>
<p>Para poder compilarlo, crearemos un sencillo makefile con el siguiente
código. Crea un fichero llamado Makefile y escribe el siguiente
codigo:</p>
<pre class="code make literal-block">
<span class="nv">CXX</span><span class="o">=</span>g++
<span class="nv">CXXFLAGS</span> <span class="o">=</span> -std<span class="o">=</span>c++11 -ggdb <span class="k">$(</span>shell pkg-config --cflags OGRE OIS<span class="k">)</span>
<span class="nv">LDLIBS</span> <span class="o">=</span> <span class="k">$(</span>shell pkg-config --libs OGRE OIS<span class="k">)</span>

<span class="nf">main</span><span class="o">:</span> <span class="m">main.cpp</span>
</pre>
<p>Para compilarlo, abriremos un terminal en la carpeta donde
tengamos el codigo fuente y ejecutaremos:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>make
</pre>
<p>Esto compilara nuestro codigo. Si la compilación se realizó sin
problemas, procederemos a ejecutar el binario:</p>
<pre class="code bash literal-block">
<span class="nv">$ </span>./main
</pre>
<p>Si todo ha ido bien, la traza de inicialización de Ogre debiera
mostrarse por terminal y en el fichero "config/ogre.log". Hecho
esto, habremos comprobado que hemos instalado correctamente Ogre en
nuestro sistema. Ahora, continuemos construyendo nuestro ejemplo.</p>
</div>
</div>
<div class="section" id="sigamos-programando">
<h2>Sigamos programando</h2>
<p>El objeto que acabamos de crear es el objeto principal de Ogre, el
cual inicializa todos los componentes internos. Recibe hasta tres
parámetros, los cuales son las rutas a tres ficheros de configuración:
el primero indica la ruta de los plugins que se van a usar, el segundo
indica la configuración básica del sistema de renderizado(OpenGL o
DirectX, tamaño de la pantalla, frecuencia de refresco,...) y el
tercero es la ruta hacia el log donde Ogre volcará la traza, tanto de
inicialización como de destrucción de los recursos. Indicándole la
ruta hacia los ficheros, Ogre se encargará de crearlos si no
existiesen, únicamente en los dos últimos casos. En el caso del
fichero de plugins, hay que indicarle la ruta, ya que por defecto Ogre
no sabe donde buscarlos.</p>
<p>Una vez hecho esto, añadiremos el siguiente código que permite indicar
a Ogre la configuración básica del sistema de renderizado:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 223)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   void check_config(Ogre::Root* root) {
      if (not (root-&gt;restoreConfig() || root-&gt;showConfigDialog())) {
         Ogre::LogManager::getSingleton().logMessage("Initialize::configure_ogre =&gt; " +
         std::string("ERROR: unable to configure Ogre"));
      }
   }

   int main(int argc, char *argv[]) {
     Ogre::Root* root = new Ogre::Root("config/plugins.cfg", "config/ogre.cfg", "config/ogre.log");
     check_config(root);

     return 0;
   }

</pre>
</div>
<p>Al ejecutarlo por primera vez, debería aparecer una pantalla como la siguiente:</p>
<div class="line-block">
<div class="line"><br></div>
</div>
<img alt="configuracion-ogre.png" class="align-center" src="configuracion-ogre.png">
<div class="line-block">
<div class="line"><br></div>
</div>
<p>Este dialogo aparecerá cuando Ogre no encuentre el fichero
"config/ogre.cfg" (es decir, Ogre::Root::restoreConfig() devuelva
falso) e invoque al método Ogre::Root::showConfigDialog(). Debemos
asegurarnos de que la opción <em>Full Screen</em> este marcada como
<em>No</em>, de modo que podamos cerrar la aplicación de forma
correcta mas adelante. Hecho esto, podemos pulsar
<em>Accept</em>. Internamente, Ogre invocará a los métodos
Ogre::Root::SetRenderSystem, Ogre::RenderSystem::setConfigOption y
Ogre::Root::saveConfig que establecen el sistema de renderizado, la
configuración del mismo y guardan dicha configuración en un fichero de
texto.</p>
<p>El siguiente paso consiste en crear la ventana de nuestra aplicación,
donde se renderizará la escena. Existen dos formas de crear una
ventana: la primera es usando el constructor de la clase
Ogre::RenderWindow. La segunda, mas sencilla, es dejar que Ogre cree
una por defecto, basándose en la configuración obtenida del paso
anterior:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 267)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   #include &lt;OgreRenderWindow.h&gt;
   (...)
   int main(int argc, char *argv[]) {
      Ogre::Root* root = new Ogre::Root("config/plugins.cfg", "config/ogre.cfg", "config/ogre.log");
      check_config(root);
      Ogre::RenderWindow* window = root-&gt;initialize(true, "Titulo");
   }

</pre>
</div>
<p>Añadimos el fichero de cabecera y creamos la ventana por defecto con el método
Ogre::Root:initialize. El primer parámetro indica a Ogre que queremos que cree un
Ogre::RenderWindow. Internamente se invocará al método
Ogre::Root::createRenderWindow. Es importante señalar que solo se
puede invocar este método después de haber obtenido la configuración
básica del sistema de renderizado.</p>
<p>Tras esto, procederemos a inicializar el gestor de escena:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 286)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

  (...)

   int main(int argc, char *argv[]) {

   (...)
      Ogre::SceneManager* scene_manager = root-&gt;createSceneManager(Ogre::ST_GENERIC);
  }

</pre>
</div>
<p>La clase Ogre::SceneManager se encarga de organizar el
<em>culling</em> y el proceso de renderizado de la escena, junto con
la clase Ogre::RenderQueue. Del mismo modo que antes, hacemos uso de
la instancia del objeto Root para inicializar el gestor de escena. El
método Ogre::Root::createSceneManager acepta un tipo enumerado llamado
<a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/group___scene.html#gga7383602bd480d43b80c626969b9af914a0af8f844019e52fe112e9a946a919fcd">Ogre::SceneType</a>. Este tipo enumerado le indica a
Ogre qué tipo de <a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/class_ogre_1_1_scene_manager.html">SceneManger</a> tiene que
devolver (para mas información ver el <a class="reference external" href="http://www.ogre3d.org/tikiwiki/SceneManagersFAQ#Selecting_a_Scene_Manager">faq</a> ).</p>
<p>El gestor de escena nos permitirá crear nuestros nodos de escena y
las entidades donde se cargarán las mallas 3D. Para ello, necesitamos
tener algo que renderizar, de modo que vamos a descargarnos las
mallas.</p>
<div class="section" id="obteniendo-recursos-multimedia">
<h3>Obteniendo recursos multimedia</h3>
<p>En Internet podemos encontrar gran cantidad de contenido con licencia
creative commons que nos permitirá trabajar libremente con él, aunque
siempre hay que mirar cuidadosamente qué tipo de licencia tiene el
contenido multimedia que vamos a usar y respetarla en todo
momento. Para nuestro primer ejemplo, utilizaremos la mascota de
Ogre3D, Sinbad. Para ello, nos iremos al repositorio del
<a class="reference external" href="https://bitbucket.org/sinbad/ogre/src/046a0d6687d11a4413db3bbb8d49cc721b083a48/Samples/Media/packs/?at=default">proyecto</a>, a la carpeta <strong>Samples/Media/Packs</strong>,
donde podremos encontrar mallas listas para ser usadas. Nos
descargaremos el pack llamadado <em>Sinbad.zip</em>. A continuación,
crearemos una carpeta llamada <em>media</em> dentro del directorio de
nuestro proyecto y descompromimos el contenido del archivo .zip allí.</p>
<p>Hecho esto, los siguientes pasos que nos quedan son crear un nodo y
una entidad, adjuntar la entidad al nodo, así como crear un foco de
luz y una cámara.</p>
</div>
<div class="section" id="creando-nuestra-escena">
<h3>Creando nuestra escena</h3>
<p>El siguiente paso que deberemos realizar será crear un fichero que
permita saber a Ogre donde están los recursos multimedia. Dentro de la
carpeta <em>config</em> crearemos un fichero llamado "resources.cfg"
con el siguiente contenido:</p>
<pre class="code bash literal-block">
<span class="o">[</span>General<span class="o">]</span>
<span class="nv">FileSystem</span><span class="o">=</span>media
</pre>
<p>Esto simplemente le indica a Ogre que dentro de la carpeta media
encontrara los recursos multimedia. Pero primero hay que parsear el
fichero y cargar dichos recursos.</p>
</div>
<div class="section" id="cargando-los-recursos">
<h3>Cargando los recursos</h3>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 349)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   (...)
   #include &lt;OgreResourceGroupManager.h&gt;
   #include &lt;OgreConfigFile.h&gt;

   void load_resources(string resources_file) {
       Ogre::ConfigFile cf;
       cf.load(resources_file);

       Ogre::ConfigFile::SectionIterator seci = cf.getSectionIterator();

       Ogre::String secName, typeName, archName;
       while (seci.hasMoreElements()) {
         secName = seci.peekNextKey();
         Ogre::ConfigFile::SettingsMultiMap *settings = seci.getNext();
         Ogre::ConfigFile::SettingsMultiMap::iterator i;
         for (i = settings-&gt;begin(); i != settings-&gt;end(); ++i) {
           typeName = i-&gt;first;
           archName = i-&gt;second;
           Ogre::ResourceGroupManager::getSingleton()
             .addResourceLocation(archName, typeName, secName);
         }
       }

       Ogre::ResourceGroupManager::getSingleton()
         .initialiseAllResourceGroups();
   }

   int main(int argc, char *argv[])
   {
     (...)
     load_resources("config/resources.cfg");
   }


</pre>
</div>
<p>La función anterior abre el fichero y lo va
recorriendo buscando claves. Cada clave indica el nombre de
un directorio donde hay recursos multimedia. Estos directorios los
recorre en el bucle <em>for</em> buscando archivos de los que saca
el tipo, el nombre y los registra dentro del gestor de recursos
(Ogre::ResourcerGroupManager). Tras registrar todos los recursos que
haya encontrado, los inicializa.</p>
<p>Es importante que se invoque la función
<em>load_resources(string)</em> antes que la función
<em>check_config(Ogre::Root)</em> en el caso en el que usemos
Ogre::Overlay. Si se invoca en orden contrario, el programa compilará
correctamente, pero lanzará un error de segmento.</p>
<p>Este paso nos permitirá utilizar los recursos multimedia en nuestra
escena. Pero primero, deberemos crearemos la cámara y un foco de
luz.</p>
</div>
<div class="section" id="creando-nuestra-camara">
<h3>Creando nuestra cámara</h3>
<p>El objeto Ogre::Camera define la cámara de la escena. Este objeto es
imprescindible, pues sin él no podremos ver nada en nuestra
ventana. Para ello, añadiremos el siguiente código:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 410)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   (...)
   #include &lt;OgreCamera.h&gt;

   Ogre::Camera* create_camera(Ogre::Root* root) {
     Ogre::Camera* camera = root-&gt;getSceneManager("SceneManager")-&gt;createCamera("Camera");

     camera-&gt;setPosition(Ogre::Vector3(0, 160, 160));
     camera-&gt;lookAt(Ogre::Vector3(0,0,0));
     camera-&gt;setNearClipDistance(5);
     camera-&gt;setFarClipDistance(10000);


     Ogre::Viewport* viewport = root-&gt;getAutoCreatedWindow()-&gt;addViewport(camera);
     viewport-&gt;setBackgroundColour(Ogre::ColourValue(0, 0, 0));

     camera-&gt;setAspectRatio(Ogre::Real(viewport-&gt;getActualWidth()) / Ogre::Real(viewport-&gt;getActualHeight()));

     return camera;
   }

   int main(int argc, char *argv[]){
    (...)
     Ogre::Camera* camera = create_camera(root);
   }


</pre>
</div>
<p>En esta ocasión, utilizamos el gestor de escena para crear una cámara
asociada a él. Ogre permite tener mas de un gestor de escena, e ir
cambiando entre ellos. Es por esta razón que hay que asociar la cámara
a un gestor de escena.</p>
<p>El objeto Ogre::Viewport es el equivalente al frustrum de la cámara;
es decir, indica la región que sera renderizada.</p>
<p>Una vez inicializada la cámara, es importante añadir una fuente de
luz, ya que por defecto el mundo se haya en tinieblas:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 449)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   void create_light(Ogre::Root* root){
     Ogre::SceneManager* manager = root-&gt;getSceneManager("SceneManager");
     manager-&gt;setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_ADDITIVE);

     manager-&gt;setAmbientLight(Ogre::ColourValue(0.25, 0.25, 0.25));

     Ogre::Light* light = manager-&gt;createLight("MainLight");
     light-&gt;setPosition(20, 80, 50);
     light-&gt;setCastShadows(true);

   }

   int main(int argc, char *argv[])
   {
     (...)
     create_light(root);
   }


</pre>
</div>
<p>El método Ogre::SceneManager:setShadowTechnique(Ogre::ShadowTechnique)
asigna la técnica de generación de sombras que sera usada por este
gestor de escena. El tipo <a class="reference external" href="http://www.ogre3d.org/docs/api/1.9/group___general.html#ga79dcd426d291c31072c1ad6f183715d6">Ogre::ShadowTechnique</a>
es un tipo enumerado que permite seleccionar una técnica de generación
de sombra.</p>
<p>Una vez que tenemos listo todo lo necesario para que pueda renderizarse
nuestra escena, procederemos a crearla añadiendo nodos de escena.</p>
</div>
<div class="section" id="anadiendo-nodos-a-nuestra-escena">
<h3>Añadiendo nodos a nuestra escena</h3>
<p>La forma en que Ogre desencapsula el grafo de escena y los objetos de
los mismos es mediante el objeto Ogre::SceneNode. Los objeto SceneNode
son los cuerpos gráficos genéricos sobre los que se realizarán las
operaciones de traslación, rotación, etc. A estos nodos hay que
adjuntarles un contenido, típicamente un objeto de tipo Ogre::Entity,
aunque se pueden adjuntar otros tipos de objetos. Veamos el código:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 491)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   (...)
   #include &lt;OgreEntity.h&gt;
   #include &lt;OgreVector3.h&gt;
   #include &lt;OgreMath.h&gt;
   #include &lt;OgreMeshManager.h&gt;

   (...)
   Ogre::SceneNode* get_node_by_name(Ogre::SceneManager* manager,
                                    Ogre::String node_name="") {
     Ogre::SceneNode* node;
     if (node_name.empty())
       node = manager-&gt;getRootSceneNode();
     else
       node = manager-&gt;getSceneNode(node_name);

     return node;
   }

   Ogre::Entity* create_entity_and_attach(Ogre::SceneManager* manager,
                                          Ogre::String name,
                                          Ogre::String mesh,
                                          Ogre::String target_node="",
                                          bool cast_shadows=true){
     Ogre::SceneNode* node = get_node_by_name(manager, target_node);
     Ogre::Entity* entity = manager-&gt;createEntity(name, mesh);
     entity-&gt;setCastShadows(cast_shadows);

     node-&gt;attachObject(entity);
     return entity;
   }
   Ogre::SceneNode* create_node(Ogre::SceneManager* manager,
                                Ogre::String name,
                                Ogre::String parent="") {
     Ogre::SceneNode* parent_node = get_node_by_name(manager, parent);

       return parent_node-&gt;createChildSceneNode(name);
   }


   Ogre::SceneNode* create_node_and_entity(Ogre::SceneManager* manager,
                                           Ogre::String name,
                                           Ogre::String mesh,
                                           Ogre::String parent="") {
     Ogre::SceneNode* node = create_node(manager, name, parent);
     Ogre::Entity* entity = create_entity_and_attach(manager, name, mesh, name);
       return node;
   }

   int main(int argc, char *argv[]) {
   (...)
     Ogre::SceneNode* node = create_node_and_entity(scene_manager, "SinbadNode", "Sinbad.mesh");

   }


</pre>
</div>
<p>Las funciones anteriores son funciones de alto nivel que encapsulan
una funcionalidad relacionada con el nombre de la función. Aunque
parezca mucho código, las sentencias mas importantes son:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 552)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

  parent_node-&gt;createChildSceneNode(name);


</pre>
</div>
<p>La sentencia anterior genera un nodo hijo cuyo nodo raíz es el nodo
padre(<em>parent_node</em>). Esto es muy útil, ya que todas las
transformaciones que sufra el padre tambien las sufrirá el hijo. De
esta forma, podemos generar cuerpos compuestos y mover únicamente el
nodo padre, sabiendo que los nodos hijos se moverán de igual forma.</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 563)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

  Ogre::Entity* entity = manager-&gt;createEntity(name, mesh);


</pre>
</div>
<p>Esta sentencia crea una instancia de un objeto tipo Ogre::Mesh. La
clase Ogre::Mesh almacena los datos necesarios para representar un
objeto tridimensional. Dicha malla la hemos cargado anteriormente en
el método <em>load_resources(std::string)</em>.</p>
<p>Por último, utilizamos dos funciones muy similares para obtener la
referencia a los SceneNode por su nombre:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 576)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   Ogre::SceneManager::getRootSceneNode();
   Ogre::SceneManager::getSceneNode(Ogre::String node_name);


</pre>
</div>
<p>El primero devuelve la referencia al nodo raíz del grafo de escena y
el segundo al nodo que coincida con el nombre que se le pase por
argumentos.</p>
<p>Por último, debemos añadir la sentencia que renderiza la escena. Para
poder parar nuestra aplicación, en este documento se hará uso de la
clase Ogre::WindowEventListener, que cuenta con el método
WindowClosing y windowClosed. Para ello crearemos una clase y haremos
que herede de Ogre::WindowEventListener:</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 592)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   #include &lt;OgreWindowEventUtilities.h&gt;

   class WindowManager: public Ogre::WindowEventListener{
     Ogre::RenderWindow* window_;

   public:
     bool exit;

     WindowManager(Ogre::RenderWindow* window){
       window_ = window;
       exit = false;
       Ogre::WindowEventUtilities::addWindowEventListener(window, this);
     }

     bool windowClosing(Ogre::RenderWindow* window){
       Ogre::LogManager::getSingleton().logMessage("Closing window...");
       exit = true;
       return true;
     }

     void windowClosed(Ogre::RenderWindow* window) {
       Ogre::LogManager::getSingleton().logMessage("Window closed.");
       exit = true;
     }

   int main(int argc, char *argv[])
   {
     (...)
     WindowManager windowManager(window);

     while(!windowManager.exit){
       root-&gt;renderOneFrame();
       Ogre::WindowEventUtilities::messagePump();
     }
   }
   };


</pre>
</div>
<p>La clase Ogre::WindowEventListener se encarga de gestionar todos los
eventos relacionados con una ventana.</p>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 635)</p>
<p>Cannot analyze code. No Pygments lexer found for "C++".</p>
<pre class="literal-block">
.. code:: C++

   Ogre::WindowEventUtilities::addWindowEventListener(window, this);

</pre>
</div>
<p>La sentencia anterior se encarga de registrar la instancia de la clase
WindowManager como gestor de todos los eventos producidos en
<em>window</em>. Los métodos <em>windowClosed</em> y
<em>windowClosing</em> se ejecutan cuando se detecta un evento de
cierre de ventana; es decir, cuando se pulsa el botón de salir de la
esquina superior derecha de la ventana.</p>
<p>Se ha añadido el bucle principal a la función principal. El método
<em>renderOneFrame</em> indica a Ogre que debe actualizar los cuerpos
gráficos de la escena, muestras que la sentencia
<em>messagePump()</em> debe ser llamada una vez por frame, ya que
actualizará todas las ventanas que hayan sido registradas.</p>
<p>Hecho esto, habremos terminado. Sólo faltará compilar y ejecutar
nuestra aplicación. El resultado deberá ser parecido al de la
siguiente figura.</p>
<div class="line-block">
<div class="line"><br></div>
</div>
<blockquote>
<img alt="captura-ejecucion.png" class="align-center" src="captura-ejecucion.png">
</blockquote>
<div class="line-block">
<div class="line"><br></div>
</div>
<p>El código final debe parecerse al del fichero que podremos encontrar
en el <a class="reference external" href="https://bitbucket.org/IsaacLacoba/intro-ogre/src/47e9565d0897607426587ef70798496f44f23ec8/src/main.cpp?at=master">repositorio de este tutorial</a></p>
<!-- LocalWords:  renderizada -->
</div>
</div>
</div>
    </div>
    <aside class="postpromonav">
    <nav>
    

    
        <ul class="pager">
            <li class="previous">
                <a href="../presentacion/presentacion.html" rel="prev" title="Presentación">Post anterior</a>
            </li>
            <li class="next">
                <a href="../justificacion-objetivos/justificacion-y-objetivos-del-proyecto.html" rel="next" title="Justificación y objetivos del proyecto">Siguiente post</a>
            </li>
        </ul>

    </nav>
    </aside>
    

</article>



        </div>
        <!--End of body content-->

        <footer>
            Contents © 2015         <a href="mailto:isaac.lacoba@gmail.com">Isaac Lacoba Molina</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
    </div>
</div>


            <script src="../../assets/js/all-nocdn.js"></script>
        <script src="../../assets/js/colorbox-i18n/jquery.colorbox-es.js"></script>
    
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul>
<li>
<a class="addthis_button_facebook"></a>
</li>
<li>
<a class="addthis_button_google_plusone_share"></a>
</li>
<li>
<a class="addthis_button_linkedin"></a>
</li>
<li>
<a class="addthis_button_twitter"></a>
</li>
</ul>
</div>
<script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script>jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    <!-- fancy dates -->
    <script>
    moment.locale("es");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script>
    <!-- end fancy dates -->
    
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-57580832-1', 'auto');ga('send', 'pageview');</script>

</body>
</html>
